var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// node_modules/@sveltejs/kit/dist/chunks/multipart-parser.js
var multipart_parser_exports = {};
__export(multipart_parser_exports, {
  toFormData: () => toFormData
});
function _fileName(headerValue) {
  const m2 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  if (!m2) {
    return;
  }
  const match2 = m2[2] || m2[3] || "";
  let filename = match2.slice(match2.lastIndexOf("\\") + 1);
  filename = filename.replace(/%22/g, '"');
  filename = filename.replace(/&#(\d{4});/g, (m3, code) => {
    return String.fromCharCode(code);
  });
  return filename;
}
async function toFormData(Body2, ct) {
  if (!/multipart/i.test(ct)) {
    throw new TypeError("Failed to fetch");
  }
  const m2 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!m2) {
    throw new TypeError("no or bad content-type header, no multipart boundary");
  }
  const parser = new MultipartParser(m2[1] || m2[2]);
  let headerField;
  let headerValue;
  let entryValue;
  let entryName;
  let contentType;
  let filename;
  const entryChunks = [];
  const formData = new FormData();
  const onPartData = (ui8a) => {
    entryValue += decoder.decode(ui8a, { stream: true });
  };
  const appendToFile = (ui8a) => {
    entryChunks.push(ui8a);
  };
  const appendFileToFormData = () => {
    const file = new File(entryChunks, filename, { type: contentType });
    formData.append(entryName, file);
  };
  const appendEntryToFormData = () => {
    formData.append(entryName, entryValue);
  };
  const decoder = new TextDecoder("utf-8");
  decoder.decode();
  parser.onPartBegin = function() {
    parser.onPartData = onPartData;
    parser.onPartEnd = appendEntryToFormData;
    headerField = "";
    headerValue = "";
    entryValue = "";
    entryName = "";
    contentType = "";
    filename = null;
    entryChunks.length = 0;
  };
  parser.onHeaderField = function(ui8a) {
    headerField += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderValue = function(ui8a) {
    headerValue += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderEnd = function() {
    headerValue += decoder.decode();
    headerField = headerField.toLowerCase();
    if (headerField === "content-disposition") {
      const m3 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
      if (m3) {
        entryName = m3[2] || m3[3] || "";
      }
      filename = _fileName(headerValue);
      if (filename) {
        parser.onPartData = appendToFile;
        parser.onPartEnd = appendFileToFormData;
      }
    } else if (headerField === "content-type") {
      contentType = headerValue;
    }
    headerValue = "";
    headerField = "";
  };
  for await (const chunk of Body2) {
    parser.write(chunk);
  }
  parser.end();
  return formData;
}
var import_node_worker_threads, s, S, f, F, LF, CR, SPACE, HYPHEN, COLON, A, Z, lower, noop, MultipartParser;
var init_multipart_parser = __esm({
  "node_modules/@sveltejs/kit/dist/chunks/multipart-parser.js"() {
    import_node_worker_threads = require("worker_threads");
    init_install_fetch();
    globalThis.DOMException || (() => {
      const port = new import_node_worker_threads.MessageChannel().port1;
      const ab = new ArrayBuffer(0);
      try {
        port.postMessage(ab, [ab, ab]);
      } catch (err) {
        return err.constructor;
      }
    })();
    s = 0;
    S = {
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      END: s++
    };
    f = 1;
    F = {
      PART_BOUNDARY: f,
      LAST_BOUNDARY: f *= 2
    };
    LF = 10;
    CR = 13;
    SPACE = 32;
    HYPHEN = 45;
    COLON = 58;
    A = 97;
    Z = 122;
    lower = (c) => c | 32;
    noop = () => {
    };
    MultipartParser = class {
      constructor(boundary) {
        this.index = 0;
        this.flags = 0;
        this.onHeaderEnd = noop;
        this.onHeaderField = noop;
        this.onHeadersEnd = noop;
        this.onHeaderValue = noop;
        this.onPartBegin = noop;
        this.onPartData = noop;
        this.onPartEnd = noop;
        this.boundaryChars = {};
        boundary = "\r\n--" + boundary;
        const ui8a = new Uint8Array(boundary.length);
        for (let i2 = 0; i2 < boundary.length; i2++) {
          ui8a[i2] = boundary.charCodeAt(i2);
          this.boundaryChars[ui8a[i2]] = true;
        }
        this.boundary = ui8a;
        this.lookbehind = new Uint8Array(this.boundary.length + 8);
        this.state = S.START_BOUNDARY;
      }
      write(data) {
        let i2 = 0;
        const length_ = data.length;
        let previousIndex = this.index;
        let { lookbehind, boundary, boundaryChars, index, state, flags } = this;
        const boundaryLength = this.boundary.length;
        const boundaryEnd = boundaryLength - 1;
        const bufferLength = data.length;
        let c;
        let cl;
        const mark = (name) => {
          this[name + "Mark"] = i2;
        };
        const clear = (name) => {
          delete this[name + "Mark"];
        };
        const callback = (callbackSymbol, start, end, ui8a) => {
          if (start === void 0 || start !== end) {
            this[callbackSymbol](ui8a && ui8a.subarray(start, end));
          }
        };
        const dataCallback = (name, clear2) => {
          const markSymbol = name + "Mark";
          if (!(markSymbol in this)) {
            return;
          }
          if (clear2) {
            callback(name, this[markSymbol], i2, data);
            delete this[markSymbol];
          } else {
            callback(name, this[markSymbol], data.length, data);
            this[markSymbol] = 0;
          }
        };
        for (i2 = 0; i2 < length_; i2++) {
          c = data[i2];
          switch (state) {
            case S.START_BOUNDARY:
              if (index === boundary.length - 2) {
                if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else if (c !== CR) {
                  return;
                }
                index++;
                break;
              } else if (index - 1 === boundary.length - 2) {
                if (flags & F.LAST_BOUNDARY && c === HYPHEN) {
                  state = S.END;
                  flags = 0;
                } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {
                  index = 0;
                  callback("onPartBegin");
                  state = S.HEADER_FIELD_START;
                } else {
                  return;
                }
                break;
              }
              if (c !== boundary[index + 2]) {
                index = -2;
              }
              if (c === boundary[index + 2]) {
                index++;
              }
              break;
            case S.HEADER_FIELD_START:
              state = S.HEADER_FIELD;
              mark("onHeaderField");
              index = 0;
            case S.HEADER_FIELD:
              if (c === CR) {
                clear("onHeaderField");
                state = S.HEADERS_ALMOST_DONE;
                break;
              }
              index++;
              if (c === HYPHEN) {
                break;
              }
              if (c === COLON) {
                if (index === 1) {
                  return;
                }
                dataCallback("onHeaderField", true);
                state = S.HEADER_VALUE_START;
                break;
              }
              cl = lower(c);
              if (cl < A || cl > Z) {
                return;
              }
              break;
            case S.HEADER_VALUE_START:
              if (c === SPACE) {
                break;
              }
              mark("onHeaderValue");
              state = S.HEADER_VALUE;
            case S.HEADER_VALUE:
              if (c === CR) {
                dataCallback("onHeaderValue", true);
                callback("onHeaderEnd");
                state = S.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              state = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              callback("onHeadersEnd");
              state = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              state = S.PART_DATA;
              mark("onPartData");
            case S.PART_DATA:
              previousIndex = index;
              if (index === 0) {
                i2 += boundaryEnd;
                while (i2 < bufferLength && !(data[i2] in boundaryChars)) {
                  i2 += boundaryLength;
                }
                i2 -= boundaryEnd;
                c = data[i2];
              }
              if (index < boundary.length) {
                if (boundary[index] === c) {
                  if (index === 0) {
                    dataCallback("onPartData", true);
                  }
                  index++;
                } else {
                  index = 0;
                }
              } else if (index === boundary.length) {
                index++;
                if (c === CR) {
                  flags |= F.PART_BOUNDARY;
                } else if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else {
                  index = 0;
                }
              } else if (index - 1 === boundary.length) {
                if (flags & F.PART_BOUNDARY) {
                  index = 0;
                  if (c === LF) {
                    flags &= ~F.PART_BOUNDARY;
                    callback("onPartEnd");
                    callback("onPartBegin");
                    state = S.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags & F.LAST_BOUNDARY) {
                  if (c === HYPHEN) {
                    callback("onPartEnd");
                    state = S.END;
                    flags = 0;
                  } else {
                    index = 0;
                  }
                } else {
                  index = 0;
                }
              }
              if (index > 0) {
                lookbehind[index - 1] = c;
              } else if (previousIndex > 0) {
                const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
                callback("onPartData", 0, previousIndex, _lookbehind);
                previousIndex = 0;
                mark("onPartData");
                i2--;
              }
              break;
            case S.END:
              break;
            default:
              throw new Error(`Unexpected state entered: ${state}`);
          }
        }
        dataCallback("onHeaderField");
        dataCallback("onHeaderValue");
        dataCallback("onPartData");
        this.index = index;
        this.state = state;
        this.flags = flags;
      }
      end() {
        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {
          this.onPartEnd();
        } else if (this.state !== S.END) {
          throw new Error("MultipartParser.end(): stream ended unexpectedly");
        }
      }
    };
  }
});

// node_modules/@sveltejs/kit/dist/install-fetch.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base642 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i2 = 1; i2 < meta.length; i2++) {
    if (meta[i2] === "base64") {
      base642 = true;
    } else {
      typeFull += `;${meta[i2]}`;
      if (meta[i2].indexOf("charset=") === 0) {
        charset = meta[i2].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base642 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
async function* toIterator(parts, clone2 = true) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else if (ArrayBuffer.isView(part)) {
      if (clone2) {
        let position = part.byteOffset;
        const end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position = 0;
      while (position !== part.size) {
        const chunk = part.slice(position, Math.min(part.size, position + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
function formDataToBlob(F2, B = Blob$1) {
  var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c = [], p = `--${b}\r
Content-Disposition: form-data; name="`;
  F2.forEach((v, n) => typeof v == "string" ? c.push(p + e(n) + `"\r
\r
${v.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r
`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r
Content-Type: ${v.type || "application/octet-stream"}\r
\r
`, v, "\r\n"));
  c.push(`--${b}--`);
  return new B(c, { type: "multipart/form-data; boundary=" + b });
}
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  const { body } = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (!(body instanceof import_node_stream.default)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error2 = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(error2);
        throw error2;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error2) {
    const error_ = error2 instanceof FetchBaseError ? error2 : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error2.message}`, "system", error2);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error2) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error2.message}`, "system", error2);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
function fromRawHeaders(headers = []) {
  return new Headers2(headers.reduce((result, value, index, array) => {
    if (index % 2 === 0) {
      result.push(array.slice(index, index + 2));
    }
    return result;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
function stripURLForUseAsAReferrer(url, originOnly = false) {
  if (url == null) {
    return "no-referrer";
  }
  url = new URL(url);
  if (/^(about|blob|data):$/.test(url.protocol)) {
    return "no-referrer";
  }
  url.username = "";
  url.password = "";
  url.hash = "";
  if (originOnly) {
    url.pathname = "";
    url.search = "";
  }
  return url;
}
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy)) {
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  }
  return referrerPolicy;
}
function isOriginPotentiallyTrustworthy(url) {
  if (/^(http|ws)s:$/.test(url.protocol)) {
    return true;
  }
  const hostIp = url.host.replace(/(^\[)|(]$)/g, "");
  const hostIPVersion = (0, import_net.isIP)(hostIp);
  if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
    return true;
  }
  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
    return true;
  }
  if (/^(.+\.)*localhost$/.test(url.host)) {
    return false;
  }
  if (url.protocol === "file:") {
    return true;
  }
  return false;
}
function isUrlPotentiallyTrustworthy(url) {
  if (/^about:(blank|srcdoc)$/.test(url)) {
    return true;
  }
  if (url.protocol === "data:") {
    return true;
  }
  if (/^(blob|filesystem):$/.test(url.protocol)) {
    return true;
  }
  return isOriginPotentiallyTrustworthy(url);
}
function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {
  if (request.referrer === "no-referrer" || request.referrerPolicy === "") {
    return null;
  }
  const policy = request.referrerPolicy;
  if (request.referrer === "about:client") {
    return "no-referrer";
  }
  const referrerSource = request.referrer;
  let referrerURL = stripURLForUseAsAReferrer(referrerSource);
  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
  if (referrerURL.toString().length > 4096) {
    referrerURL = referrerOrigin;
  }
  if (referrerURLCallback) {
    referrerURL = referrerURLCallback(referrerURL);
  }
  if (referrerOriginCallback) {
    referrerOrigin = referrerOriginCallback(referrerOrigin);
  }
  const currentURL = new URL(request.url);
  switch (policy) {
    case "no-referrer":
      return "no-referrer";
    case "origin":
      return referrerOrigin;
    case "unsafe-url":
      return referrerURL;
    case "strict-origin":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin.toString();
    case "strict-origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin;
    case "same-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return "no-referrer";
    case "origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return referrerOrigin;
    case "no-referrer-when-downgrade":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  }
}
function parseReferrerPolicyFromHeader(headers) {
  const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
  let policy = "";
  for (const token of policyTokens) {
    if (token && ReferrerPolicy.has(token)) {
      policy = token;
    }
  }
  return policy;
}
async function fetch2(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request2(url, options_);
    const { parsedURL, options } = getNodeRequestOptions(request);
    if (!supportedSchemas.has(parsedURL.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (parsedURL.protocol === "data:") {
      const data = dataUriToBuffer(request.url);
      const response2 = new Response2(data, { headers: { "Content-Type": data.typeFull } });
      resolve2(response2);
      return;
    }
    const send = (parsedURL.protocol === "https:" ? import_node_https.default : import_node_http.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error2 = new AbortError("The operation was aborted.");
      reject(error2);
      if (request.body && request.body instanceof import_node_stream.default.Readable) {
        request.body.destroy(error2);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error2);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(parsedURL, options);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error2) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error2.message}`, "system", error2));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error2) => {
      response.body.destroy(error2);
    });
    if (process.version < "v14") {
      request_.on("socket", (s3) => {
        let endedWithEventsCount;
        s3.prependListener("end", () => {
          endedWithEventsCount = s3._eventsCount;
        });
        s3.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s3._eventsCount && !hadError) {
            const error2 = new Error("Premature close");
            error2.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error2);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        const locationURL = location === null ? null : new URL(location, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              headers.set("Location", locationURL);
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers2(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: clone(request),
              signal: request.signal,
              size: request.size,
              referrer: request.referrer,
              referrerPolicy: request.referrerPolicy
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_node_stream.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
            if (responseReferrerPolicy) {
              requestOptions.referrerPolicy = responseReferrerPolicy;
            }
            resolve2(fetch2(new Request2(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = (0, import_node_stream.pipeline)(response_, new import_node_stream.PassThrough(), reject);
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_node_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_node_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_node_stream.pipeline)(body, import_node_zlib.default.createGunzip(zlibOptions), reject);
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_node_stream.pipeline)(response_, new import_node_stream.PassThrough(), reject);
        raw.once("data", (chunk) => {
          body = (chunk[0] & 15) === 8 ? (0, import_node_stream.pipeline)(body, import_node_zlib.default.createInflate(), reject) : (0, import_node_stream.pipeline)(body, import_node_zlib.default.createInflateRaw(), reject);
          response = new Response2(body, responseOptions);
          resolve2(response);
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_node_stream.pipeline)(body, import_node_zlib.default.createBrotliDecompress(), reject);
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response2(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = Buffer.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error2 = new Error("Premature close");
        error2.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error2);
      }
    };
    socket.prependListener("close", onSocketClose);
    request.on("abort", () => {
      socket.removeListener("close", onSocketClose);
    });
    socket.on("data", (buf) => {
      properLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    });
  });
}
function installFetch() {
  Object.defineProperties(globalThis, {
    fetch: {
      enumerable: true,
      configurable: true,
      value: fetch2
    },
    Response: {
      enumerable: true,
      configurable: true,
      value: Response2
    },
    Request: {
      enumerable: true,
      configurable: true,
      value: Request2
    },
    Headers: {
      enumerable: true,
      configurable: true,
      value: Headers2
    }
  });
}
var import_node_http, import_node_https, import_node_zlib, import_node_stream, import_node_util, import_node_url, import_net, commonjsGlobal, ponyfill_es2018, POOL_SIZE$1, POOL_SIZE, _parts, _type, _size, _a, _Blob, Blob, Blob$1, _lastModified, _name, _a2, _File, File, t, i, h, r, m, f2, e, x, _d, _a3, FormData, FetchBaseError, FetchError, NAME, isURLSearchParameters, isBlob, isAbortSignal, INTERNALS$2, Body, clone, getNonSpecFormDataBoundary, extractContentType, getTotalBytes, writeToStream, validateHeaderName, validateHeaderValue, Headers2, redirectStatus, isRedirect, INTERNALS$1, Response2, getSearch, ReferrerPolicy, DEFAULT_REFERRER_POLICY, INTERNALS, isRequest, Request2, getNodeRequestOptions, AbortError, supportedSchemas;
var init_install_fetch = __esm({
  "node_modules/@sveltejs/kit/dist/install-fetch.js"() {
    import_node_http = __toESM(require("http"), 1);
    import_node_https = __toESM(require("https"), 1);
    import_node_zlib = __toESM(require("zlib"), 1);
    import_node_stream = __toESM(require("stream"), 1);
    import_node_util = require("util");
    import_node_url = require("url");
    import_net = require("net");
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    ponyfill_es2018 = { exports: {} };
    (function(module2, exports) {
      (function(global2, factory) {
        factory(exports);
      })(commonjsGlobal, function(exports2) {
        const SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : (description) => `Symbol(${description})`;
        function noop4() {
          return void 0;
        }
        function getGlobals() {
          if (typeof self !== "undefined") {
            return self;
          } else if (typeof window !== "undefined") {
            return window;
          } else if (typeof commonjsGlobal !== "undefined") {
            return commonjsGlobal;
          }
          return void 0;
        }
        const globals = getGlobals();
        function typeIsObject(x2) {
          return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
        }
        const rethrowAssertionErrorRejection = noop4;
        const originalPromise = Promise;
        const originalPromiseThen = Promise.prototype.then;
        const originalPromiseResolve = Promise.resolve.bind(originalPromise);
        const originalPromiseReject = Promise.reject.bind(originalPromise);
        function newPromise(executor) {
          return new originalPromise(executor);
        }
        function promiseResolvedWith(value) {
          return originalPromiseResolve(value);
        }
        function promiseRejectedWith(reason) {
          return originalPromiseReject(reason);
        }
        function PerformPromiseThen(promise, onFulfilled, onRejected) {
          return originalPromiseThen.call(promise, onFulfilled, onRejected);
        }
        function uponPromise(promise, onFulfilled, onRejected) {
          PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
        }
        function uponFulfillment(promise, onFulfilled) {
          uponPromise(promise, onFulfilled);
        }
        function uponRejection(promise, onRejected) {
          uponPromise(promise, void 0, onRejected);
        }
        function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
          return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
        }
        function setPromiseIsHandledToTrue(promise) {
          PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
        }
        const queueMicrotask = (() => {
          const globalQueueMicrotask = globals && globals.queueMicrotask;
          if (typeof globalQueueMicrotask === "function") {
            return globalQueueMicrotask;
          }
          const resolvedPromise = promiseResolvedWith(void 0);
          return (fn) => PerformPromiseThen(resolvedPromise, fn);
        })();
        function reflectCall(F2, V, args) {
          if (typeof F2 !== "function") {
            throw new TypeError("Argument is not a function");
          }
          return Function.prototype.apply.call(F2, V, args);
        }
        function promiseCall(F2, V, args) {
          try {
            return promiseResolvedWith(reflectCall(F2, V, args));
          } catch (value) {
            return promiseRejectedWith(value);
          }
        }
        const QUEUE_MAX_ARRAY_SIZE = 16384;
        class SimpleQueue {
          constructor() {
            this._cursor = 0;
            this._size = 0;
            this._front = {
              _elements: [],
              _next: void 0
            };
            this._back = this._front;
            this._cursor = 0;
            this._size = 0;
          }
          get length() {
            return this._size;
          }
          push(element) {
            const oldBack = this._back;
            let newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
              newBack = {
                _elements: [],
                _next: void 0
              };
            }
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
              this._back = newBack;
              oldBack._next = newBack;
            }
            ++this._size;
          }
          shift() {
            const oldFront = this._front;
            let newFront = oldFront;
            const oldCursor = this._cursor;
            let newCursor = oldCursor + 1;
            const elements = oldFront._elements;
            const element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
              newFront = oldFront._next;
              newCursor = 0;
            }
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
              this._front = newFront;
            }
            elements[oldCursor] = void 0;
            return element;
          }
          forEach(callback) {
            let i2 = this._cursor;
            let node = this._front;
            let elements = node._elements;
            while (i2 !== elements.length || node._next !== void 0) {
              if (i2 === elements.length) {
                node = node._next;
                elements = node._elements;
                i2 = 0;
                if (elements.length === 0) {
                  break;
                }
              }
              callback(elements[i2]);
              ++i2;
            }
          }
          peek() {
            const front = this._front;
            const cursor = this._cursor;
            return front._elements[cursor];
          }
        }
        function ReadableStreamReaderGenericInitialize(reader, stream) {
          reader._ownerReadableStream = stream;
          stream._reader = reader;
          if (stream._state === "readable") {
            defaultReaderClosedPromiseInitialize(reader);
          } else if (stream._state === "closed") {
            defaultReaderClosedPromiseInitializeAsResolved(reader);
          } else {
            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
          }
        }
        function ReadableStreamReaderGenericCancel(reader, reason) {
          const stream = reader._ownerReadableStream;
          return ReadableStreamCancel(stream, reason);
        }
        function ReadableStreamReaderGenericRelease(reader) {
          if (reader._ownerReadableStream._state === "readable") {
            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          } else {
            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          }
          reader._ownerReadableStream._reader = void 0;
          reader._ownerReadableStream = void 0;
        }
        function readerLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released reader");
        }
        function defaultReaderClosedPromiseInitialize(reader) {
          reader._closedPromise = newPromise((resolve2, reject) => {
            reader._closedPromise_resolve = resolve2;
            reader._closedPromise_reject = reject;
          });
        }
        function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseReject(reader, reason);
        }
        function defaultReaderClosedPromiseInitializeAsResolved(reader) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseResolve(reader);
        }
        function defaultReaderClosedPromiseReject(reader, reason) {
          if (reader._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(reader._closedPromise);
          reader._closedPromise_reject(reason);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        function defaultReaderClosedPromiseResetToRejected(reader, reason) {
          defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
        }
        function defaultReaderClosedPromiseResolve(reader) {
          if (reader._closedPromise_resolve === void 0) {
            return;
          }
          reader._closedPromise_resolve(void 0);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        const AbortSteps = SymbolPolyfill("[[AbortSteps]]");
        const ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
        const CancelSteps = SymbolPolyfill("[[CancelSteps]]");
        const PullSteps = SymbolPolyfill("[[PullSteps]]");
        const NumberIsFinite2 = Number.isFinite || function(x2) {
          return typeof x2 === "number" && isFinite(x2);
        };
        const MathTrunc2 = Math.trunc || function(v) {
          return v < 0 ? Math.ceil(v) : Math.floor(v);
        };
        function isDictionary(x2) {
          return typeof x2 === "object" || typeof x2 === "function";
        }
        function assertDictionary(obj, context) {
          if (obj !== void 0 && !isDictionary(obj)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertFunction(x2, context) {
          if (typeof x2 !== "function") {
            throw new TypeError(`${context} is not a function.`);
          }
        }
        function isObject(x2) {
          return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
        }
        function assertObject(x2, context) {
          if (!isObject(x2)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertRequiredArgument(x2, position, context) {
          if (x2 === void 0) {
            throw new TypeError(`Parameter ${position} is required in '${context}'.`);
          }
        }
        function assertRequiredField(x2, field, context) {
          if (x2 === void 0) {
            throw new TypeError(`${field} is required in '${context}'.`);
          }
        }
        function convertUnrestrictedDouble(value) {
          return Number(value);
        }
        function censorNegativeZero(x2) {
          return x2 === 0 ? 0 : x2;
        }
        function integerPart(x2) {
          return censorNegativeZero(MathTrunc2(x2));
        }
        function convertUnsignedLongLongWithEnforceRange(value, context) {
          const lowerBound = 0;
          const upperBound = Number.MAX_SAFE_INTEGER;
          let x2 = Number(value);
          x2 = censorNegativeZero(x2);
          if (!NumberIsFinite2(x2)) {
            throw new TypeError(`${context} is not a finite number`);
          }
          x2 = integerPart(x2);
          if (x2 < lowerBound || x2 > upperBound) {
            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
          }
          if (!NumberIsFinite2(x2) || x2 === 0) {
            return 0;
          }
          return x2;
        }
        function assertReadableStream(x2, context) {
          if (!IsReadableStream(x2)) {
            throw new TypeError(`${context} is not a ReadableStream.`);
          }
        }
        function AcquireReadableStreamDefaultReader(stream) {
          return new ReadableStreamDefaultReader(stream);
        }
        function ReadableStreamAddReadRequest(stream, readRequest) {
          stream._reader._readRequests.push(readRequest);
        }
        function ReadableStreamFulfillReadRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readRequest = reader._readRequests.shift();
          if (done) {
            readRequest._closeSteps();
          } else {
            readRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadRequests(stream) {
          return stream._reader._readRequests.length;
        }
        function ReadableStreamHasDefaultReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamDefaultReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamDefaultReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("read"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: () => resolvePromise({ value: void 0, done: true }),
              _errorSteps: (e2) => rejectPromise(e2)
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamDefaultReader(this)) {
              throw defaultReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamDefaultReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultReader",
            configurable: true
          });
        }
        function IsReadableStreamDefaultReader(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_readRequests")) {
            return false;
          }
          return x2 instanceof ReadableStreamDefaultReader;
        }
        function ReadableStreamDefaultReaderRead(reader, readRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "closed") {
            readRequest._closeSteps();
          } else if (stream._state === "errored") {
            readRequest._errorSteps(stream._storedError);
          } else {
            stream._readableStreamController[PullSteps](readRequest);
          }
        }
        function defaultReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
        }
        const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
        }).prototype);
        class ReadableStreamAsyncIteratorImpl {
          constructor(reader, preventCancel) {
            this._ongoingPromise = void 0;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
          }
          next() {
            const nextSteps = () => this._nextSteps();
            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
            return this._ongoingPromise;
          }
          return(value) {
            const returnSteps = () => this._returnSteps(value);
            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
          }
          _nextSteps() {
            if (this._isFinished) {
              return Promise.resolve({ value: void 0, done: true });
            }
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("iterate"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => {
                this._ongoingPromise = void 0;
                queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
              },
              _closeSteps: () => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                resolvePromise({ value: void 0, done: true });
              },
              _errorSteps: (reason) => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                rejectPromise(reason);
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
          }
          _returnSteps(value) {
            if (this._isFinished) {
              return Promise.resolve({ value, done: true });
            }
            this._isFinished = true;
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("finish iterating"));
            }
            if (!this._preventCancel) {
              const result = ReadableStreamReaderGenericCancel(reader, value);
              ReadableStreamReaderGenericRelease(reader);
              return transformPromiseWith(result, () => ({ value, done: true }));
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({ value, done: true });
          }
        }
        const ReadableStreamAsyncIteratorPrototype = {
          next() {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
            }
            return this._asyncIteratorImpl.next();
          },
          return(value) {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
            }
            return this._asyncIteratorImpl.return(value);
          }
        };
        if (AsyncIteratorPrototype !== void 0) {
          Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
        }
        function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          const impl2 = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
          const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
          iterator._asyncIteratorImpl = impl2;
          return iterator;
        }
        function IsReadableStreamAsyncIterator(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_asyncIteratorImpl")) {
            return false;
          }
          try {
            return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
          } catch (_a4) {
            return false;
          }
        }
        function streamAsyncIteratorBrandCheckException(name) {
          return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
        }
        const NumberIsNaN2 = Number.isNaN || function(x2) {
          return x2 !== x2;
        };
        function CreateArrayFromList(elements) {
          return elements.slice();
        }
        function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
          new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
        }
        function TransferArrayBuffer(O) {
          return O;
        }
        function IsDetachedBuffer(O) {
          return false;
        }
        function ArrayBufferSlice(buffer, begin, end) {
          if (buffer.slice) {
            return buffer.slice(begin, end);
          }
          const length = end - begin;
          const slice = new ArrayBuffer(length);
          CopyDataBlockBytes(slice, 0, buffer, begin, length);
          return slice;
        }
        function IsNonNegativeNumber(v) {
          if (typeof v !== "number") {
            return false;
          }
          if (NumberIsNaN2(v)) {
            return false;
          }
          if (v < 0) {
            return false;
          }
          return true;
        }
        function CloneAsUint8Array(O) {
          const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
          return new Uint8Array(buffer);
        }
        function DequeueValue(container) {
          const pair = container._queue.shift();
          container._queueTotalSize -= pair.size;
          if (container._queueTotalSize < 0) {
            container._queueTotalSize = 0;
          }
          return pair.value;
        }
        function EnqueueValueWithSize(container, value, size) {
          if (!IsNonNegativeNumber(size) || size === Infinity) {
            throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
          }
          container._queue.push({ value, size });
          container._queueTotalSize += size;
        }
        function PeekQueueValue(container) {
          const pair = container._queue.peek();
          return pair.value;
        }
        function ResetQueue(container) {
          container._queue = new SimpleQueue();
          container._queueTotalSize = 0;
        }
        class ReadableStreamBYOBRequest {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get view() {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("view");
            }
            return this._view;
          }
          respond(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respond");
            }
            assertRequiredArgument(bytesWritten, 1, "respond");
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(this._view.buffer))
              ;
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
          }
          respondWithNewView(view) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respondWithNewView");
            }
            assertRequiredArgument(view, 1, "respondWithNewView");
            if (!ArrayBuffer.isView(view)) {
              throw new TypeError("You can only respond with array buffer views");
            }
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
          }
        }
        Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
          respond: { enumerable: true },
          respondWithNewView: { enumerable: true },
          view: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBRequest",
            configurable: true
          });
        }
        class ReadableByteStreamController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get byobRequest() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("byobRequest");
            }
            return ReadableByteStreamControllerGetBYOBRequest(this);
          }
          get desiredSize() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("desiredSize");
            }
            return ReadableByteStreamControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("close");
            }
            if (this._closeRequested) {
              throw new TypeError("The stream has already been closed; do not close it again!");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
            }
            ReadableByteStreamControllerClose(this);
          }
          enqueue(chunk) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("enqueue");
            }
            assertRequiredArgument(chunk, 1, "enqueue");
            if (!ArrayBuffer.isView(chunk)) {
              throw new TypeError("chunk must be an array buffer view");
            }
            if (chunk.byteLength === 0) {
              throw new TypeError("chunk must have non-zero byteLength");
            }
            if (chunk.buffer.byteLength === 0) {
              throw new TypeError(`chunk's buffer must have non-zero byteLength`);
            }
            if (this._closeRequested) {
              throw new TypeError("stream is closed or draining");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
          }
          error(e2 = void 0) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("error");
            }
            ReadableByteStreamControllerError(this, e2);
          }
          [CancelSteps](reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
              const entry11 = this._queue.shift();
              this._queueTotalSize -= entry11.byteLength;
              ReadableByteStreamControllerHandleQueueDrain(this);
              const view = new Uint8Array(entry11.buffer, entry11.byteOffset, entry11.byteLength);
              readRequest._chunkSteps(view);
              return;
            }
            const autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== void 0) {
              let buffer;
              try {
                buffer = new ArrayBuffer(autoAllocateChunkSize);
              } catch (bufferE) {
                readRequest._errorSteps(bufferE);
                return;
              }
              const pullIntoDescriptor = {
                buffer,
                bufferByteLength: autoAllocateChunkSize,
                byteOffset: 0,
                byteLength: autoAllocateChunkSize,
                bytesFilled: 0,
                elementSize: 1,
                viewConstructor: Uint8Array,
                readerType: "default"
              };
              this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
          }
        }
        Object.defineProperties(ReadableByteStreamController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          byobRequest: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableByteStreamController",
            configurable: true
          });
        }
        function IsReadableByteStreamController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableByteStream")) {
            return false;
          }
          return x2 instanceof ReadableByteStreamController;
        }
        function IsReadableStreamBYOBRequest(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_associatedReadableByteStreamController")) {
            return false;
          }
          return x2 instanceof ReadableStreamBYOBRequest;
        }
        function ReadableByteStreamControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
          }, (e2) => {
            ReadableByteStreamControllerError(controller, e2);
          });
        }
        function ReadableByteStreamControllerClearPendingPullIntos(controller) {
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          controller._pendingPullIntos = new SimpleQueue();
        }
        function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
          let done = false;
          if (stream._state === "closed") {
            done = true;
          }
          const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
          if (pullIntoDescriptor.readerType === "default") {
            ReadableStreamFulfillReadRequest(stream, filledView, done);
          } else {
            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
          }
        }
        function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
          const bytesFilled = pullIntoDescriptor.bytesFilled;
          const elementSize = pullIntoDescriptor.elementSize;
          return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
        }
        function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
          controller._queue.push({ buffer, byteOffset, byteLength });
          controller._queueTotalSize += byteLength;
        }
        function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
          const elementSize = pullIntoDescriptor.elementSize;
          const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
          const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
          const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
          const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
          let totalBytesToCopyRemaining = maxBytesToCopy;
          let ready = false;
          if (maxAlignedBytes > currentAlignedBytes) {
            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
            ready = true;
          }
          const queue = controller._queue;
          while (totalBytesToCopyRemaining > 0) {
            const headOfQueue = queue.peek();
            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
            if (headOfQueue.byteLength === bytesToCopy) {
              queue.shift();
            } else {
              headOfQueue.byteOffset += bytesToCopy;
              headOfQueue.byteLength -= bytesToCopy;
            }
            controller._queueTotalSize -= bytesToCopy;
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
            totalBytesToCopyRemaining -= bytesToCopy;
          }
          return ready;
        }
        function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
          pullIntoDescriptor.bytesFilled += size;
        }
        function ReadableByteStreamControllerHandleQueueDrain(controller) {
          if (controller._queueTotalSize === 0 && controller._closeRequested) {
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(controller._controlledReadableByteStream);
          } else {
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }
        function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
          if (controller._byobRequest === null) {
            return;
          }
          controller._byobRequest._associatedReadableByteStreamController = void 0;
          controller._byobRequest._view = null;
          controller._byobRequest = null;
        }
        function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
          while (controller._pendingPullIntos.length > 0) {
            if (controller._queueTotalSize === 0) {
              return;
            }
            const pullIntoDescriptor = controller._pendingPullIntos.peek();
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
          const stream = controller._controlledReadableByteStream;
          let elementSize = 1;
          if (view.constructor !== DataView) {
            elementSize = view.constructor.BYTES_PER_ELEMENT;
          }
          const ctor = view.constructor;
          const buffer = TransferArrayBuffer(view.buffer);
          const pullIntoDescriptor = {
            buffer,
            bufferByteLength: buffer.byteLength,
            byteOffset: view.byteOffset,
            byteLength: view.byteLength,
            bytesFilled: 0,
            elementSize,
            viewConstructor: ctor,
            readerType: "byob"
          };
          if (controller._pendingPullIntos.length > 0) {
            controller._pendingPullIntos.push(pullIntoDescriptor);
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            return;
          }
          if (stream._state === "closed") {
            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
            readIntoRequest._closeSteps(emptyView);
            return;
          }
          if (controller._queueTotalSize > 0) {
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
              ReadableByteStreamControllerHandleQueueDrain(controller);
              readIntoRequest._chunkSteps(filledView);
              return;
            }
            if (controller._closeRequested) {
              const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e2);
              readIntoRequest._errorSteps(e2);
              return;
            }
          }
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
          const stream = controller._controlledReadableByteStream;
          if (ReadableStreamHasBYOBReader(stream)) {
            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
              const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
          if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
            return;
          }
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
          if (remainderSize > 0) {
            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
          }
          pullIntoDescriptor.bytesFilled -= remainderSize;
          ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
        function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            ReadableByteStreamControllerRespondInClosedState(controller);
          } else {
            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerShiftPendingPullInto(controller) {
          const descriptor2 = controller._pendingPullIntos.shift();
          return descriptor2;
        }
        function ReadableByteStreamControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return false;
          }
          if (controller._closeRequested) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableByteStreamControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
        }
        function ReadableByteStreamControllerClose(controller) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          if (controller._queueTotalSize > 0) {
            controller._closeRequested = true;
            return;
          }
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
              const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e2);
              throw e2;
            }
          }
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
        function ReadableByteStreamControllerEnqueue(controller, chunk) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          const buffer = chunk.buffer;
          const byteOffset = chunk.byteOffset;
          const byteLength = chunk.byteLength;
          const transferredBuffer = TransferArrayBuffer(buffer);
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (IsDetachedBuffer(firstPendingPullInto.buffer))
              ;
            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          if (ReadableStreamHasDefaultReader(stream)) {
            if (ReadableStreamGetNumReadRequests(stream) === 0) {
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            } else {
              if (controller._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerShiftPendingPullInto(controller);
              }
              const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
              ReadableStreamFulfillReadRequest(stream, transferredView, false);
            }
          } else if (ReadableStreamHasBYOBReader(stream)) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          } else {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerError(controller, e2) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return;
          }
          ReadableByteStreamControllerClearPendingPullIntos(controller);
          ResetQueue(controller);
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e2);
        }
        function ReadableByteStreamControllerGetBYOBRequest(controller) {
          if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
            const firstDescriptor = controller._pendingPullIntos.peek();
            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
            controller._byobRequest = byobRequest;
          }
          return controller._byobRequest;
        }
        function ReadableByteStreamControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableByteStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableByteStreamControllerRespond(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (bytesWritten !== 0) {
              throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
            }
          } else {
            if (bytesWritten === 0) {
              throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
            }
            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
              throw new RangeError("bytesWritten out of range");
            }
          }
          firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
          ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
        }
        function ReadableByteStreamControllerRespondWithNewView(controller, view) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (view.byteLength !== 0) {
              throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
            }
          } else {
            if (view.byteLength === 0) {
              throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
            }
          }
          if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
            throw new RangeError("The region specified by view does not match byobRequest");
          }
          if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
            throw new RangeError("The buffer of view has different capacity than byobRequest");
          }
          if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
            throw new RangeError("The region specified by view is larger than byobRequest");
          }
          const viewByteLength = view.byteLength;
          firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
          ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
        }
        function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
          controller._controlledReadableByteStream = stream;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._byobRequest = null;
          controller._queue = controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._closeRequested = false;
          controller._started = false;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          controller._autoAllocateChunkSize = autoAllocateChunkSize;
          controller._pendingPullIntos = new SimpleQueue();
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }, (r2) => {
            ReadableByteStreamControllerError(controller, r2);
          });
        }
        function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
          const controller = Object.create(ReadableByteStreamController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingByteSource.start !== void 0) {
            startAlgorithm = () => underlyingByteSource.start(controller);
          }
          if (underlyingByteSource.pull !== void 0) {
            pullAlgorithm = () => underlyingByteSource.pull(controller);
          }
          if (underlyingByteSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
          }
          const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
          if (autoAllocateChunkSize === 0) {
            throw new TypeError("autoAllocateChunkSize must be greater than 0");
          }
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
        }
        function SetUpReadableStreamBYOBRequest(request, controller, view) {
          request._associatedReadableByteStreamController = controller;
          request._view = view;
        }
        function byobRequestBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
        }
        function byteStreamControllerBrandCheckException(name) {
          return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
        }
        function AcquireReadableStreamBYOBReader(stream) {
          return new ReadableStreamBYOBReader(stream);
        }
        function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
          stream._reader._readIntoRequests.push(readIntoRequest);
        }
        function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readIntoRequest = reader._readIntoRequests.shift();
          if (done) {
            readIntoRequest._closeSteps(chunk);
          } else {
            readIntoRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadIntoRequests(stream) {
          return stream._reader._readIntoRequests.length;
        }
        function ReadableStreamHasBYOBReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamBYOBReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamBYOBReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            if (!IsReadableByteStreamController(stream._readableStreamController)) {
              throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readIntoRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read(view) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("read"));
            }
            if (!ArrayBuffer.isView(view)) {
              return promiseRejectedWith(new TypeError("view must be an array buffer view"));
            }
            if (view.byteLength === 0) {
              return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
            }
            if (view.buffer.byteLength === 0) {
              return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readIntoRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
              _errorSteps: (e2) => rejectPromise(e2)
            };
            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamBYOBReader(this)) {
              throw byobReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readIntoRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamBYOBReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBReader",
            configurable: true
          });
        }
        function IsReadableStreamBYOBReader(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_readIntoRequests")) {
            return false;
          }
          return x2 instanceof ReadableStreamBYOBReader;
        }
        function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "errored") {
            readIntoRequest._errorSteps(stream._storedError);
          } else {
            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
          }
        }
        function byobReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
        }
        function ExtractHighWaterMark(strategy, defaultHWM) {
          const { highWaterMark } = strategy;
          if (highWaterMark === void 0) {
            return defaultHWM;
          }
          if (NumberIsNaN2(highWaterMark) || highWaterMark < 0) {
            throw new RangeError("Invalid highWaterMark");
          }
          return highWaterMark;
        }
        function ExtractSizeAlgorithm(strategy) {
          const { size } = strategy;
          if (!size) {
            return () => 1;
          }
          return size;
        }
        function convertQueuingStrategy(init2, context) {
          assertDictionary(init2, context);
          const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
          const size = init2 === null || init2 === void 0 ? void 0 : init2.size;
          return {
            highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
            size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
          };
        }
        function convertQueuingStrategySize(fn, context) {
          assertFunction(fn, context);
          return (chunk) => convertUnrestrictedDouble(fn(chunk));
        }
        function convertUnderlyingSink(original, context) {
          assertDictionary(original, context);
          const abort = original === null || original === void 0 ? void 0 : original.abort;
          const close = original === null || original === void 0 ? void 0 : original.close;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          const write = original === null || original === void 0 ? void 0 : original.write;
          return {
            abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
            close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
            start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
            write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
            type
          };
        }
        function convertUnderlyingSinkAbortCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSinkCloseCallback(fn, original, context) {
          assertFunction(fn, context);
          return () => promiseCall(fn, original, []);
        }
        function convertUnderlyingSinkStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertUnderlyingSinkWriteCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        function assertWritableStream(x2, context) {
          if (!IsWritableStream(x2)) {
            throw new TypeError(`${context} is not a WritableStream.`);
          }
        }
        function isAbortSignal2(value) {
          if (typeof value !== "object" || value === null) {
            return false;
          }
          try {
            return typeof value.aborted === "boolean";
          } catch (_a4) {
            return false;
          }
        }
        const supportsAbortController = typeof AbortController === "function";
        function createAbortController() {
          if (supportsAbortController) {
            return new AbortController();
          }
          return void 0;
        }
        class WritableStream {
          constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
            if (rawUnderlyingSink === void 0) {
              rawUnderlyingSink = null;
            } else {
              assertObject(rawUnderlyingSink, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
            InitializeWritableStream(this);
            const type = underlyingSink.type;
            if (type !== void 0) {
              throw new RangeError("Invalid type is specified");
            }
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
          }
          get locked() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("locked");
            }
            return IsWritableStreamLocked(this);
          }
          abort(reason = void 0) {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("abort"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
            }
            return WritableStreamAbort(this, reason);
          }
          close() {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("close"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamClose(this);
          }
          getWriter() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("getWriter");
            }
            return AcquireWritableStreamDefaultWriter(this);
          }
        }
        Object.defineProperties(WritableStream.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          getWriter: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStream",
            configurable: true
          });
        }
        function AcquireWritableStreamDefaultWriter(stream) {
          return new WritableStreamDefaultWriter(stream);
        }
        function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(WritableStream.prototype);
          InitializeWritableStream(stream);
          const controller = Object.create(WritableStreamDefaultController.prototype);
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function InitializeWritableStream(stream) {
          stream._state = "writable";
          stream._storedError = void 0;
          stream._writer = void 0;
          stream._writableStreamController = void 0;
          stream._writeRequests = new SimpleQueue();
          stream._inFlightWriteRequest = void 0;
          stream._closeRequest = void 0;
          stream._inFlightCloseRequest = void 0;
          stream._pendingAbortRequest = void 0;
          stream._backpressure = false;
        }
        function IsWritableStream(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_writableStreamController")) {
            return false;
          }
          return x2 instanceof WritableStream;
        }
        function IsWritableStreamLocked(stream) {
          if (stream._writer === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamAbort(stream, reason) {
          var _a4;
          if (stream._state === "closed" || stream._state === "errored") {
            return promiseResolvedWith(void 0);
          }
          stream._writableStreamController._abortReason = reason;
          (_a4 = stream._writableStreamController._abortController) === null || _a4 === void 0 ? void 0 : _a4.abort();
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseResolvedWith(void 0);
          }
          if (stream._pendingAbortRequest !== void 0) {
            return stream._pendingAbortRequest._promise;
          }
          let wasAlreadyErroring = false;
          if (state === "erroring") {
            wasAlreadyErroring = true;
            reason = void 0;
          }
          const promise = newPromise((resolve2, reject) => {
            stream._pendingAbortRequest = {
              _promise: void 0,
              _resolve: resolve2,
              _reject: reject,
              _reason: reason,
              _wasAlreadyErroring: wasAlreadyErroring
            };
          });
          stream._pendingAbortRequest._promise = promise;
          if (!wasAlreadyErroring) {
            WritableStreamStartErroring(stream, reason);
          }
          return promise;
        }
        function WritableStreamClose(stream) {
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
          }
          const promise = newPromise((resolve2, reject) => {
            const closeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._closeRequest = closeRequest;
          });
          const writer = stream._writer;
          if (writer !== void 0 && stream._backpressure && state === "writable") {
            defaultWriterReadyPromiseResolve(writer);
          }
          WritableStreamDefaultControllerClose(stream._writableStreamController);
          return promise;
        }
        function WritableStreamAddWriteRequest(stream) {
          const promise = newPromise((resolve2, reject) => {
            const writeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._writeRequests.push(writeRequest);
          });
          return promise;
        }
        function WritableStreamDealWithRejection(stream, error2) {
          const state = stream._state;
          if (state === "writable") {
            WritableStreamStartErroring(stream, error2);
            return;
          }
          WritableStreamFinishErroring(stream);
        }
        function WritableStreamStartErroring(stream, reason) {
          const controller = stream._writableStreamController;
          stream._state = "erroring";
          stream._storedError = reason;
          const writer = stream._writer;
          if (writer !== void 0) {
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
          }
          if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
            WritableStreamFinishErroring(stream);
          }
        }
        function WritableStreamFinishErroring(stream) {
          stream._state = "errored";
          stream._writableStreamController[ErrorSteps]();
          const storedError = stream._storedError;
          stream._writeRequests.forEach((writeRequest) => {
            writeRequest._reject(storedError);
          });
          stream._writeRequests = new SimpleQueue();
          if (stream._pendingAbortRequest === void 0) {
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const abortRequest = stream._pendingAbortRequest;
          stream._pendingAbortRequest = void 0;
          if (abortRequest._wasAlreadyErroring) {
            abortRequest._reject(storedError);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
          uponPromise(promise, () => {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          }, (reason) => {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          });
        }
        function WritableStreamFinishInFlightWrite(stream) {
          stream._inFlightWriteRequest._resolve(void 0);
          stream._inFlightWriteRequest = void 0;
        }
        function WritableStreamFinishInFlightWriteWithError(stream, error2) {
          stream._inFlightWriteRequest._reject(error2);
          stream._inFlightWriteRequest = void 0;
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamFinishInFlightClose(stream) {
          stream._inFlightCloseRequest._resolve(void 0);
          stream._inFlightCloseRequest = void 0;
          const state = stream._state;
          if (state === "erroring") {
            stream._storedError = void 0;
            if (stream._pendingAbortRequest !== void 0) {
              stream._pendingAbortRequest._resolve();
              stream._pendingAbortRequest = void 0;
            }
          }
          stream._state = "closed";
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseResolve(writer);
          }
        }
        function WritableStreamFinishInFlightCloseWithError(stream, error2) {
          stream._inFlightCloseRequest._reject(error2);
          stream._inFlightCloseRequest = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._reject(error2);
            stream._pendingAbortRequest = void 0;
          }
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamCloseQueuedOrInFlight(stream) {
          if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamHasOperationMarkedInFlight(stream) {
          if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamMarkCloseRequestInFlight(stream) {
          stream._inFlightCloseRequest = stream._closeRequest;
          stream._closeRequest = void 0;
        }
        function WritableStreamMarkFirstWriteRequestInFlight(stream) {
          stream._inFlightWriteRequest = stream._writeRequests.shift();
        }
        function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
          if (stream._closeRequest !== void 0) {
            stream._closeRequest._reject(stream._storedError);
            stream._closeRequest = void 0;
          }
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseReject(writer, stream._storedError);
          }
        }
        function WritableStreamUpdateBackpressure(stream, backpressure) {
          const writer = stream._writer;
          if (writer !== void 0 && backpressure !== stream._backpressure) {
            if (backpressure) {
              defaultWriterReadyPromiseReset(writer);
            } else {
              defaultWriterReadyPromiseResolve(writer);
            }
          }
          stream._backpressure = backpressure;
        }
        class WritableStreamDefaultWriter {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
            assertWritableStream(stream, "First parameter");
            if (IsWritableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            }
            this._ownerWritableStream = stream;
            stream._writer = this;
            const state = stream._state;
            if (state === "writable") {
              if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                defaultWriterReadyPromiseInitialize(this);
              } else {
                defaultWriterReadyPromiseInitializeAsResolved(this);
              }
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "erroring") {
              defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "closed") {
              defaultWriterReadyPromiseInitializeAsResolved(this);
              defaultWriterClosedPromiseInitializeAsResolved(this);
            } else {
              const storedError = stream._storedError;
              defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
              defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
          }
          get closed() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          get desiredSize() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("desiredSize");
            }
            if (this._ownerWritableStream === void 0) {
              throw defaultWriterLockException("desiredSize");
            }
            return WritableStreamDefaultWriterGetDesiredSize(this);
          }
          get ready() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
            }
            return this._readyPromise;
          }
          abort(reason = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("abort"));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
          }
          close() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("close"));
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("close"));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamDefaultWriterClose(this);
          }
          releaseLock() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("releaseLock");
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return;
            }
            WritableStreamDefaultWriterRelease(this);
          }
          write(chunk = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("write"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("write to"));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
          }
        }
        Object.defineProperties(WritableStreamDefaultWriter.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          releaseLock: { enumerable: true },
          write: { enumerable: true },
          closed: { enumerable: true },
          desiredSize: { enumerable: true },
          ready: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultWriter",
            configurable: true
          });
        }
        function IsWritableStreamDefaultWriter(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_ownerWritableStream")) {
            return false;
          }
          return x2 instanceof WritableStreamDefaultWriter;
        }
        function WritableStreamDefaultWriterAbort(writer, reason) {
          const stream = writer._ownerWritableStream;
          return WritableStreamAbort(stream, reason);
        }
        function WritableStreamDefaultWriterClose(writer) {
          const stream = writer._ownerWritableStream;
          return WritableStreamClose(stream);
        }
        function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          return WritableStreamDefaultWriterClose(writer);
        }
        function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error2) {
          if (writer._closedPromiseState === "pending") {
            defaultWriterClosedPromiseReject(writer, error2);
          } else {
            defaultWriterClosedPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error2) {
          if (writer._readyPromiseState === "pending") {
            defaultWriterReadyPromiseReject(writer, error2);
          } else {
            defaultWriterReadyPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterGetDesiredSize(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (state === "errored" || state === "erroring") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
        }
        function WritableStreamDefaultWriterRelease(writer) {
          const stream = writer._ownerWritableStream;
          const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
          WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
          stream._writer = void 0;
          writer._ownerWritableStream = void 0;
        }
        function WritableStreamDefaultWriterWrite(writer, chunk) {
          const stream = writer._ownerWritableStream;
          const controller = stream._writableStreamController;
          const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
          if (stream !== writer._ownerWritableStream) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          const state = stream._state;
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
          }
          if (state === "erroring") {
            return promiseRejectedWith(stream._storedError);
          }
          const promise = WritableStreamAddWriteRequest(stream);
          WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
          return promise;
        }
        const closeSentinel = {};
        class WritableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get abortReason() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("abortReason");
            }
            return this._abortReason;
          }
          get signal() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("signal");
            }
            if (this._abortController === void 0) {
              throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
            }
            return this._abortController.signal;
          }
          error(e2 = void 0) {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("error");
            }
            const state = this._controlledWritableStream._state;
            if (state !== "writable") {
              return;
            }
            WritableStreamDefaultControllerError(this, e2);
          }
          [AbortSteps](reason) {
            const result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [ErrorSteps]() {
            ResetQueue(this);
          }
        }
        Object.defineProperties(WritableStreamDefaultController.prototype, {
          abortReason: { enumerable: true },
          signal: { enumerable: true },
          error: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultController",
            configurable: true
          });
        }
        function IsWritableStreamDefaultController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledWritableStream")) {
            return false;
          }
          return x2 instanceof WritableStreamDefaultController;
        }
        function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledWritableStream = stream;
          stream._writableStreamController = controller;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._abortReason = void 0;
          controller._abortController = createAbortController();
          controller._started = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._writeAlgorithm = writeAlgorithm;
          controller._closeAlgorithm = closeAlgorithm;
          controller._abortAlgorithm = abortAlgorithm;
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
          const startResult = startAlgorithm();
          const startPromise = promiseResolvedWith(startResult);
          uponPromise(startPromise, () => {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (r2) => {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r2);
          });
        }
        function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(WritableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let writeAlgorithm = () => promiseResolvedWith(void 0);
          let closeAlgorithm = () => promiseResolvedWith(void 0);
          let abortAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSink.start !== void 0) {
            startAlgorithm = () => underlyingSink.start(controller);
          }
          if (underlyingSink.write !== void 0) {
            writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
          }
          if (underlyingSink.close !== void 0) {
            closeAlgorithm = () => underlyingSink.close();
          }
          if (underlyingSink.abort !== void 0) {
            abortAlgorithm = (reason) => underlyingSink.abort(reason);
          }
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function WritableStreamDefaultControllerClearAlgorithms(controller) {
          controller._writeAlgorithm = void 0;
          controller._closeAlgorithm = void 0;
          controller._abortAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function WritableStreamDefaultControllerClose(controller) {
          EnqueueValueWithSize(controller, closeSentinel, 0);
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
          try {
            return controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
            return 1;
          }
        }
        function WritableStreamDefaultControllerGetDesiredSize(controller) {
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
            return;
          }
          const stream = controller._controlledWritableStream;
          if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
          const stream = controller._controlledWritableStream;
          if (!controller._started) {
            return;
          }
          if (stream._inFlightWriteRequest !== void 0) {
            return;
          }
          const state = stream._state;
          if (state === "erroring") {
            WritableStreamFinishErroring(stream);
            return;
          }
          if (controller._queue.length === 0) {
            return;
          }
          const value = PeekQueueValue(controller);
          if (value === closeSentinel) {
            WritableStreamDefaultControllerProcessClose(controller);
          } else {
            WritableStreamDefaultControllerProcessWrite(controller, value);
          }
        }
        function WritableStreamDefaultControllerErrorIfNeeded(controller, error2) {
          if (controller._controlledWritableStream._state === "writable") {
            WritableStreamDefaultControllerError(controller, error2);
          }
        }
        function WritableStreamDefaultControllerProcessClose(controller) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkCloseRequestInFlight(stream);
          DequeueValue(controller);
          const sinkClosePromise = controller._closeAlgorithm();
          WritableStreamDefaultControllerClearAlgorithms(controller);
          uponPromise(sinkClosePromise, () => {
            WritableStreamFinishInFlightClose(stream);
          }, (reason) => {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkFirstWriteRequestInFlight(stream);
          const sinkWritePromise = controller._writeAlgorithm(chunk);
          uponPromise(sinkWritePromise, () => {
            WritableStreamFinishInFlightWrite(stream);
            const state = stream._state;
            DequeueValue(controller);
            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
              const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
              WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (reason) => {
            if (stream._state === "writable") {
              WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerGetBackpressure(controller) {
          const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
          return desiredSize <= 0;
        }
        function WritableStreamDefaultControllerError(controller, error2) {
          const stream = controller._controlledWritableStream;
          WritableStreamDefaultControllerClearAlgorithms(controller);
          WritableStreamStartErroring(stream, error2);
        }
        function streamBrandCheckException$2(name) {
          return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
        }
        function defaultControllerBrandCheckException$2(name) {
          return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
        }
        function defaultWriterBrandCheckException(name) {
          return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
        }
        function defaultWriterLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released writer");
        }
        function defaultWriterClosedPromiseInitialize(writer) {
          writer._closedPromise = newPromise((resolve2, reject) => {
            writer._closedPromise_resolve = resolve2;
            writer._closedPromise_reject = reject;
            writer._closedPromiseState = "pending";
          });
        }
        function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseReject(writer, reason);
        }
        function defaultWriterClosedPromiseInitializeAsResolved(writer) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseResolve(writer);
        }
        function defaultWriterClosedPromiseReject(writer, reason) {
          if (writer._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._closedPromise);
          writer._closedPromise_reject(reason);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "rejected";
        }
        function defaultWriterClosedPromiseResetToRejected(writer, reason) {
          defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterClosedPromiseResolve(writer) {
          if (writer._closedPromise_resolve === void 0) {
            return;
          }
          writer._closedPromise_resolve(void 0);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "resolved";
        }
        function defaultWriterReadyPromiseInitialize(writer) {
          writer._readyPromise = newPromise((resolve2, reject) => {
            writer._readyPromise_resolve = resolve2;
            writer._readyPromise_reject = reject;
          });
          writer._readyPromiseState = "pending";
        }
        function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseReject(writer, reason);
        }
        function defaultWriterReadyPromiseInitializeAsResolved(writer) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseResolve(writer);
        }
        function defaultWriterReadyPromiseReject(writer, reason) {
          if (writer._readyPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._readyPromise);
          writer._readyPromise_reject(reason);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "rejected";
        }
        function defaultWriterReadyPromiseReset(writer) {
          defaultWriterReadyPromiseInitialize(writer);
        }
        function defaultWriterReadyPromiseResetToRejected(writer, reason) {
          defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterReadyPromiseResolve(writer) {
          if (writer._readyPromise_resolve === void 0) {
            return;
          }
          writer._readyPromise_resolve(void 0);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "fulfilled";
        }
        const NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
        function isDOMExceptionConstructor(ctor) {
          if (!(typeof ctor === "function" || typeof ctor === "object")) {
            return false;
          }
          try {
            new ctor();
            return true;
          } catch (_a4) {
            return false;
          }
        }
        function createDOMExceptionPolyfill() {
          const ctor = function DOMException2(message, name) {
            this.message = message || "";
            this.name = name || "Error";
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          };
          ctor.prototype = Object.create(Error.prototype);
          Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
          return ctor;
        }
        const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
        function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
          const reader = AcquireReadableStreamDefaultReader(source);
          const writer = AcquireWritableStreamDefaultWriter(dest);
          source._disturbed = true;
          let shuttingDown = false;
          let currentWrite = promiseResolvedWith(void 0);
          return newPromise((resolve2, reject) => {
            let abortAlgorithm;
            if (signal !== void 0) {
              abortAlgorithm = () => {
                const error2 = new DOMException$1("Aborted", "AbortError");
                const actions = [];
                if (!preventAbort) {
                  actions.push(() => {
                    if (dest._state === "writable") {
                      return WritableStreamAbort(dest, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                if (!preventCancel) {
                  actions.push(() => {
                    if (source._state === "readable") {
                      return ReadableStreamCancel(source, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error2);
              };
              if (signal.aborted) {
                abortAlgorithm();
                return;
              }
              signal.addEventListener("abort", abortAlgorithm);
            }
            function pipeLoop() {
              return newPromise((resolveLoop, rejectLoop) => {
                function next(done) {
                  if (done) {
                    resolveLoop();
                  } else {
                    PerformPromiseThen(pipeStep(), next, rejectLoop);
                  }
                }
                next(false);
              });
            }
            function pipeStep() {
              if (shuttingDown) {
                return promiseResolvedWith(true);
              }
              return PerformPromiseThen(writer._readyPromise, () => {
                return newPromise((resolveRead, rejectRead) => {
                  ReadableStreamDefaultReaderRead(reader, {
                    _chunkSteps: (chunk) => {
                      currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop4);
                      resolveRead(false);
                    },
                    _closeSteps: () => resolveRead(true),
                    _errorSteps: rejectRead
                  });
                });
              });
            }
            isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
              if (!preventAbort) {
                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesClosed(source, reader._closedPromise, () => {
              if (!preventClose) {
                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
              } else {
                shutdown();
              }
            });
            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
              const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
              } else {
                shutdown(true, destClosed);
              }
            }
            setPromiseIsHandledToTrue(pipeLoop());
            function waitForWritesToFinish() {
              const oldCurrentWrite = currentWrite;
              return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
            }
            function isOrBecomesErrored(stream, promise, action) {
              if (stream._state === "errored") {
                action(stream._storedError);
              } else {
                uponRejection(promise, action);
              }
            }
            function isOrBecomesClosed(stream, promise, action) {
              if (stream._state === "closed") {
                action();
              } else {
                uponFulfillment(promise, action);
              }
            }
            function shutdownWithAction(action, originalIsError, originalError) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), doTheRest);
              } else {
                doTheRest();
              }
              function doTheRest() {
                uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
              }
            }
            function shutdown(isError, error2) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error2));
              } else {
                finalize(isError, error2);
              }
            }
            function finalize(isError, error2) {
              WritableStreamDefaultWriterRelease(writer);
              ReadableStreamReaderGenericRelease(reader);
              if (signal !== void 0) {
                signal.removeEventListener("abort", abortAlgorithm);
              }
              if (isError) {
                reject(error2);
              } else {
                resolve2(void 0);
              }
            }
          });
        }
        class ReadableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("desiredSize");
            }
            return ReadableStreamDefaultControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("close");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits close");
            }
            ReadableStreamDefaultControllerClose(this);
          }
          enqueue(chunk = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("enqueue");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits enqueue");
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
          }
          error(e2 = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("error");
            }
            ReadableStreamDefaultControllerError(this, e2);
          }
          [CancelSteps](reason) {
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
              const chunk = DequeueValue(this);
              if (this._closeRequested && this._queue.length === 0) {
                ReadableStreamDefaultControllerClearAlgorithms(this);
                ReadableStreamClose(stream);
              } else {
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
              }
              readRequest._chunkSteps(chunk);
            } else {
              ReadableStreamAddReadRequest(stream, readRequest);
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
          }
        }
        Object.defineProperties(ReadableStreamDefaultController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultController",
            configurable: true
          });
        }
        function IsReadableStreamDefaultController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableStream")) {
            return false;
          }
          return x2 instanceof ReadableStreamDefaultController;
        }
        function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
          }, (e2) => {
            ReadableStreamDefaultControllerError(controller, e2);
          });
        }
        function ReadableStreamDefaultControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableStream;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableStreamDefaultControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function ReadableStreamDefaultControllerClose(controller) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          controller._closeRequested = true;
          if (controller._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
          }
        }
        function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            ReadableStreamFulfillReadRequest(stream, chunk, false);
          } else {
            let chunkSize;
            try {
              chunkSize = controller._strategySizeAlgorithm(chunk);
            } catch (chunkSizeE) {
              ReadableStreamDefaultControllerError(controller, chunkSizeE);
              throw chunkSizeE;
            }
            try {
              EnqueueValueWithSize(controller, chunk, chunkSize);
            } catch (enqueueE) {
              ReadableStreamDefaultControllerError(controller, enqueueE);
              throw enqueueE;
            }
          }
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
        function ReadableStreamDefaultControllerError(controller, e2) {
          const stream = controller._controlledReadableStream;
          if (stream._state !== "readable") {
            return;
          }
          ResetQueue(controller);
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e2);
        }
        function ReadableStreamDefaultControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableStreamDefaultControllerHasBackpressure(controller) {
          if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
            return false;
          }
          return true;
        }
        function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
          const state = controller._controlledReadableStream._state;
          if (!controller._closeRequested && state === "readable") {
            return true;
          }
          return false;
        }
        function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledReadableStream = stream;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._started = false;
          controller._closeRequested = false;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }, (r2) => {
            ReadableStreamDefaultControllerError(controller, r2);
          });
        }
        function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSource.start !== void 0) {
            startAlgorithm = () => underlyingSource.start(controller);
          }
          if (underlyingSource.pull !== void 0) {
            pullAlgorithm = () => underlyingSource.pull(controller);
          }
          if (underlyingSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
          }
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function defaultControllerBrandCheckException$1(name) {
          return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
        }
        function ReadableStreamTee(stream, cloneForBranch2) {
          if (IsReadableByteStreamController(stream._readableStreamController)) {
            return ReadableByteStreamTee(stream);
          }
          return ReadableStreamDefaultTee(stream);
        }
        function ReadableStreamDefaultTee(stream, cloneForBranch2) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let readAgain = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function pullAlgorithm() {
            if (reading) {
              readAgain = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgain = false;
                  const chunk1 = chunk;
                  const chunk2 = chunk;
                  if (!canceled1) {
                    ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgain) {
                    pullAlgorithm();
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
          }
          branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
          branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
          uponRejection(reader._closedPromise, (r2) => {
            ReadableStreamDefaultControllerError(branch1._readableStreamController, r2);
            ReadableStreamDefaultControllerError(branch2._readableStreamController, r2);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
          return [branch1, branch2];
        }
        function ReadableByteStreamTee(stream) {
          let reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let readAgainForBranch1 = false;
          let readAgainForBranch2 = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function forwardReaderError(thisReader) {
            uponRejection(thisReader._closedPromise, (r2) => {
              if (thisReader !== reader) {
                return;
              }
              ReadableByteStreamControllerError(branch1._readableStreamController, r2);
              ReadableByteStreamControllerError(branch2._readableStreamController, r2);
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            });
          }
          function pullWithDefaultReader() {
            if (IsReadableStreamBYOBReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamDefaultReader(stream);
              forwardReaderError(reader);
            }
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  const chunk1 = chunk;
                  let chunk2 = chunk;
                  if (!canceled1 && !canceled2) {
                    try {
                      chunk2 = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                  }
                  if (!canceled1) {
                    ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableByteStreamControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerClose(branch2._readableStreamController);
                }
                if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                }
                if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
          }
          function pullWithBYOBReader(view, forBranch2) {
            if (IsReadableStreamDefaultReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamBYOBReader(stream);
              forwardReaderError(reader);
            }
            const byobBranch = forBranch2 ? branch2 : branch1;
            const otherBranch = forBranch2 ? branch1 : branch2;
            const readIntoRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  const byobCanceled = forBranch2 ? canceled2 : canceled1;
                  const otherCanceled = forBranch2 ? canceled1 : canceled2;
                  if (!otherCanceled) {
                    let clonedChunk;
                    try {
                      clonedChunk = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                    if (!byobCanceled) {
                      ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                    }
                    ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                  } else if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: (chunk) => {
                reading = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!byobCanceled) {
                  ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                }
                if (!otherCanceled) {
                  ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                }
                if (chunk !== void 0) {
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                  }
                }
                if (!byobCanceled || !otherCanceled) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
          }
          function pull1Algorithm() {
            if (reading) {
              readAgainForBranch1 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, false);
            }
            return promiseResolvedWith(void 0);
          }
          function pull2Algorithm() {
            if (reading) {
              readAgainForBranch2 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, true);
            }
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
            return;
          }
          branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
          branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
          forwardReaderError(reader);
          return [branch1, branch2];
        }
        function convertUnderlyingDefaultOrByteSource(source, context) {
          assertDictionary(source, context);
          const original = source;
          const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
          const cancel = original === null || original === void 0 ? void 0 : original.cancel;
          const pull = original === null || original === void 0 ? void 0 : original.pull;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          return {
            autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
            cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
            pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
            start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
            type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
          };
        }
        function convertUnderlyingSourceCancelCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSourcePullCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertUnderlyingSourceStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertReadableStreamType(type, context) {
          type = `${type}`;
          if (type !== "bytes") {
            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
          }
          return type;
        }
        function convertReaderOptions(options, context) {
          assertDictionary(options, context);
          const mode = options === null || options === void 0 ? void 0 : options.mode;
          return {
            mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
          };
        }
        function convertReadableStreamReaderMode(mode, context) {
          mode = `${mode}`;
          if (mode !== "byob") {
            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
          }
          return mode;
        }
        function convertIteratorOptions(options, context) {
          assertDictionary(options, context);
          const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
          return { preventCancel: Boolean(preventCancel) };
        }
        function convertPipeOptions(options, context) {
          assertDictionary(options, context);
          const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
          const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
          const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
          const signal = options === null || options === void 0 ? void 0 : options.signal;
          if (signal !== void 0) {
            assertAbortSignal(signal, `${context} has member 'signal' that`);
          }
          return {
            preventAbort: Boolean(preventAbort),
            preventCancel: Boolean(preventCancel),
            preventClose: Boolean(preventClose),
            signal
          };
        }
        function assertAbortSignal(signal, context) {
          if (!isAbortSignal2(signal)) {
            throw new TypeError(`${context} is not an AbortSignal.`);
          }
        }
        function convertReadableWritablePair(pair, context) {
          assertDictionary(pair, context);
          const readable2 = pair === null || pair === void 0 ? void 0 : pair.readable;
          assertRequiredField(readable2, "readable", "ReadableWritablePair");
          assertReadableStream(readable2, `${context} has member 'readable' that`);
          const writable3 = pair === null || pair === void 0 ? void 0 : pair.writable;
          assertRequiredField(writable3, "writable", "ReadableWritablePair");
          assertWritableStream(writable3, `${context} has member 'writable' that`);
          return { readable: readable2, writable: writable3 };
        }
        class ReadableStream2 {
          constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
            if (rawUnderlyingSource === void 0) {
              rawUnderlyingSource = null;
            } else {
              assertObject(rawUnderlyingSource, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
            InitializeReadableStream(this);
            if (underlyingSource.type === "bytes") {
              if (strategy.size !== void 0) {
                throw new RangeError("The strategy for a byte stream cannot have a size function");
              }
              const highWaterMark = ExtractHighWaterMark(strategy, 0);
              SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            } else {
              const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
              const highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
          }
          get locked() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("locked");
            }
            return IsReadableStreamLocked(this);
          }
          cancel(reason = void 0) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("cancel"));
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
            }
            return ReadableStreamCancel(this, reason);
          }
          getReader(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("getReader");
            }
            const options = convertReaderOptions(rawOptions, "First parameter");
            if (options.mode === void 0) {
              return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
          }
          pipeThrough(rawTransform, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("pipeThrough");
            }
            assertRequiredArgument(rawTransform, 1, "pipeThrough");
            const transform = convertReadableWritablePair(rawTransform, "First parameter");
            const options = convertPipeOptions(rawOptions, "Second parameter");
            if (IsReadableStreamLocked(this)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            }
            if (IsWritableStreamLocked(transform.writable)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            }
            const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
            setPromiseIsHandledToTrue(promise);
            return transform.readable;
          }
          pipeTo(destination, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
            }
            if (destination === void 0) {
              return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
            }
            if (!IsWritableStream(destination)) {
              return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
            }
            let options;
            try {
              options = convertPipeOptions(rawOptions, "Second parameter");
            } catch (e2) {
              return promiseRejectedWith(e2);
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
            }
            if (IsWritableStreamLocked(destination)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
            }
            return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          }
          tee() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("tee");
            }
            const branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
          }
          values(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("values");
            }
            const options = convertIteratorOptions(rawOptions, "First parameter");
            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
          }
        }
        Object.defineProperties(ReadableStream2.prototype, {
          cancel: { enumerable: true },
          getReader: { enumerable: true },
          pipeThrough: { enumerable: true },
          pipeTo: { enumerable: true },
          tee: { enumerable: true },
          values: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStream",
            configurable: true
          });
        }
        if (typeof SymbolPolyfill.asyncIterator === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
            value: ReadableStream2.prototype.values,
            writable: true,
            configurable: true
          });
        }
        function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableByteStreamController.prototype);
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
          return stream;
        }
        function InitializeReadableStream(stream) {
          stream._state = "readable";
          stream._reader = void 0;
          stream._storedError = void 0;
          stream._disturbed = false;
        }
        function IsReadableStream(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_readableStreamController")) {
            return false;
          }
          return x2 instanceof ReadableStream2;
        }
        function IsReadableStreamLocked(stream) {
          if (stream._reader === void 0) {
            return false;
          }
          return true;
        }
        function ReadableStreamCancel(stream, reason) {
          stream._disturbed = true;
          if (stream._state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (stream._state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          ReadableStreamClose(stream);
          const reader = stream._reader;
          if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._closeSteps(void 0);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
          const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
          return transformPromiseWith(sourceCancelPromise, noop4);
        }
        function ReadableStreamClose(stream) {
          stream._state = "closed";
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseResolve(reader);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._closeSteps();
            });
            reader._readRequests = new SimpleQueue();
          }
        }
        function ReadableStreamError(stream, e2) {
          stream._state = "errored";
          stream._storedError = e2;
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseReject(reader, e2);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._errorSteps(e2);
            });
            reader._readRequests = new SimpleQueue();
          } else {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._errorSteps(e2);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
        }
        function streamBrandCheckException$1(name) {
          return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
        }
        function convertQueuingStrategyInit(init2, context) {
          assertDictionary(init2, context);
          const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
          assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
          return {
            highWaterMark: convertUnrestrictedDouble(highWaterMark)
          };
        }
        const byteLengthSizeFunction = (chunk) => {
          return chunk.byteLength;
        };
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class ByteLengthQueuingStrategy {
          constructor(options) {
            assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
            options = convertQueuingStrategyInit(options, "First parameter");
            this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          get highWaterMark() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("highWaterMark");
            }
            return this._byteLengthQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("size");
            }
            return byteLengthSizeFunction;
          }
        }
        Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "ByteLengthQueuingStrategy",
            configurable: true
          });
        }
        function byteLengthBrandCheckException(name) {
          return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
        }
        function IsByteLengthQueuingStrategy(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_byteLengthQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x2 instanceof ByteLengthQueuingStrategy;
        }
        const countSizeFunction = () => {
          return 1;
        };
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class CountQueuingStrategy {
          constructor(options) {
            assertRequiredArgument(options, 1, "CountQueuingStrategy");
            options = convertQueuingStrategyInit(options, "First parameter");
            this._countQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          get highWaterMark() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("highWaterMark");
            }
            return this._countQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("size");
            }
            return countSizeFunction;
          }
        }
        Object.defineProperties(CountQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "CountQueuingStrategy",
            configurable: true
          });
        }
        function countBrandCheckException(name) {
          return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
        }
        function IsCountQueuingStrategy(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_countQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x2 instanceof CountQueuingStrategy;
        }
        function convertTransformer(original, context) {
          assertDictionary(original, context);
          const flush = original === null || original === void 0 ? void 0 : original.flush;
          const readableType = original === null || original === void 0 ? void 0 : original.readableType;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const transform = original === null || original === void 0 ? void 0 : original.transform;
          const writableType = original === null || original === void 0 ? void 0 : original.writableType;
          return {
            flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
            readableType,
            start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
            transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
            writableType
          };
        }
        function convertTransformerFlushCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertTransformerStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertTransformerTransformCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        class TransformStream {
          constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
            if (rawTransformer === void 0) {
              rawTransformer = null;
            }
            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
            const transformer = convertTransformer(rawTransformer, "First parameter");
            if (transformer.readableType !== void 0) {
              throw new RangeError("Invalid readableType specified");
            }
            if (transformer.writableType !== void 0) {
              throw new RangeError("Invalid writableType specified");
            }
            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            let startPromise_resolve;
            const startPromise = newPromise((resolve2) => {
              startPromise_resolve = resolve2;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
            if (transformer.start !== void 0) {
              startPromise_resolve(transformer.start(this._transformStreamController));
            } else {
              startPromise_resolve(void 0);
            }
          }
          get readable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("readable");
            }
            return this._readable;
          }
          get writable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("writable");
            }
            return this._writable;
          }
        }
        Object.defineProperties(TransformStream.prototype, {
          readable: { enumerable: true },
          writable: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStream",
            configurable: true
          });
        }
        function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
          function startAlgorithm() {
            return startPromise;
          }
          function writeAlgorithm(chunk) {
            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
          }
          function abortAlgorithm(reason) {
            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
          }
          function closeAlgorithm() {
            return TransformStreamDefaultSinkCloseAlgorithm(stream);
          }
          stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
          function pullAlgorithm() {
            return TransformStreamDefaultSourcePullAlgorithm(stream);
          }
          function cancelAlgorithm(reason) {
            TransformStreamErrorWritableAndUnblockWrite(stream, reason);
            return promiseResolvedWith(void 0);
          }
          stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          stream._backpressure = void 0;
          stream._backpressureChangePromise = void 0;
          stream._backpressureChangePromise_resolve = void 0;
          TransformStreamSetBackpressure(stream, true);
          stream._transformStreamController = void 0;
        }
        function IsTransformStream(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_transformStreamController")) {
            return false;
          }
          return x2 instanceof TransformStream;
        }
        function TransformStreamError(stream, e2) {
          ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e2);
          TransformStreamErrorWritableAndUnblockWrite(stream, e2);
        }
        function TransformStreamErrorWritableAndUnblockWrite(stream, e2) {
          TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
          WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e2);
          if (stream._backpressure) {
            TransformStreamSetBackpressure(stream, false);
          }
        }
        function TransformStreamSetBackpressure(stream, backpressure) {
          if (stream._backpressureChangePromise !== void 0) {
            stream._backpressureChangePromise_resolve();
          }
          stream._backpressureChangePromise = newPromise((resolve2) => {
            stream._backpressureChangePromise_resolve = resolve2;
          });
          stream._backpressure = backpressure;
        }
        class TransformStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("desiredSize");
            }
            const readableController = this._controlledTransformStream._readable._readableStreamController;
            return ReadableStreamDefaultControllerGetDesiredSize(readableController);
          }
          enqueue(chunk = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("enqueue");
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
          }
          error(reason = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("error");
            }
            TransformStreamDefaultControllerError(this, reason);
          }
          terminate() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("terminate");
            }
            TransformStreamDefaultControllerTerminate(this);
          }
        }
        Object.defineProperties(TransformStreamDefaultController.prototype, {
          enqueue: { enumerable: true },
          error: { enumerable: true },
          terminate: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStreamDefaultController",
            configurable: true
          });
        }
        function IsTransformStreamDefaultController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledTransformStream")) {
            return false;
          }
          return x2 instanceof TransformStreamDefaultController;
        }
        function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
          controller._controlledTransformStream = stream;
          stream._transformStreamController = controller;
          controller._transformAlgorithm = transformAlgorithm;
          controller._flushAlgorithm = flushAlgorithm;
        }
        function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
          const controller = Object.create(TransformStreamDefaultController.prototype);
          let transformAlgorithm = (chunk) => {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
          let flushAlgorithm = () => promiseResolvedWith(void 0);
          if (transformer.transform !== void 0) {
            transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
          }
          if (transformer.flush !== void 0) {
            flushAlgorithm = () => transformer.flush(controller);
          }
          SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
        }
        function TransformStreamDefaultControllerClearAlgorithms(controller) {
          controller._transformAlgorithm = void 0;
          controller._flushAlgorithm = void 0;
        }
        function TransformStreamDefaultControllerEnqueue(controller, chunk) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
            throw new TypeError("Readable side is not in a state that permits enqueue");
          }
          try {
            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
          } catch (e2) {
            TransformStreamErrorWritableAndUnblockWrite(stream, e2);
            throw stream._readable._storedError;
          }
          const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
          if (backpressure !== stream._backpressure) {
            TransformStreamSetBackpressure(stream, true);
          }
        }
        function TransformStreamDefaultControllerError(controller, e2) {
          TransformStreamError(controller._controlledTransformStream, e2);
        }
        function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
          const transformPromise = controller._transformAlgorithm(chunk);
          return transformPromiseWith(transformPromise, void 0, (r2) => {
            TransformStreamError(controller._controlledTransformStream, r2);
            throw r2;
          });
        }
        function TransformStreamDefaultControllerTerminate(controller) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          ReadableStreamDefaultControllerClose(readableController);
          const error2 = new TypeError("TransformStream terminated");
          TransformStreamErrorWritableAndUnblockWrite(stream, error2);
        }
        function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
          const controller = stream._transformStreamController;
          if (stream._backpressure) {
            const backpressureChangePromise = stream._backpressureChangePromise;
            return transformPromiseWith(backpressureChangePromise, () => {
              const writable3 = stream._writable;
              const state = writable3._state;
              if (state === "erroring") {
                throw writable3._storedError;
              }
              return TransformStreamDefaultControllerPerformTransform(controller, chunk);
            });
          }
          return TransformStreamDefaultControllerPerformTransform(controller, chunk);
        }
        function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
          TransformStreamError(stream, reason);
          return promiseResolvedWith(void 0);
        }
        function TransformStreamDefaultSinkCloseAlgorithm(stream) {
          const readable2 = stream._readable;
          const controller = stream._transformStreamController;
          const flushPromise = controller._flushAlgorithm();
          TransformStreamDefaultControllerClearAlgorithms(controller);
          return transformPromiseWith(flushPromise, () => {
            if (readable2._state === "errored") {
              throw readable2._storedError;
            }
            ReadableStreamDefaultControllerClose(readable2._readableStreamController);
          }, (r2) => {
            TransformStreamError(stream, r2);
            throw readable2._storedError;
          });
        }
        function TransformStreamDefaultSourcePullAlgorithm(stream) {
          TransformStreamSetBackpressure(stream, false);
          return stream._backpressureChangePromise;
        }
        function defaultControllerBrandCheckException(name) {
          return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
        }
        function streamBrandCheckException(name) {
          return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
        }
        exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
        exports2.CountQueuingStrategy = CountQueuingStrategy;
        exports2.ReadableByteStreamController = ReadableByteStreamController;
        exports2.ReadableStream = ReadableStream2;
        exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
        exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
        exports2.ReadableStreamDefaultController = ReadableStreamDefaultController;
        exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
        exports2.TransformStream = TransformStream;
        exports2.TransformStreamDefaultController = TransformStreamDefaultController;
        exports2.WritableStream = WritableStream;
        exports2.WritableStreamDefaultController = WritableStreamDefaultController;
        exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    })(ponyfill_es2018, ponyfill_es2018.exports);
    POOL_SIZE$1 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        const process2 = require("process");
        const { emitWarning } = process2;
        try {
          process2.emitWarning = () => {
          };
          Object.assign(globalThis, require("stream/web"));
          process2.emitWarning = emitWarning;
        } catch (error2) {
          process2.emitWarning = emitWarning;
          throw error2;
        }
      } catch (error2) {
        Object.assign(globalThis, ponyfill_es2018.exports);
      }
    }
    try {
      const { Blob: Blob2 } = require("buffer");
      if (Blob2 && !Blob2.prototype.stream) {
        Blob2.prototype.stream = function name(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE$1));
              const buffer = await chunk.arrayBuffer();
              position += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));
              if (position === blob.size) {
                ctrl.close();
              }
            }
          });
        };
      }
    } catch (error2) {
    }
    POOL_SIZE = 65536;
    _Blob = (_a = class {
      constructor(blobParts = [], options = {}) {
        __privateAdd(this, _parts, []);
        __privateAdd(this, _type, "");
        __privateAdd(this, _size, 0);
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (typeof blobParts[Symbol.iterator] !== "function") {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options !== "object" && typeof options !== "function") {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        if (options === null)
          options = {};
        const encoder2 = new TextEncoder();
        for (const element of blobParts) {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof _a) {
            part = element;
          } else {
            part = encoder2.encode(element);
          }
          __privateSet(this, _size, __privateGet(this, _size) + (ArrayBuffer.isView(part) ? part.byteLength : part.size));
          __privateGet(this, _parts).push(part);
        }
        const type = options.type === void 0 ? "" : String(options.type);
        __privateSet(this, _type, /^[\x20-\x7E]*$/.test(type) ? type : "");
      }
      get size() {
        return __privateGet(this, _size);
      }
      get type() {
        return __privateGet(this, _type);
      }
      async text() {
        const decoder = new TextDecoder();
        let str = "";
        for await (const part of toIterator(__privateGet(this, _parts), false)) {
          str += decoder.decode(part, { stream: true });
        }
        str += decoder.decode();
        return str;
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset2 = 0;
        for await (const chunk of toIterator(__privateGet(this, _parts), false)) {
          data.set(chunk, offset2);
          offset2 += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        const it = toIterator(__privateGet(this, _parts), true);
        return new globalThis.ReadableStream({
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },
          async cancel() {
            await it.return();
          }
        });
      }
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = __privateGet(this, _parts);
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            relativeEnd -= size2;
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new _a([], { type: String(type).toLowerCase() });
        __privateSet(blob, _size, span);
        __privateSet(blob, _parts, blobParts);
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    }, _parts = new WeakMap(), _type = new WeakMap(), _size = new WeakMap(), _a);
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Blob = _Blob;
    Blob$1 = Blob;
    _File = (_a2 = class extends Blob$1 {
      constructor(fileBits, fileName, options = {}) {
        if (arguments.length < 2) {
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        super(fileBits, options);
        __privateAdd(this, _lastModified, 0);
        __privateAdd(this, _name, "");
        if (options === null)
          options = {};
        const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);
        if (!Number.isNaN(lastModified)) {
          __privateSet(this, _lastModified, lastModified);
        }
        __privateSet(this, _name, String(fileName));
      }
      get name() {
        return __privateGet(this, _name);
      }
      get lastModified() {
        return __privateGet(this, _lastModified);
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    }, _lastModified = new WeakMap(), _name = new WeakMap(), _a2);
    File = _File;
    ({ toStringTag: t, iterator: i, hasInstance: h } = Symbol);
    r = Math.random;
    m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
    f2 = (a, b, c) => (a += "", /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + "" : b[t] == "File" ? b.name : "blob", a), b.name !== c || b[t] == "blob" ? new File([b], c, b) : b] : [a, b + ""]);
    e = (c, f3) => (f3 ? c : c.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    x = (n, a, e2) => {
      if (a.length < e2) {
        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e2} arguments required, but only ${a.length} present.`);
      }
    };
    FormData = (_a3 = class {
      constructor(...a) {
        __privateAdd(this, _d, []);
        if (a.length)
          throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
      }
      get [t]() {
        return "FormData";
      }
      [i]() {
        return this.entries();
      }
      static [h](o) {
        return o && typeof o === "object" && o[t] === "FormData" && !m.some((m2) => typeof o[m2] != "function");
      }
      append(...a) {
        x("append", arguments, 2);
        __privateGet(this, _d).push(f2(...a));
      }
      delete(a) {
        x("delete", arguments, 1);
        a += "";
        __privateSet(this, _d, __privateGet(this, _d).filter(([b]) => b !== a));
      }
      get(a) {
        x("get", arguments, 1);
        a += "";
        for (var b = __privateGet(this, _d), l = b.length, c = 0; c < l; c++)
          if (b[c][0] === a)
            return b[c][1];
        return null;
      }
      getAll(a, b) {
        x("getAll", arguments, 1);
        b = [];
        a += "";
        __privateGet(this, _d).forEach((c) => c[0] === a && b.push(c[1]));
        return b;
      }
      has(a) {
        x("has", arguments, 1);
        a += "";
        return __privateGet(this, _d).some((b) => b[0] === a);
      }
      forEach(a, b) {
        x("forEach", arguments, 1);
        for (var [c, d] of this)
          a.call(b, d, c, this);
      }
      set(...a) {
        x("set", arguments, 2);
        var b = [], c = true;
        a = f2(...a);
        __privateGet(this, _d).forEach((d) => {
          d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
        });
        c && b.push(a);
        __privateSet(this, _d, b);
      }
      *entries() {
        yield* __privateGet(this, _d);
      }
      *keys() {
        for (var [a] of this)
          yield a;
      }
      *values() {
        for (var [, a] of this)
          yield a;
      }
    }, _d = new WeakMap(), _a3);
    FetchBaseError = class extends Error {
      constructor(message, type) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    FetchError = class extends FetchBaseError {
      constructor(message, type, systemError) {
        super(message, type);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
    NAME = Symbol.toStringTag;
    isURLSearchParameters = (object) => {
      return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
    };
    isBlob = (object) => {
      return object && typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
    };
    isAbortSignal = (object) => {
      return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
    };
    INTERNALS$2 = Symbol("Body internals");
    Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = Buffer.from(body.toString());
        } else if (isBlob(body))
          ;
        else if (Buffer.isBuffer(body))
          ;
        else if (import_node_util.types.isAnyArrayBuffer(body)) {
          body = Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof import_node_stream.default)
          ;
        else if (body instanceof FormData) {
          body = formDataToBlob(body);
          boundary = body.type.split("=")[1];
        } else {
          body = Buffer.from(String(body));
        }
        let stream = body;
        if (Buffer.isBuffer(body)) {
          stream = import_node_stream.default.Readable.from(body);
        } else if (isBlob(body)) {
          stream = import_node_stream.default.Readable.from(body.stream());
        }
        this[INTERNALS$2] = {
          body,
          stream,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof import_node_stream.default) {
          body.on("error", (error_) => {
            const error2 = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
            this[INTERNALS$2].error = error2;
          });
        }
      }
      get body() {
        return this[INTERNALS$2].stream;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      async formData() {
        const ct = this.headers.get("content-type");
        if (ct.startsWith("application/x-www-form-urlencoded")) {
          const formData = new FormData();
          const parameters = new URLSearchParams(await this.text());
          for (const [name, value] of parameters) {
            formData.append(name, value);
          }
          return formData;
        }
        const { toFormData: toFormData2 } = await Promise.resolve().then(() => (init_multipart_parser(), multipart_parser_exports));
        return toFormData2(this.body, ct);
      }
      async blob() {
        const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
        const buf = await this.buffer();
        return new Blob$1([buf], {
          type: ct
        });
      }
      async json() {
        const buffer = await consumeBody(this);
        return JSON.parse(buffer.toString());
      }
      async text() {
        const buffer = await consumeBody(this);
        return buffer.toString();
      }
      buffer() {
        return consumeBody(this);
      }
    };
    Body.prototype.buffer = (0, import_node_util.deprecate)(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    clone = (instance, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance[INTERNALS$2];
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof import_node_stream.default && typeof body.getBoundary !== "function") {
        p1 = new import_node_stream.PassThrough({ highWaterMark });
        p2 = new import_node_stream.PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS$2].stream = p1;
        body = p2;
      }
      return body;
    };
    getNonSpecFormDataBoundary = (0, import_node_util.deprecate)((body) => body.getBoundary(), "form-data doesn't follow the spec and requires special treatment. Use alternative package", "https://github.com/node-fetch/node-fetch/issues/1167");
    extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (Buffer.isBuffer(body) || import_node_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body instanceof FormData) {
        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
      }
      if (body instanceof import_node_stream.default) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    getTotalBytes = (request) => {
      const { body } = request[INTERNALS$2];
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      return null;
    };
    writeToStream = (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else {
        body.pipe(dest);
      }
    };
    validateHeaderName = typeof import_node_http.default.validateHeaderName === "function" ? import_node_http.default.validateHeaderName : (name) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
        const error2 = new TypeError(`Header name must be a valid HTTP token [${name}]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw error2;
      }
    };
    validateHeaderValue = typeof import_node_http.default.validateHeaderValue === "function" ? import_node_http.default.validateHeaderValue : (name, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const error2 = new TypeError(`Invalid character in header content ["${name}"]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_CHAR" });
        throw error2;
      }
    };
    Headers2 = class extends URLSearchParams {
      constructor(init2) {
        let result = [];
        if (init2 instanceof Headers2) {
          const raw = init2.raw();
          for (const [name, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name, value]));
          }
        } else if (init2 == null)
          ;
        else if (typeof init2 === "object" && !import_node_util.types.isBoxedPrimitive(init2)) {
          const method = init2[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init2));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init2].map((pair) => {
              if (typeof pair !== "object" || import_node_util.types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name, value]) => {
          validateHeaderName(name);
          validateHeaderValue(name, String(value));
          return [String(name).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name, value) => {
                  validateHeaderName(name);
                  validateHeaderValue(name, String(value));
                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));
                };
              case "delete":
              case "has":
              case "getAll":
                return (name) => {
                  validateHeaderName(name);
                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name) {
        const values = this.getAll(name);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback, thisArg = void 0) {
        for (const name of this.keys()) {
          Reflect.apply(callback, thisArg, [this.get(name), name, this]);
        }
      }
      *values() {
        for (const name of this.keys()) {
          yield this.get(name);
        }
      }
      *entries() {
        for (const name of this.keys()) {
          yield [name, this.get(name)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((result, key2) => {
          result[key2] = this.getAll(key2);
          return result;
        }, {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key2) => {
          const values = this.getAll(key2);
          if (key2 === "host") {
            result[key2] = values[0];
          } else {
            result[key2] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(Headers2.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
      result[property] = { enumerable: true };
      return result;
    }, {}));
    redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    isRedirect = (code) => {
      return redirectStatus.has(code);
    };
    INTERNALS$1 = Symbol("Response internals");
    Response2 = class extends Body {
      constructor(body = null, options = {}) {
        super(body, options);
        const status = options.status != null ? options.status : 200;
        const headers = new Headers2(options.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          type: "default",
          url: options.url,
          status,
          statusText: options.statusText || "",
          headers,
          counter: options.counter,
          highWaterMark: options.highWaterMark
        };
      }
      get type() {
        return this[INTERNALS$1].type;
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Response2(clone(this, this.highWaterMark), {
          type: this.type,
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size,
          highWaterMark: this.highWaterMark
        });
      }
      static redirect(url, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new Response2(null, {
          headers: {
            location: new URL(url).toString()
          },
          status
        });
      }
      static error() {
        const response = new Response2(null, { status: 0, statusText: "" });
        response[INTERNALS$1].type = "error";
        return response;
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response2.prototype, {
      type: { enumerable: true },
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
    };
    ReferrerPolicy = /* @__PURE__ */ new Set([
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ]);
    DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
    INTERNALS = Symbol("Request internals");
    isRequest = (object) => {
      return typeof object === "object" && typeof object[INTERNALS] === "object";
    };
    Request2 = class extends Body {
      constructor(input, init2 = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        if (parsedURL.username !== "" || parsedURL.password !== "") {
          throw new TypeError(`${parsedURL} is an url with embedded credentails.`);
        }
        let method = init2.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init2.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init2.body ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init2.size || input.size || 0
        });
        const headers = new Headers2(init2.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers.set("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init2) {
          signal = init2.signal;
        }
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        }
        let referrer = init2.referrer == null ? input.referrer : init2.referrer;
        if (referrer === "") {
          referrer = "no-referrer";
        } else if (referrer) {
          const parsedReferrer = new URL(referrer);
          referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
        } else {
          referrer = void 0;
        }
        this[INTERNALS] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal,
          referrer
        };
        this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
        this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
        this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
        this.referrerPolicy = init2.referrerPolicy || input.referrerPolicy || "";
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return (0, import_node_url.format)(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      get referrer() {
        if (this[INTERNALS].referrer === "no-referrer") {
          return "";
        }
        if (this[INTERNALS].referrer === "client") {
          return "about:client";
        }
        if (this[INTERNALS].referrer) {
          return this[INTERNALS].referrer.toString();
        }
        return void 0;
      }
      get referrerPolicy() {
        return this[INTERNALS].referrerPolicy;
      }
      set referrerPolicy(referrerPolicy) {
        this[INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy);
      }
      clone() {
        return new Request2(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request2.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true },
      referrer: { enumerable: true },
      referrerPolicy: { enumerable: true }
    });
    getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS];
      const headers = new Headers2(request[INTERNALS].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = DEFAULT_REFERRER_POLICY;
      }
      if (request.referrer && request.referrer !== "no-referrer") {
        request[INTERNALS].referrer = determineRequestsReferrer(request);
      } else {
        request[INTERNALS].referrer = "no-referrer";
      }
      if (request[INTERNALS].referrer instanceof URL) {
        headers.set("Referer", request.referrer);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate,br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      const search = getSearch(parsedURL);
      const options = {
        path: parsedURL.pathname + search,
        method: request.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return {
        parsedURL,
        options
      };
    };
    AbortError = class extends FetchBaseError {
      constructor(message, type = "aborted") {
        super(message, type);
      }
    };
    supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:"]);
  }
});

// .svelte-kit/output/server/chunks/index-b01bd1b0.js
function noop2() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop2;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function setContext(key2, context) {
  get_current_component().$$.context.set(key2, context);
}
function getContext(key2) {
  return get_current_component().$$.context.get(key2);
}
function escape(html) {
  return String(html).replace(/["'&<>]/g, (match2) => escaped[match2]);
}
function each(items, fn) {
  let str = "";
  for (let i2 = 0; i2 < items.length; i2 += 1) {
    str += fn(items[i2], i2);
  }
  return str;
}
function validate_component(component, name) {
  if (!component || !component.$$render) {
    if (name === "svelte:component")
      name += " this={...}";
    throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots2, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(context || (parent_component ? parent_component.$$.context : [])),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn(result, props, bindings, slots2);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = /* @__PURE__ */ new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: /* @__PURE__ */ new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css25) => css25.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  return ` ${name}${value === true && boolean_attributes.has(name) ? "" : `=${typeof value === "string" ? JSON.stringify(escape(value)) : `"${value}"`}`}`;
}
function style_object_to_string(style_object) {
  return Object.keys(style_object).filter((key2) => style_object[key2]).map((key2) => `${key2}: ${style_object[key2]};`).join(" ");
}
function add_styles(style_object) {
  const styles = style_object_to_string(style_object);
  return styles ? ` style="${styles}"` : "";
}
var current_component, boolean_attributes, escaped, missing_component, on_destroy;
var init_index_b01bd1b0 = __esm({
  ".svelte-kit/output/server/chunks/index-b01bd1b0.js"() {
    Promise.resolve();
    boolean_attributes = /* @__PURE__ */ new Set([
      "allowfullscreen",
      "allowpaymentrequest",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "defer",
      "disabled",
      "formnovalidate",
      "hidden",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "selected"
    ]);
    escaped = {
      '"': "&quot;",
      "'": "&#39;",
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;"
    };
    missing_component = {
      $$render: () => ""
    };
  }
});

// node_modules/@sveltejs/kit/dist/hooks.js
function sequence(...handlers) {
  const length = handlers.length;
  if (!length)
    return ({ event, resolve: resolve2 }) => resolve2(event);
  return ({ event, resolve: resolve2 }) => {
    return apply_handle(0, event);
    function apply_handle(i2, event2) {
      const handle2 = handlers[i2];
      return handle2({
        event: event2,
        resolve: i2 < length - 1 ? (event3) => apply_handle(i2 + 1, event3) : resolve2
      });
    }
  };
}
var init_hooks = __esm({
  "node_modules/@sveltejs/kit/dist/hooks.js"() {
  }
});

// .svelte-kit/output/server/chunks/links-275d677a.js
var links;
var init_links_275d677a = __esm({
  ".svelte-kit/output/server/chunks/links-275d677a.js"() {
    links = {
      github: "https://github.com/EthanThatOneKid/acmcsuf.com",
      youtube: "https://www.youtube.com/channel/UCDMBj0o4V8Cpt0jgsZLNVVg",
      instagram: "https://instagram.com/acmcsuf",
      discord: "https://discord.gg/eKRApG627b",
      linkedin: "https://linkedin.com/company/acm-at-csuf/",
      tuffyhacks: "https://tuffyhacks.com/",
      "acm-w": "https://sites.google.com/view/acm-w",
      "covid-19": "https://docs.google.com/document/d/1aEfH50N0fmeK3JiID968DoG41jmdk3nelDipQpF6yio/edit?usp=sharing",
      bug: "https://github.com/EthanThatOneKid/acmcsuf.com/issues/new?assignees=&labels=bug&template=bug_report.yaml",
      enhance: "https://github.com/EthanThatOneKid/acmcsuf.com/issues/new?assignees=&labels=enhancement&template=feature_request.yaml",
      gfi: "https://github.com/EthanThatOneKid/acmcsuf.com/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22"
    };
  }
});

// .svelte-kit/output/server/chunks/index-17102cb9.js
var index_17102cb9_exports = {};
__export(index_17102cb9_exports, {
  handle: () => handle
});
function urlShortener() {
  return async ({ event, resolve: resolve2 }) => {
    const slug = event.url.pathname.replace(/^\/+|\/+$/g, "");
    const url = links[slug];
    if (!url) {
      return resolve2(event);
    }
    const message = `Redirecting to ${url}...`;
    return new Response(message, {
      status: 302,
      headers: {
        Location: url,
        "Content-Type": "text/plain",
        "Content-Length": message.length.toString()
      }
    });
  };
}
var handle;
var init_index_17102cb9 = __esm({
  ".svelte-kit/output/server/chunks/index-17102cb9.js"() {
    init_hooks();
    init_links_275d677a();
    handle = sequence(urlShortener());
  }
});

// .svelte-kit/output/server/chunks/index-b8bace31.js
function writable2(value, start = noop2) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue2.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue2.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue2.length; i2 += 2) {
            subscriber_queue2[i2][0](subscriber_queue2[i2 + 1]);
          }
          subscriber_queue2.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop2) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop2;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}
var subscriber_queue2;
var init_index_b8bace31 = __esm({
  ".svelte-kit/output/server/chunks/index-b8bace31.js"() {
    init_index_b01bd1b0();
    subscriber_queue2 = [];
  }
});

// .svelte-kit/output/server/chunks/index-ba3ba78e.js
var DEBUG;
var init_index_ba3ba78e = __esm({
  ".svelte-kit/output/server/chunks/index-ba3ba78e.js"() {
    DEBUG = !["", "0", "false", "undefined"].includes(String({}.VITE_DEBUG).toLowerCase());
  }
});

// .svelte-kit/output/server/entries/pages/__layout.svelte.js
var layout_svelte_exports = {};
__export(layout_svelte_exports, {
  default: () => _layout
});
function get() {
  const savedValue = localStorage.getItem(STORAGE_KEY);
  if (savedValue === "dark")
    return "dark";
  if (savedValue === "light")
    return "light";
  return matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
}
function save(value) {
  localStorage.setItem(STORAGE_KEY, value);
  switch (value) {
    case "dark": {
      document.body.classList.add("dark");
      document.body.classList.remove("light");
      return;
    }
    default: {
      document.body.classList.remove("dark");
      document.body.classList.add("light");
      return;
    }
  }
}
function createTheme(defaultValue = "light") {
  const { subscribe: subscribe2, set, update } = writable2(defaultValue);
  function init2() {
    const saved = get();
    set(saved);
    subscribe2(save);
  }
  function toggle() {
    update((value) => {
      const nextValue = value === "light" ? "dark" : "light";
      save(nextValue);
      return nextValue;
    });
  }
  return { subscribe: subscribe2, set, update, init: init2, toggle, save };
}
var getStores, page, STORAGE_KEY, theme, css$3, Navbar, Instagram, Discord, Youtube, Linkedin, css$2, Footer, ToastType, toasts, css$1, Acm_toaster, css, _layout;
var init_layout_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/__layout.svelte.js"() {
    init_index_b01bd1b0();
    init_index_b8bace31();
    init_index_ba3ba78e();
    getStores = () => {
      const stores = getContext("__svelte__");
      return {
        page: {
          subscribe: stores.page.subscribe
        },
        navigating: {
          subscribe: stores.navigating.subscribe
        },
        get preloading() {
          console.error("stores.preloading is deprecated; use stores.navigating instead");
          return {
            subscribe: stores.navigating.subscribe
          };
        },
        session: stores.session,
        updated: stores.updated
      };
    };
    page = {
      subscribe(fn) {
        const store = getStores().page;
        return store.subscribe(fn);
      }
    };
    STORAGE_KEY = "theme";
    theme = createTheme();
    css$3 = {
      code: "nav.svelte-1t7vm7z.svelte-1t7vm7z{display:flex;position:fixed;width:100%;justify-content:center;padding:16px 0;background-color:var(--navbar-bg);box-shadow:0 3px 12px rgba(16, 19, 21, 0.1);z-index:10}nav.svelte-1t7vm7z .container.svelte-1t7vm7z{display:flex;align-items:center;justify-content:space-between;padding:0 16px;width:1280px}nav.svelte-1t7vm7z .container .logo-container .logo.svelte-1t7vm7z{display:flex;align-items:center;text-decoration:none;gap:4px}nav.svelte-1t7vm7z .container .logo-container .logo .badge.svelte-1t7vm7z{height:64px;width:auto;filter:drop-shadow(0 1.5px 4.5px rgba(44, 145, 198, 0.5))}nav.svelte-1t7vm7z .container .logo-container .logo h3.svelte-1t7vm7z{font-size:clamp(1.25rem, 1.2039rem + 0.2632vw, 1.625rem)}nav.svelte-1t7vm7z .container section.svelte-1t7vm7z{display:flex;align-items:center;gap:64px}nav.svelte-1t7vm7z .container section .pages.svelte-1t7vm7z{display:flex;gap:64px;list-style:none}nav.svelte-1t7vm7z .container section .pages a.svelte-1t7vm7z{text-decoration:none;transition:0.25s ease-in-out}nav.svelte-1t7vm7z .container section .pages a.svelte-1t7vm7z:hover,nav.svelte-1t7vm7z .container section .pages a[aria-current=true].svelte-1t7vm7z{color:var(--acm-blue)}nav.svelte-1t7vm7z .container section .toggle-container.svelte-1t7vm7z{display:flex;justify-content:flex-end}nav.svelte-1t7vm7z .container section .toggle-container .dark-toggle.svelte-1t7vm7z{display:flex;align-items:center;max-width:fit-content;padding:6px 12px;background-color:var(--acm-gray);border-radius:8px;gap:4px;transition:0.25s ease-in-out}nav.svelte-1t7vm7z .container section .toggle-container .dark-toggle.svelte-1t7vm7z:hover{cursor:pointer;background-color:#3d4043}nav.svelte-1t7vm7z .toggle.svelte-1t7vm7z,nav.svelte-1t7vm7z .menu.svelte-1t7vm7z{display:none;z-index:10}@media screen and (max-width: 900px){nav.svelte-1t7vm7z .container .logo-container .logo .badge.svelte-1t7vm7z{height:48px}nav.svelte-1t7vm7z .container .pages.svelte-1t7vm7z{position:fixed;flex-direction:column;justify-content:center;align-items:center;top:0;right:0;height:0;width:100%;gap:0;background-color:var(--acm-light);overflow:hidden;z-index:9;transition:0.25s ease-in-out}nav.svelte-1t7vm7z .container .pages a.svelte-1t7vm7z{font-size:var(--size-md)}nav.svelte-1t7vm7z .toggle-container .dark-toggle.svelte-1t7vm7z{position:absolute;top:50%;transform:translateY(-50%);right:56px}nav.svelte-1t7vm7z .menu.svelte-1t7vm7z{display:block;position:absolute;padding:8px;top:50%;transform:translateY(-50%);right:8px;cursor:pointer}nav.svelte-1t7vm7z .menu .menuLine.svelte-1t7vm7z{width:24px;height:2px;margin:6px 0;background-color:var(--acm-dark);transition:0.25s ease-in-out}nav.svelte-1t7vm7z .menu:hover .menuLine.svelte-1t7vm7z{background-color:var(--acm-blue)}nav.svelte-1t7vm7z :checked~.container .pages.svelte-1t7vm7z{height:100vh}nav.svelte-1t7vm7z :checked~.menu .menuLine.svelte-1t7vm7z{background-color:var(--acm-blue)}nav.svelte-1t7vm7z :checked~.menu .menuLine.svelte-1t7vm7z:nth-child(1){transform:translateY(8px) rotate(45deg)}nav.svelte-1t7vm7z :checked~.menu .menuLine.svelte-1t7vm7z:nth-child(2){opacity:0}nav.svelte-1t7vm7z :checked~.menu .menuLine.svelte-1t7vm7z:nth-child(3){transform:translateY(-8px) rotate(-45deg)}}",
      map: null
    };
    Navbar = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      let $page, $$unsubscribe_page;
      let $$unsubscribe_theme;
      $$unsubscribe_page = subscribe(page, (value) => $page = value);
      $$unsubscribe_theme = subscribe(theme, (value) => value);
      const navItems = [
        { title: "About", path: "/about" },
        { title: "Events", path: "/events" },
        { title: "Paths", path: "/paths" },
        { title: "Node Buds", path: "/nodebuds" },
        { title: "Blog", path: "/blog" }
      ];
      let checkbox;
      $$result.css.add(css$3);
      $$unsubscribe_page();
      $$unsubscribe_theme();
      return `<nav class="${"svelte-1t7vm7z"}"><input type="${"checkbox"}" id="${"navToggle"}" class="${"toggle svelte-1t7vm7z"}"${add_attribute("this", checkbox, 0)}>

  <div class="${"container svelte-1t7vm7z"}"><div class="${"logo-container"}"><a href="${"/"}" class="${"logo svelte-1t7vm7z"}"><img src="${"/assets/badges/general.svg"}" class="${"badge svelte-1t7vm7z"}" alt="${"acmCSUF badge"}">
        <h3 class="${"brand-header svelte-1t7vm7z"}">at <b>CSUF</b></h3></a></div>

    <section class="${"svelte-1t7vm7z"}"><ul class="${"pages svelte-1t7vm7z"}">${each(navItems, ({ title, path }) => {
        return `<li><a${add_attribute("href", path, 0)} class="${"brand-header size-sm svelte-1t7vm7z"}"${add_attribute("aria-current", path === $page.url.pathname, 0)} sveltekit:prefetch><!-- HTML_TAG_START -->${title}<!-- HTML_TAG_END --></a>
          </li>`;
      })}</ul>

      ${``}</section></div>

  <label for="${"navToggle"}" class="${"menu svelte-1t7vm7z"}"><div class="${"menuLine svelte-1t7vm7z"}"></div>
    <div class="${"menuLine svelte-1t7vm7z"}"></div>
    <div class="${"menuLine svelte-1t7vm7z"}"></div></label>
</nav>`;
    });
    Instagram = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      return `<svg width="${"56"}" height="${"56"}" viewBox="${"0 0 56 56"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}"><path d="${"M39.6662 4.66625C42.7578 4.67548 45.7201 5.9077 47.9062 8.09378C50.0923 10.2799 51.3245 13.2422 51.3338 16.3337V39.6662C51.3245 42.7578 50.0923 45.7201 47.9062 47.9062C45.7201 50.0923 42.7578 51.3245 39.6662 51.3338H16.3337C13.2422 51.3245 10.2799 50.0923 8.09378 47.9062C5.9077 45.7201 4.67548 42.7578 4.66625 39.6662V16.3337C4.67548 13.2422 5.9077 10.2799 8.09378 8.09378C10.2799 5.9077 13.2422 4.67548 16.3337 4.66625H39.6662ZM39.6662 0H16.3337C7.35 0 0 7.35 0 16.3337V39.6662C0 48.65 7.35 56 16.3337 56H39.6662C48.65 56 56 48.65 56 39.6662V16.3337C56 7.35 48.65 0 39.6662 0Z"}" fill="${"white"}"></path><path d="${"M43.1663 16.3338C42.474 16.3338 41.7973 16.1285 41.2218 15.7439C40.6462 15.3594 40.1976 14.8127 39.9327 14.1732C39.6678 13.5337 39.5985 12.8299 39.7335 12.151C39.8686 11.4721 40.2019 10.8484 40.6914 10.3589C41.1809 9.86944 41.8045 9.5361 42.4834 9.40105C43.1624 9.26601 43.8661 9.33532 44.5056 9.60022C45.1452 9.86513 45.6918 10.3137 46.0764 10.8893C46.461 11.4649 46.6663 12.1416 46.6663 12.8338C46.6672 13.2937 46.5774 13.7493 46.4018 14.1744C46.2263 14.5994 45.9685 14.9857 45.6433 15.3109C45.3181 15.6361 44.9319 15.8939 44.5068 16.0694C44.0817 16.2449 43.6262 16.3348 43.1663 16.3338ZM28 18.6663C29.846 18.6663 31.6506 19.2137 33.1856 20.2393C34.7205 21.2649 35.9168 22.7227 36.6233 24.4282C37.3297 26.1337 37.5146 28.0104 37.1544 29.821C36.7943 31.6315 35.9053 33.2947 34.6 34.6C33.2946 35.9054 31.6315 36.7943 29.8209 37.1545C28.0104 37.5146 26.1337 37.3298 24.4281 36.6233C22.7226 35.9169 21.2649 34.7205 20.2393 33.1856C19.2137 31.6507 18.6663 29.8461 18.6663 28.0001C18.6689 25.5254 19.6531 23.1529 21.403 21.403C23.1528 19.6532 25.5254 18.669 28 18.6663ZM28 14.0001C25.2311 14.0001 22.5243 14.8211 20.222 16.3595C17.9197 17.8978 16.1253 20.0843 15.0657 22.6425C14.0061 25.2006 13.7288 28.0156 14.269 30.7313C14.8092 33.4471 16.1426 35.9416 18.1005 37.8995C20.0584 39.8575 22.553 41.1909 25.2687 41.731C27.9845 42.2712 30.7994 41.994 33.3576 40.9344C35.9157 39.8747 38.1022 38.0803 39.6406 35.778C41.1789 33.4757 42 30.769 42 28.0001C42 24.287 40.525 20.7261 37.8995 18.1006C35.274 15.475 31.713 14.0001 28 14.0001Z"}" fill="${"white"}"></path></svg>`;
    });
    Discord = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      return `<svg width="${"71"}" height="${"55"}" viewBox="${"0 0 71 55"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}"><g clip-path="${"url(#clip0)"}"><path d="${"M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z"}" fill="${"currentColor"}"></path></g><defs><clipPath id="${"clip0"}"><rect width="${"71"}" height="${"55"}" fill="${"currentColor"}"></rect></clipPath></defs></svg>`;
    });
    Youtube = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      return `<svg width="${"64"}" height="${"49"}" viewBox="${"0 0 64 49"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}"><path d="${"M63.5798 10.5987C63.5798 4.97375 59.4423 0.44875 54.3298 0.44875C47.4048 0.125 40.3423 0 33.1248 0H30.8748C23.6748 0 16.5998 0.125 9.67478 0.45C4.57478 0.45 0.437284 5 0.437284 10.625C0.124784 15.0737 -0.00771643 19.5238 -0.000216427 23.9737C-0.0127164 28.4237 0.12895 32.8779 0.424784 37.3363C0.424784 42.9613 4.56228 47.5238 9.66228 47.5238C16.9373 47.8613 24.3998 48.0112 31.9873 47.9987C39.5873 48.0238 47.0289 47.8654 54.3123 47.5238C59.4248 47.5238 63.5623 42.9613 63.5623 37.3363C63.8623 32.8737 63.9998 28.4237 63.9873 23.9613C64.0156 19.5112 63.8798 15.0571 63.5798 10.5987ZM25.8748 36.2363V11.6737L43.9998 23.9487L25.8748 36.2363Z"}" fill="${"currentColor"}"></path></svg>`;
    });
    Linkedin = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      return `<svg width="${"56"}" height="${"56"}" viewBox="${"0 0 56 56"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}"><path d="${"M51.5213 0H4.785C2.23125 0 0 1.8375 0 4.36125V51.2012C0 53.7387 2.23125 56 4.785 56H51.5075C54.075 56 56 53.7237 56 51.2012V4.36125C56.015 1.8375 54.075 0 51.5213 0ZM17.3587 46.6787H9.33625V21.735H17.3587V46.6787ZM13.625 17.9425H13.5675C11 17.9425 9.3375 16.0312 9.3375 13.6388C9.3375 11.2025 11.0438 9.33625 13.6688 9.33625C16.2938 9.33625 17.9 11.1888 17.9575 13.6388C17.9563 16.0312 16.2938 17.9425 13.625 17.9425ZM46.6787 46.6787H38.6562V33.04C38.6562 29.7725 37.4888 27.54 34.5863 27.54C32.3688 27.54 31.0562 29.04 30.4725 30.5013C30.2537 31.0263 30.195 31.7412 30.195 32.4712V46.6787H22.1725V21.735H30.195V25.2062C31.3625 23.5437 33.1862 21.1513 37.43 21.1513C42.6963 21.1513 46.68 24.6225 46.68 32.1063L46.6787 46.6787Z"}" fill="${"white"}"></path></svg>`;
    });
    css$2 = {
      code: "footer.svelte-1det3ou.svelte-1det3ou{display:flex;width:100%;justify-content:center;padding:24px 0;background-color:var(--footer-bg)}footer.svelte-1det3ou .container.svelte-1det3ou{display:flex;justify-content:space-between;padding:0 16px;width:1280px}footer.svelte-1det3ou .container ul.svelte-1det3ou,footer.svelte-1det3ou .container li.svelte-1det3ou{list-style:none}footer.svelte-1det3ou .container a.svelte-1det3ou{color:var(--perma-light);text-decoration:none;transition:0.25s ease-in-out}footer.svelte-1det3ou .container a.svelte-1det3ou:hover{color:var(--acm-blue)}footer.svelte-1det3ou .container .connect.svelte-1det3ou,footer.svelte-1det3ou .container .legal.svelte-1det3ou,footer.svelte-1det3ou .container .more.svelte-1det3ou{display:flex;flex-direction:column;gap:4px}footer.svelte-1det3ou .container .connect h3.svelte-1det3ou,footer.svelte-1det3ou .container .connect h3 span.svelte-1det3ou,footer.svelte-1det3ou .container .legal h3.svelte-1det3ou,footer.svelte-1det3ou .container .legal h3 span.svelte-1det3ou,footer.svelte-1det3ou .container .more h3.svelte-1det3ou,footer.svelte-1det3ou .container .more h3 span.svelte-1det3ou{color:var(--perma-light)}footer.svelte-1det3ou .container .connect.svelte-1det3ou{width:250px;align-items:flex-start}footer.svelte-1det3ou .container .connect .socials.svelte-1det3ou{display:flex;gap:32px}footer.svelte-1det3ou .container .connect .socials a.svelte-1det3ou{display:flex;padding-top:6px}footer.svelte-1det3ou .container .connect .socials a.svelte-1det3ou:hover path{fill:var(--acm-blue)}footer.svelte-1det3ou .container .connect .socials.svelte-1det3ou svg{height:32px;width:auto}footer.svelte-1det3ou .container .connect .socials.svelte-1det3ou path{fill:var(--perma-light);transition:0.25s ease-in-out}footer.svelte-1det3ou .container .legal.svelte-1det3ou{align-items:center;text-align:center}footer.svelte-1det3ou .container .more.svelte-1det3ou{width:250px;align-items:flex-end;text-align:right}@media screen and (max-width: 900px){footer.svelte-1det3ou .container.svelte-1det3ou{flex-direction:column;align-items:center;gap:32px;padding:unset}footer.svelte-1det3ou .container a.svelte-1det3ou{font-size:var(--size-sm)}footer.svelte-1det3ou .container .legal.svelte-1det3ou{order:1}footer.svelte-1det3ou .container .connect.svelte-1det3ou{order:2;align-items:center}footer.svelte-1det3ou .container .more.svelte-1det3ou{order:3;align-items:center;text-align:center}}",
      map: null
    };
    Footer = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      const footerItems = [
        { title: "Source Code", path: "/github" },
        { title: "Report a Bug", path: "/bug" },
        {
          title: "COVID-19 Policy",
          path: "/covid-19"
        },
        {
          title: "frankBot Privacy",
          path: "/privacy"
        }
      ];
      const socialItems = [
        { icon: Discord, path: "/discord" },
        { icon: Instagram, path: "/instagram" },
        { icon: Youtube, path: "/youtube" },
        { icon: Linkedin, path: "/linkedin" }
      ];
      $$result.css.add(css$2);
      return `<footer class="${"svelte-1det3ou"}"><div class="${"container svelte-1det3ou"}"><div class="${"connect svelte-1det3ou"}"><h3 class="${"brand-header size-md svelte-1det3ou"}">Stay connected</h3>

      <ul class="${"socials svelte-1det3ou"}">${each(socialItems, ({ path, icon }) => {
        return `<li class="${"svelte-1det3ou"}"><a${add_attribute("href", path, 0)} target="${"_blank"}" rel="${"noopener noreferrer"}" class="${"svelte-1det3ou"}">${validate_component(icon || missing_component, "svelte:component").$$render($$result, {}, {}, {})}</a>
          </li>`;
      })}</ul></div>

    <div class="${"legal svelte-1det3ou"}"><h3 class="${"brand-header size-md svelte-1det3ou"}">\xA9 2022 ACM Chapter at <span class="${"brand-bold svelte-1det3ou"}">CSUF</span></h3>

      <a href="${"mailto:acmcsufullerton@gmail.com"}" class="${"brand-med size-sm svelte-1det3ou"}" target="${"_blank"}" rel="${"noopener noreferrer"}">Get in Touch
      </a></div>

    <div class="${"more svelte-1det3ou"}"><h3 class="${"brand-header size-md svelte-1det3ou"}">More from us</h3>

      <ul class="${"links svelte-1det3ou"}">${each(footerItems, ({ title, path }) => {
        return `<li class="${"svelte-1det3ou"}"><a${add_attribute("href", path, 0)} class="${"brand-med size-sm svelte-1det3ou"}" target="${"_blank"}" rel="${"noopener noreferrer"}"><!-- HTML_TAG_START -->${title}<!-- HTML_TAG_END --></a>
          </li>`;
      })}</ul></div></div>
</footer>`;
    });
    ToastType = /* @__PURE__ */ ((ToastType2) => {
      ToastType2["Success"] = "success";
      ToastType2["Error"] = "error";
      ToastType2["Info"] = "info";
      return ToastType2;
    })(ToastType || {});
    toasts = writable2([]);
    css$1 = {
      code: ":root{--success-rgb:157, 231, 53;--error-rgb:255, 67, 101;--info-rgb:30, 108, 255}section.svelte-427evd.svelte-427evd{position:fixed;z-index:10000;bottom:0;right:50%;transform:translateX(50%);min-width:min(390px, 100%)}.toast-item.svelte-427evd.svelte-427evd{display:flex;align-items:center;flex-direction:row;gap:1.5em;margin:32px 32px;padding:2em;transition:all 0.25s ease-in-out;box-shadow:0 6px 24px rgba(var(--highlights, --acm-general-rgb), 0.5);border:3px solid rgb(var(--highlights, --acm-general-rgb));transition:0.25s ease-in-out;border-radius:20px;background-color:var(--acm-light)}.toast-item.svelte-427evd img.svelte-427evd{--img-width:75px;width:var(--img-width);height:calc(var(--img-width) * 0.56);align-self:center}@media(min-width: 800px){section.svelte-427evd.svelte-427evd{right:0;transform:translateX(0)}}",
      map: null
    };
    Acm_toaster = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      let $toasts, $$unsubscribe_toasts;
      $$unsubscribe_toasts = subscribe(toasts, (value) => $toasts = value);
      $$result.css.add(css$1);
      $$unsubscribe_toasts();
      return `<section class="${"svelte-427evd"}">${each($toasts, (toastItem) => {
        return `<div class="${[
          "toast-item svelte-427evd",
          (toastItem.type === ToastType.Error ? "error" : "") + " " + (toastItem.type === ToastType.Success ? "success" : "") + " " + (toastItem.type === ToastType.Info ? "info" : "")
        ].join(" ").trim()}"${add_styles({
          "--highlights": `var(--acm-${toastItem.path}-rgb)`
        })}><img src="${"/assets/png/acm-shark.png"}" alt="${"acmCSUF Mascot: Frank the Shark"}" class="${"svelte-427evd"}">
      <p><!-- HTML_TAG_START -->${toastItem.content}<!-- HTML_TAG_END --></p>
    </div>`;
      })}
</section>`;
    });
    css = {
      code: "main.svelte-ck21ns{min-height:100vh}",
      map: null
    };
    _layout = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      $$result.css.add(css);
      return `${validate_component(Navbar, "Navbar").$$render($$result, {}, {}, {})}
<main class="${"svelte-ck21ns"}">${slots2.default ? slots2.default({}) : ``}</main>
${validate_component(Footer, "Footer").$$render($$result, {}, {}, {})}
${validate_component(Acm_toaster, "AcmToaster").$$render($$result, {}, {}, {})}

${$$result.head += `<meta charset="${"UTF-8"}" data-svelte="svelte-n6w7sa"><meta name="${"viewport"}" content="${"width=device-width, initial-scale=1.0"}" data-svelte="svelte-n6w7sa">`, ""}`;
    });
  }
});

// .svelte-kit/output/server/nodes/0.js
var __exports = {};
__export(__exports, {
  css: () => css2,
  entry: () => entry,
  js: () => js,
  module: () => layout_svelte_exports
});
var entry, js, css2;
var init__ = __esm({
  ".svelte-kit/output/server/nodes/0.js"() {
    init_layout_svelte();
    entry = "pages/__layout.svelte-cd7d85da.js";
    js = ["pages/__layout.svelte-cd7d85da.js", "chunks/index-462fa7ca.js", "chunks/index-af743adc.js", "chunks/toasts-8c4e63ab.js", "chunks/index-cc4b3e8c.js", "chunks/acm-paths-c5897a25.js"];
    css2 = ["assets/pages/__layout.svelte-e4f644c2.css"];
  }
});

// .svelte-kit/output/server/entries/pages/__error.svelte.js
var error_svelte_exports = {};
__export(error_svelte_exports, {
  default: () => _error
});
var css3, _error;
var init_error_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/__error.svelte.js"() {
    init_index_b01bd1b0();
    css3 = {
      code: "section.svelte-qk4p1x.svelte-qk4p1x{min-height:100vh;display:flex;flex-direction:column;justify-content:center;align-items:center;margin:0 24px;color:var(--acm-light)}section.svelte-qk4p1x h1.svelte-qk4p1x{margin-bottom:2em;align-items:center;text-align:center}section.svelte-qk4p1x em.svelte-qk4p1x{align-items:center;text-align:center;font-size:50px;margin-bottom:0.5em;margin-top:2em;text-shadow:2px 2px #92c4df;font-weight:600}section.svelte-qk4p1x img.svelte-qk4p1x{width:100%;max-width:1000px;height:auto;margin-bottom:3em}",
      map: null
    };
    _error = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      let { status = 404 } = $$props;
      if ($$props.status === void 0 && $$bindings.status && status !== void 0)
        $$bindings.status(status);
      $$result.css.add(css3);
      return `${$$result.head += `${$$result.title = `<title>ACM at CSUF / ${escape(status)}</title>`, ""}<link rel="${"stylesheet"}" href="${"/global.css"}" data-svelte="svelte-1goyycz">`, ""}

<section class="${"svelte-qk4p1x"}"><em class="${"svelte-qk4p1x"}">404</em>
  <h1 class="${"svelte-qk4p1x"}">Frank can&#39;t find where you&#39;re going!</h1>
  <img src="${"/assets/png/lost-frank.png"}" alt="${"404 - Page Not Found"}" class="${"svelte-qk4p1x"}">
</section>`;
    });
  }
});

// .svelte-kit/output/server/nodes/1.js
var __exports2 = {};
__export(__exports2, {
  css: () => css4,
  entry: () => entry2,
  js: () => js2,
  module: () => error_svelte_exports
});
var entry2, js2, css4;
var init__2 = __esm({
  ".svelte-kit/output/server/nodes/1.js"() {
    init_error_svelte();
    entry2 = "pages/__error.svelte-99dea009.js";
    js2 = ["pages/__error.svelte-99dea009.js", "chunks/index-462fa7ca.js"];
    css4 = ["assets/pages/__error.svelte-e687dfad.css"];
  }
});

// .svelte-kit/output/server/chunks/acm-paths-c5897a25.js
var acmAlgo, acmCreate, acmDev, acmGeneral, pinnedPaths;
var init_acm_paths_c5897a25 = __esm({
  ".svelte-kit/output/server/chunks/acm-paths-c5897a25.js"() {
    acmAlgo = {
      title: "Algo",
      slug: "algo",
      picture: "./assets/badges/with-shadow/algo.svg",
      color: "var(--acm-purple)"
    };
    acmCreate = {
      title: "Create",
      slug: "create",
      picture: "./assets/badges/with-shadow/create.svg",
      color: "var(--acm-pink)"
    };
    acmDev = {
      title: "Dev",
      slug: "dev",
      picture: "./assets/badges/with-shadow/dev.svg",
      color: "var(--acm-bluer)"
    };
    acmGeneral = {
      title: "General",
      slug: "general",
      picture: "./assets/badges/general.svg",
      color: "var(--acm-blue)"
    };
    pinnedPaths = [acmAlgo, acmCreate, acmDev];
  }
});

// .svelte-kit/output/server/chunks/spacing-a132bf4f.js
var css5, Spacing;
var init_spacing_a132bf4f = __esm({
  ".svelte-kit/output/server/chunks/spacing-a132bf4f.js"() {
    init_index_b01bd1b0();
    css5 = {
      code: ":root{--med:100px;--min:var(--med, 100px);--max:var(--med, 100px)}div.svelte-23s1bo{height:var(--min)}@media screen and (min-width: 768px){div.svelte-23s1bo{height:var(--med)}}@media screen and (min-width: 1440px){div.svelte-23s1bo{height:var(--max)}}",
      map: null
    };
    Spacing = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      $$result.css.add(css5);
      return `<div class="${"svelte-23s1bo"}"></div>`;
    });
  }
});

// .svelte-kit/output/server/entries/pages/index.svelte.js
var index_svelte_exports = {};
__export(index_svelte_exports, {
  default: () => Routes
});
var css$4, Acm_button, css$32, Hero, css$22, Why_join, css$12, Acm_paths, css6, Ready_up, Routes;
var init_index_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/index.svelte.js"() {
    init_index_b01bd1b0();
    init_acm_paths_c5897a25();
    init_spacing_a132bf4f();
    css$4 = {
      code: "a.svelte-1crhzlw{display:block;text-align:center;padding:12px 24px;background-color:var(--button-bg);color:var(--perma-light);border-radius:12px;text-decoration:none;user-select:none;transition:0.25s ease-in-out}a.svelte-1crhzlw:hover{background-color:var(--button-hover)}",
      map: null
    };
    Acm_button = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      let { link = "#" } = $$props;
      let { text = "Submit" } = $$props;
      if ($$props.link === void 0 && $$bindings.link && link !== void 0)
        $$bindings.link(link);
      if ($$props.text === void 0 && $$bindings.text && text !== void 0)
        $$bindings.text(text);
      $$result.css.add(css$4);
      return `<a class="${"brand-header size-md svelte-1crhzlw"}" role="${"button"}"${add_attribute("href", link, 0)} target="${"_blank"}" rel="${"noopener norefferer"}">${escape(text)}
</a>`;
    });
    css$32 = {
      code: "section.svelte-t6z1h5.svelte-t6z1h5{display:flex;justify-content:center;align-items:center}section.svelte-t6z1h5 .container.svelte-t6z1h5{display:flex;align-items:center;justify-content:space-between;padding:0 16px;width:1280px}section.svelte-t6z1h5 .container .left.svelte-t6z1h5{display:flex;align-items:flex-start;flex-direction:column;gap:64px}section.svelte-t6z1h5 .container .left h1.svelte-t6z1h5{max-width:clamp(21.875rem, 18.8048rem + 17.5439vw, 46.875rem)}section.svelte-t6z1h5 .container img.svelte-t6z1h5{width:clamp(15.625rem, 13.7061rem + 10.9649vw, 31.25rem);margin-left:32px;filter:drop-shadow(0 10px 40px rgba(44, 145, 198, 0.5))}@media screen and (max-width: 900px){section.svelte-t6z1h5 .container.svelte-t6z1h5{padding:0 8px;flex-direction:column-reverse}section.svelte-t6z1h5 .container .left.svelte-t6z1h5{align-items:center;text-align:center;gap:32px}section.svelte-t6z1h5 .container .left h1.svelte-t6z1h5{font-size:var(--size-lg)}section.svelte-t6z1h5 .container img.svelte-t6z1h5{margin:0;padding-bottom:64px;filter:drop-shadow(0 6px 24px rgba(44, 145, 198, 0.5))}}",
      map: null
    };
    Hero = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      $$result.css.add(css$32);
      return `<section class="${"svelte-t6z1h5"}"><div class="${"container svelte-t6z1h5"}"><div class="${"left svelte-t6z1h5"}"><h1 class="${"brand-header size-xl svelte-t6z1h5"}">We are the largest tech community at
        <b class="${"acm-blue"}">CSUF</b></h1>

      ${validate_component(Acm_button, "AcmButton").$$render($$result, { text: "Join us today!", link: "/discord" }, {}, {})}</div>

    <img src="${"assets/png/hero-illustration.png"}" alt="${"Frank the Shark holding a flag that says 'I Love ACM'"}" class="${"svelte-t6z1h5"}"></div>
</section>`;
    });
    css$22 = {
      code: "section.svelte-11ye1su.svelte-11ye1su{display:flex;justify-content:center;align-items:center}section.svelte-11ye1su .container.svelte-11ye1su{display:flex;align-items:center;text-align:right;justify-content:space-between;padding:0 16px;width:1280px}section.svelte-11ye1su .container img.svelte-11ye1su{width:clamp(12.5rem, 11.1184rem + 7.8947vw, 23.75rem);margin-right:32px;filter:drop-shadow(0 10px 40px rgba(44, 145, 198, 0.5))}section.svelte-11ye1su .container .right.svelte-11ye1su{display:flex;flex-direction:column;gap:16px}section.svelte-11ye1su .container .right p.svelte-11ye1su{max-width:650px}@media screen and (max-width: 900px){section.svelte-11ye1su .container.svelte-11ye1su{flex-direction:column;text-align:center;padding:0 8px;gap:64px}section.svelte-11ye1su .container img.svelte-11ye1su{margin:0;filter:drop-shadow(0 6px 24px rgba(44, 145, 198, 0.5))}}",
      map: null
    };
    Why_join = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      $$result.css.add(css$22);
      return `<section class="${"svelte-11ye1su"}"><div class="${"container svelte-11ye1su"}"><img src="${"assets/png/why-join-illustration.png"}" alt="${"Social event with ACM Chapter members."}" class="${"svelte-11ye1su"}">

    <div class="${"right svelte-11ye1su"}"><h2 class="${"size-lg brand-header"}">Your journey into tech starts here</h2>

      <p class="${"size-sm svelte-11ye1su"}">We aim to build a foundation for future industry leaders by developing their technical,
        professional, and social skills. We facilitate these by offering various events, programs,
        and initiatives that have been proven to help students start up their careers on the right
        foot.
      </p></div></div>
</section>`;
    });
    css$12 = {
      code: "section.svelte-2tomoo.svelte-2tomoo{display:flex;justify-content:center;align-items:center}section.svelte-2tomoo .container.svelte-2tomoo{display:flex;flex-direction:column;text-align:center;align-items:center;justify-content:space-between;padding:0 16px;width:1280px;gap:64px}section.svelte-2tomoo .container .paths-intro.svelte-2tomoo{display:flex;flex-direction:column;gap:16px}section.svelte-2tomoo .container .paths-list.svelte-2tomoo{display:flex;gap:96px}section.svelte-2tomoo .container .paths-list .path-item.svelte-2tomoo{display:flex;flex-direction:column;text-decoration:none}section.svelte-2tomoo .container .paths-list .path-item p.svelte-2tomoo{transition:0.25s ease-in-out}section.svelte-2tomoo .container .paths-list .path-item img.svelte-2tomoo{width:clamp(9.375rem, 8.8636rem + 2.2727vw, 12.5rem);transition:0.25s ease-in-out}section.svelte-2tomoo .container .paths-list .path-item:hover img.svelte-2tomoo{transform:scale(1.15)}section.svelte-2tomoo .container .paths-list .path-item:hover p.svelte-2tomoo{color:var(--brand-color)}@media screen and (max-width: 900px){section.svelte-2tomoo .container.svelte-2tomoo{padding:0 8px}section.svelte-2tomoo .container .paths-list.svelte-2tomoo{flex-direction:column;gap:48px}}",
      map: null
    };
    Acm_paths = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      $$result.css.add(css$12);
      return `<section class="${"svelte-2tomoo"}"><div class="${"container svelte-2tomoo"}"><div class="${"paths-intro svelte-2tomoo"}"><h2 class="${"brand-header size-lg"}">Discover your own path</h2>

      <p class="${"size-sm svelte-2tomoo"}">Paths were designed to allow students to explore the various fields within tech, and
        discover what aligns with their interests the most. Our paths offer interactive workshops
        that enhance technical knowledge, as well as fun projects to strengthen their abilities.
      </p></div>

    <div class="${"paths-list svelte-2tomoo"}">${each(pinnedPaths, ({ title, slug, picture, color }) => {
        return `<a class="${"path-item svelte-2tomoo"}" target="${"_self"}"${add_attribute("href", `/paths#${slug}`, 0)}><img${add_attribute("src", picture, 0)}${add_attribute("alt", `${slug} badge`, 0)} class="${"svelte-2tomoo"}">

          <p class="${"size-md brand-bold svelte-2tomoo"}"${add_styles({ "--brand-color": color })}>${escape(title)}</p>
        </a>`;
      })}</div></div>
</section>`;
    });
    css6 = {
      code: "section.svelte-zfljyw.svelte-zfljyw{display:flex;justify-content:center;align-items:center}section.svelte-zfljyw .container.svelte-zfljyw{display:flex;flex-direction:column;text-align:center;align-items:center;justify-content:space-between;padding:0 16px;width:1280px;gap:64px}section.svelte-zfljyw .container .main.svelte-zfljyw{display:flex;flex-direction:column;gap:16px}",
      map: null
    };
    Ready_up = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      $$result.css.add(css6);
      return `<section class="${"svelte-zfljyw"}"><div class="${"container svelte-zfljyw"}"><div class="${"main svelte-zfljyw"}"><h2 class="${"brand-header size-lg"}">Ready to get started?</h2>

      <p class="${"size-sm"}">If you want to improve your coding skills, find out how to break into the tech industry,
        connect with other people, pick up a new hobby, or just want to be involved in the tech
        space, then this is the place to be.

        <br><br>

        <span class="${"brand-med"}">Our chapter of 700+ members is forever free and open for anyone to join, regardless of
          major or technical ability.
        </span></p></div>

    ${validate_component(Acm_button, "AcmButton").$$render($$result, { text: "Join us today!", link: "/discord" }, {}, {})}</div>
</section>`;
    });
    Routes = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      return `${$$result.head += `${$$result.title = `<title>ACM at CSUF</title>`, ""}`, ""}

<div style="display: contents; --min:${"175px"}; --med:${"200px"}; --max:${"200px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

${validate_component(Hero, "Hero").$$render($$result, {}, {}, {})}

<div style="display: contents; --min:${"120px"}; --med:${"175px"}; --max:${"200px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

${validate_component(Why_join, "WhyJoin").$$render($$result, {}, {}, {})}

<div style="display: contents; --min:${"120px"}; --med:${"175px"}; --max:${"200px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

${validate_component(Acm_paths, "AcmPaths").$$render($$result, {}, {}, {})}

<div style="display: contents; --min:${"120px"}; --med:${"175px"}; --max:${"200px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

${validate_component(Ready_up, "ReadyUp").$$render($$result, {}, {}, {})}

<div style="display: contents; --min:${"75px"}; --med:${"100px"}; --max:${"120px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/6.js
var __exports3 = {};
__export(__exports3, {
  css: () => css7,
  entry: () => entry3,
  js: () => js3,
  module: () => index_svelte_exports
});
var entry3, js3, css7;
var init__3 = __esm({
  ".svelte-kit/output/server/nodes/6.js"() {
    init_index_svelte();
    entry3 = "pages/index.svelte-681cb170.js";
    js3 = ["pages/index.svelte-681cb170.js", "chunks/index-462fa7ca.js", "chunks/acm-paths-c5897a25.js", "chunks/spacing-fc7d06b9.js"];
    css7 = ["assets/pages/index.svelte-dbf9fd92.css", "assets/spacing-b2079594.css"];
  }
});

// .svelte-kit/output/server/chunks/officers-1f1dc4ef.js
var OFFICERS_JSON, TIERS_JSON, VISIBLE_TERMS, OFFICERS, TIERS;
var init_officers_1f1dc4ef = __esm({
  ".svelte-kit/output/server/chunks/officers-1f1dc4ef.js"() {
    OFFICERS_JSON = [
      {
        fullName: "Armanul Ambia",
        positions: {
          S21: {
            title: "Dev Officer",
            tier: 21
          },
          F21: {
            title: "Algo Director",
            tier: 14
          },
          S22: {
            title: "Algo President",
            tier: 14
          }
        },
        picture: "armanul-ambia.webp"
      },
      {
        fullName: "Jason Anthony",
        positions: {
          S21: {
            title: "Secretary",
            tier: 3
          }
        },
        picture: "jason-anthony.webp"
      },
      {
        fullName: "Angel Armendariz",
        positions: {
          S22: {
            title: "Dev Project Manager",
            tier: 22
          }
        },
        picture: "angel-armendariz.webp"
      },
      {
        fullName: "Sami Bajwa",
        positions: {
          F21: {
            title: "nodebuds Officer",
            tier: 23
          },
          S22: {
            title: "Algo Officer, nodebuds Officer",
            tier: 15
          }
        },
        picture: "sami-bajwa.webp"
      },
      {
        fullName: "Johnathan Carranza",
        positions: {
          F21: {
            title: "Dev Officer",
            tier: 21
          }
        },
        picture: "johnathan-carranza.webp"
      },
      {
        fullName: "Alan Cortez",
        positions: {
          S22: {
            title: "Create Officer",
            tier: 17
          }
        },
        picture: "alan-cortez.webp"
      },
      {
        fullName: "Wesley Chou",
        positions: {
          S21: {
            title: "Dev Officer",
            tier: 21
          },
          F21: {
            title: "Dev Director",
            tier: 20
          },
          S22: {
            title: "Dev President",
            tier: 20
          }
        },
        picture: "wesley-chou.webp"
      },
      {
        fullName: "Ethan Davidson",
        positions: {
          S21: {
            title: "Webmaster",
            tier: 5
          },
          F21: {
            title: "Webmaster",
            tier: 5
          },
          S22: {
            title: "Webmaster",
            tier: 5
          }
        },
        picture: "ethan-davidson.webp"
      },
      {
        fullName: "Kevin Dillon",
        positions: {
          S21: {
            title: "Algo Officer",
            tier: 15
          }
        },
        picture: "kevin-dillon.webp"
      },
      {
        fullName: "Duc Dinh",
        positions: {
          S22: {
            title: "Dev Project Manager",
            tier: 22
          }
        },
        picture: "duc-dinh.webp"
      },
      {
        fullName: "Eduardo Gomez",
        positions: {
          S21: {
            title: "nodebuds Officer",
            tier: 23
          }
        },
        picture: "eduardo-gomez.webp"
      },
      {
        fullName: "Nurhaliza Hassan",
        positions: {
          S22: {
            title: "Marketing Director",
            tier: 12
          }
        },
        picture: "nurhaliza-hassan.webp"
      },
      {
        fullName: "Lisa Hong",
        positions: {
          S21: {
            title: "Create Officer",
            tier: 17
          }
        },
        picture: "lisa-hong.webp"
      },
      {
        fullName: "Joshua Hughes",
        positions: {
          S21: {
            title: "ICC Representative",
            tier: 8
          }
        },
        picture: "joshua-hughes.webp"
      },
      {
        fullName: "Iftekharul Islam",
        positions: {
          S22: {
            title: "Algo Officer",
            tier: 15
          }
        },
        picture: "iftekharul-islam.webp"
      },
      {
        fullName: "Ibrahim Israr",
        positions: {
          S22: {
            title: "Secretary",
            tier: 3
          }
        },
        picture: "ibrahim-israr.webp"
      },
      {
        fullName: "Joel Anil John",
        positions: {
          S22: {
            title: "Dev Officer",
            tier: 21
          }
        },
        picture: "joel-anil-john.webp"
      },
      {
        fullName: "Andy Lasso",
        positions: {
          F21: {
            title: "Dev Officer",
            tier: 21
          }
        },
        picture: "andy-lasso.webp"
      },
      {
        fullName: "Andrew Lau",
        positions: {
          S21: {
            title: "Treasurer",
            tier: 4
          }
        },
        picture: "andrew-lau.webp"
      },
      {
        fullName: "Minh Le",
        positions: {
          S22: {
            title: "Dev Officer",
            tier: 21
          }
        },
        picture: "minh-le.webp"
      },
      {
        fullName: "Nguyen Le",
        positions: {
          S22: {
            title: "Data Analyst",
            tier: 7
          }
        },
        picture: "nguyen-le.webp"
      },
      {
        fullName: "Tommy Le",
        positions: {
          F21: {
            title: "Treasurer",
            tier: 4
          },
          S22: {
            title: "Treasurer",
            tier: 4
          }
        },
        picture: "tommy-le.webp"
      },
      {
        fullName: "Eugene Lee",
        positions: {
          S21: {
            title: "nodebuds Officer",
            tier: 23
          },
          F21: {
            title: "nodebuds Officer",
            tier: 23
          },
          S22: {
            title: "nodebuds Officer",
            tier: 23
          }
        },
        picture: "eugene-lee.webp"
      },
      {
        fullName: "Nolan Lee",
        positions: {
          S22: {
            title: "Historian",
            tier: 13
          }
        },
        picture: "nolan-lee.webp"
      },
      {
        fullName: "Aaron Lieberman",
        positions: {
          S21: {
            title: "Internal Vice President, nodebuds Officer",
            tier: 2
          },
          F21: {
            title: "President, nodebuds Officer",
            tier: 0
          },
          S22: {
            title: "President, nodebuds Officer",
            tier: 0
          }
        },
        picture: "aaron-lieberman.webp"
      },
      {
        fullName: "Shaleen Mathur",
        positions: {
          S21: {
            title: "Workshop Manager",
            tier: 6
          }
        },
        picture: "shaleen-mathur.webp"
      },
      {
        fullName: "Ean McGilvery",
        positions: {
          S21: {
            title: "nodebuds Officer",
            tier: 23
          }
        },
        picture: "ean-mcgilvery.webp"
      },
      {
        fullName: "Jorge Mejia",
        positions: {
          F21: {
            title: "Dev Officer",
            tier: 21
          },
          S22: {
            title: "Dev Officer",
            tier: 21
          }
        },
        picture: "jorge-mejia.webp"
      },
      {
        fullName: "Serena Naranjo",
        positions: {
          F21: {
            title: "Create Officer",
            tier: 17
          },
          S22: {
            title: "Create Officer",
            tier: 17
          }
        },
        picture: "serena-naranjo.webp"
      },
      {
        fullName: "Dalisa Nguyen",
        positions: {
          S21: {
            title: "nodebuds Officer",
            tier: 23
          }
        },
        picture: "dalisa-nguyen.webp"
      },
      {
        fullName: "Kayla Nguyen",
        positions: {
          F21: {
            title: "Create Officer",
            tier: 17
          }
        },
        picture: "kayla-nguyen.webp"
      },
      {
        fullName: "Jacob Nguyen",
        positions: {
          S21: {
            title: "President, Create Director, nodebuds Officer",
            tier: 0
          }
        },
        picture: "jacob-nguyen.webp"
      },
      {
        fullName: "Taylor Noh",
        positions: {
          S21: {
            title: "nodebuds Officer",
            tier: 23
          },
          F21: {
            title: "nodebuds Officer",
            tier: 23
          },
          S22: {
            title: "nodebuds Officer",
            tier: 23
          }
        },
        picture: "taylor-noh.webp"
      },
      {
        fullName: "Kirsten Ochoa",
        positions: {
          S22: {
            title: "Create Project Developer",
            tier: 18
          }
        },
        picture: "kirsten-ochoa.webp"
      },
      {
        fullName: "Mike Ploythai",
        positions: {
          S21: {
            title: "Create Officer",
            tier: 17
          },
          F21: {
            title: "Create Director, Marketing Chair",
            tier: 16
          },
          S22: {
            title: "Create President",
            tier: 16
          }
        },
        picture: "mike-ploythai.webp"
      },
      {
        fullName: "Stephanie Pocci",
        positions: {
          S22: {
            title: "Event Coordinator",
            tier: 9
          }
        },
        picture: "stephanie-pocci.webp"
      },
      {
        fullName: "Nicolas Renteria",
        positions: {
          S21: {
            title: "Marketing Chair",
            tier: 12
          }
        },
        picture: "nicolas-renteria.webp"
      },
      {
        fullName: "Wilbert Rodriguez",
        positions: {
          S21: {
            title: "Intern Program Manager",
            tier: 11
          }
        },
        picture: "wilbert-rodriguez.webp"
      },
      {
        fullName: "Samuel Sandoval",
        positions: {
          S21: {
            title: "Vice President, Dev Director",
            tier: 1
          }
        },
        picture: "samuel-sandoval.webp"
      },
      {
        fullName: "Kavit Sanghavi",
        positions: {
          S21: {
            title: "Algo Director",
            tier: 11
          }
        },
        picture: "kavit-sanghavi.webp"
      },
      {
        fullName: "Parth Sharma",
        positions: {
          S21: {
            title: "Algo Officer",
            tier: 15
          }
        },
        picture: "parth-sharma.webp"
      },
      {
        fullName: "Justin Stitt",
        positions: {
          S22: {
            title: "Algo Officer",
            tier: 15
          }
        },
        picture: "justin-stitt.webp"
      },
      {
        fullName: "Johnson Tong",
        positions: {
          S21: {
            title: "Workshop Manager",
            tier: 6
          }
        },
        picture: "johnson-tong.webp"
      },
      {
        fullName: "Alex Truong",
        positions: {
          F21: {
            title: "Algo Officer",
            tier: 15
          }
        },
        picture: "alex-truong.webp"
      },
      {
        fullName: "Daniel Truong",
        positions: {
          S22: {
            title: "Dev Project Manager",
            tier: 22
          }
        },
        picture: "daniel-truong.webp"
      },
      {
        fullName: "Samuel Valls",
        positions: {
          S21: {
            title: "Community Manager",
            tier: 10
          },
          F21: {
            title: "Create Officer",
            tier: 17
          },
          S22: {
            title: "Create Operations Manager",
            tier: 19
          }
        },
        picture: "samuel-valls.webp"
      },
      {
        fullName: "Karnikaa Velumani",
        positions: {
          F21: {
            title: "Vice President",
            tier: 1
          },
          S22: {
            title: "Vice President",
            tier: 1
          }
        },
        picture: "karnikaa-velumani.webp"
      },
      {
        fullName: "Rina Watanabe",
        positions: {
          F21: {
            title: "Dev Project Manager",
            tier: 22
          }
        },
        picture: "rina-watanabe.webp"
      },
      {
        fullName: "Jason Wong",
        positions: {
          S22: {
            title: "Historian",
            tier: 13
          }
        },
        picture: "jason-wong.webp"
      }
    ];
    TIERS_JSON = [
      "President",
      "Vice President",
      "Secretary",
      "Treasurer",
      "Webmaster",
      "Data Analyst",
      "Event Coordinator",
      "Marketing Director",
      "Historian",
      "Algo President",
      "Algo Officer",
      "Create President",
      "Create Officer",
      "Create Project Developer",
      "Create Operations Manager",
      "Dev President",
      "Dev Officer",
      "Dev Project Manager",
      "Deprecated Position"
    ];
    VISIBLE_TERMS = ["S22", "F21", "S21"];
    OFFICERS = [...OFFICERS_JSON];
    TIERS = [...TIERS_JSON];
  }
});

// .svelte-kit/output/server/chunks/officer-profile-list-ec5ae8e4.js
function formatTerm(termCode) {
  const [termAbbr, yearDigit1, yearDigit2] = termCode.split("");
  const termText = termAbbr === "S" ? "Spring" : "Fall";
  return `${termText} 20${yearDigit1}${yearDigit2}`;
}
function sortByTier(termCode) {
  return (a, b) => {
    const aTier = a.positions[termCode].tier;
    const bTier = b.positions[termCode].tier;
    return aTier - bTier;
  };
}
var termIndex, css$23, Officer_profile, css$13, Acm_select, css8, Officer_profile_list;
var init_officer_profile_list_ec5ae8e4 = __esm({
  ".svelte-kit/output/server/chunks/officer-profile-list-ec5ae8e4.js"() {
    init_index_b01bd1b0();
    init_index_ba3ba78e();
    init_index_b8bace31();
    init_officers_1f1dc4ef();
    termIndex = writable2(0);
    css$23 = {
      code: ".officer-container.svelte-haq5vd.svelte-haq5vd{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center}.officer-container.svelte-haq5vd .officer-image.svelte-haq5vd{width:200px;height:auto}.officer-container.svelte-haq5vd p.svelte-haq5vd{max-width:250px}",
      map: null
    };
    Officer_profile = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      let titleHTML;
      let officerTier;
      let $termIndex, $$unsubscribe_termIndex;
      $$unsubscribe_termIndex = subscribe(termIndex, (value) => $termIndex = value);
      var _a4, _b;
      let { info } = $$props;
      let { placeholderPicture = "placeholder.webp" } = $$props;
      let { dev = false } = $$props;
      const officerName = (_a4 = info.fullName) !== null && _a4 !== void 0 ? _a4 : "";
      const officerPicture = (_b = info.picture) !== null && _b !== void 0 ? _b : placeholderPicture;
      if ($$props.info === void 0 && $$bindings.info && info !== void 0)
        $$bindings.info(info);
      if ($$props.placeholderPicture === void 0 && $$bindings.placeholderPicture && placeholderPicture !== void 0)
        $$bindings.placeholderPicture(placeholderPicture);
      if ($$props.dev === void 0 && $$bindings.dev && dev !== void 0)
        $$bindings.dev(dev);
      $$result.css.add(css$23);
      titleHTML = info.positions[VISIBLE_TERMS[$termIndex]].title.replace(/Algo\s/, `<b class="acm-purple">Algo&nbsp;</b>`).replace(/Create\s/, `<b class="acm-pink">Create&nbsp;</b>`).replace(/Dev\s/, `<b class="acm-bluer">Dev&nbsp;</b>`).replace(/nodebuds\s/, `<span class="brand-header">Node Buds&nbsp;</span>`);
      officerTier = dev ? TIERS[info.positions[VISIBLE_TERMS[$termIndex]].tier] : "";
      $$unsubscribe_termIndex();
      return `<div class="${"officer-container svelte-haq5vd"}"><img class="${"officer-image svelte-haq5vd"}"${add_attribute("src", `../assets/authors/${officerPicture}`, 0)}${add_attribute("alt", `Image of ${officerName}.`, 0)}>

  <div><h3 class="${"brand-header"}">${escape(officerName)}
      ${officerTier.length ? `<br>${escape(officerTier)}<br>` : ``}</h3>

    <p class="${"brand-med svelte-haq5vd"}"><!-- HTML_TAG_START -->${titleHTML}<!-- HTML_TAG_END --></p></div>
</div>`;
    });
    css$13 = {
      code: ".term.svelte-1ighfmc.svelte-1ighfmc.svelte-1ighfmc{font-weight:600}.term.svelte-1ighfmc .option-box.svelte-1ighfmc.svelte-1ighfmc{flex-direction:column;display:flex;justify-content:center;font-size:var(--size-sm);user-select:none}.term.svelte-1ighfmc .option-box .option-choice.svelte-1ighfmc.svelte-1ighfmc,.term.svelte-1ighfmc .option-box .selected.svelte-1ighfmc.svelte-1ighfmc{color:var(--perma-light)}.term.svelte-1ighfmc .option-box .selected.svelte-1ighfmc.svelte-1ighfmc{background-color:var(--button-bg);padding:8px 24px;cursor:pointer;border-radius:8px;transition:0.25s ease-in-out}.term.svelte-1ighfmc .option-box .selected.svelte-1ighfmc.svelte-1ighfmc:hover{background-color:var(--button-hover)}.term.svelte-1ighfmc .option-box .option.svelte-1ighfmc.svelte-1ighfmc{cursor:pointer;opacity:0;transition:0.25s ease-in-out}.term.svelte-1ighfmc .option-box .option .option-choice.svelte-1ighfmc.svelte-1ighfmc{text-align:center;cursor:pointer;transition:0.25s ease-in-out}.term.svelte-1ighfmc .option-box .option .option-choice.svelte-1ighfmc.svelte-1ighfmc:hover{color:var(--acm-blue)}.term.svelte-1ighfmc .active.svelte-1ighfmc>.selected.svelte-1ighfmc{border-radius:8px 8px 0 0}.term.svelte-1ighfmc .active.svelte-1ighfmc>.option.svelte-1ighfmc{opacity:100%;background-color:var(--button-bg);padding:8px 24px;margin-top:0.2rem;border-radius:0 0 8px 8px;transition:0.25s ease-in-out}",
      map: null
    };
    Acm_select = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      let { defaultValue = "" } = $$props;
      let { options = [] } = $$props;
      let currentValue = defaultValue;
      if ($$props.defaultValue === void 0 && $$bindings.defaultValue && defaultValue !== void 0)
        $$bindings.defaultValue(defaultValue);
      if ($$props.options === void 0 && $$bindings.options && options !== void 0)
        $$bindings.options(options);
      $$result.css.add(css$13);
      return `<div class="${"term svelte-1ighfmc"}" name="${"school-year"}"><div class="${["option-box svelte-1ighfmc", ""].join(" ").trim()}"><div class="${"selected svelte-1ighfmc"}">${escape(currentValue)}</div>

    <div class="${"option svelte-1ighfmc"}">${each(options, (optionValue) => {
        return `<div class="${"option-choice svelte-1ighfmc"}">${escape(optionValue)}
        </div>`;
      })}</div></div>
</div>`;
    });
    css8 = {
      code: "section.svelte-1y5pwqh.svelte-1y5pwqh{display:flex;flex-direction:column;justify-content:center;align-items:center;gap:16px}section.svelte-1y5pwqh .container.svelte-1y5pwqh{width:100%;max-width:1100px}section.svelte-1y5pwqh .container .button.svelte-1y5pwqh{display:flex;justify-content:center}section.svelte-1y5pwqh .container .officer-list.svelte-1y5pwqh{display:grid;grid-template-columns:repeat(auto-fill, minmax(250px, 1fr));justify-content:center;align-items:center;row-gap:64px}",
      map: null
    };
    Officer_profile_list = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      let $termIndex, $$unsubscribe_termIndex;
      $$unsubscribe_termIndex = subscribe(termIndex, (value) => $termIndex = value);
      let { placeholderPicture = void 0 } = $$props;
      let { filter } = $$props;
      const formattedTerms = VISIBLE_TERMS.map(formatTerm);
      let filteredOfficers = [];
      let currentFormattedTerm = formattedTerms[$termIndex];
      termIndex.subscribe(() => filteredOfficers = OFFICERS.filter(filter).sort(sortByTier(VISIBLE_TERMS[$termIndex])));
      if ($$props.placeholderPicture === void 0 && $$bindings.placeholderPicture && placeholderPicture !== void 0)
        $$bindings.placeholderPicture(placeholderPicture);
      if ($$props.filter === void 0 && $$bindings.filter && filter !== void 0)
        $$bindings.filter(filter);
      $$result.css.add(css8);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        set_store_value(termIndex, $termIndex = formattedTerms.indexOf(currentFormattedTerm), $termIndex);
        $$rendered = `<section class="${"svelte-1y5pwqh"}"><div class="${"container svelte-1y5pwqh"}"><div class="${"button svelte-1y5pwqh"}">${validate_component(Acm_select, "AcmSelect").$$render($$result, {
          options: formattedTerms,
          defaultValue: currentFormattedTerm
        }, {
          defaultValue: ($$value) => {
            currentFormattedTerm = $$value;
            $$settled = false;
          }
        }, {})}</div>

    <div class="${"officer-list svelte-1y5pwqh"}">${each(filteredOfficers, (officer) => {
          return `${validate_component(Officer_profile, "OfficerProfile").$$render($$result, { info: officer, placeholderPicture }, {}, {})}`;
        })}</div></div>
</section>`;
      } while (!$$settled);
      $$unsubscribe_termIndex();
      return $$rendered;
    });
  }
});

// .svelte-kit/output/server/entries/pages/about/index.svelte.js
var index_svelte_exports2 = {};
__export(index_svelte_exports2, {
  default: () => About
});
var css$14, About_us, css9, About;
var init_index_svelte2 = __esm({
  ".svelte-kit/output/server/entries/pages/about/index.svelte.js"() {
    init_index_b01bd1b0();
    init_spacing_a132bf4f();
    init_officer_profile_list_ec5ae8e4();
    init_officers_1f1dc4ef();
    init_index_ba3ba78e();
    init_index_b8bace31();
    css$14 = {
      code: "section.svelte-1tpd2eh.svelte-1tpd2eh{display:flex;justify-content:center;align-items:center}section.svelte-1tpd2eh .container.svelte-1tpd2eh{display:flex;flex-direction:column;align-items:center;padding:0 16px;width:1280px;gap:64px}section.svelte-1tpd2eh .container img.svelte-1tpd2eh{min-width:250px;max-width:800px;width:100%}section.svelte-1tpd2eh .container .text.svelte-1tpd2eh{display:flex;flex-direction:column;text-align:center;gap:16px}section.svelte-1tpd2eh .container .text p a.svelte-1tpd2eh{text-decoration:none;transition:0.25s ease-in-out}section.svelte-1tpd2eh .container .text p a.svelte-1tpd2eh:hover{color:var(--acm-blue)}@media screen and (max-width: 900px){section.svelte-1tpd2eh .container.svelte-1tpd2eh{padding:0 8px}}",
      map: null
    };
    About_us = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      $$result.css.add(css$14);
      return `<section class="${"svelte-1tpd2eh"}"><div class="${"container svelte-1tpd2eh"}"><img src="${"assets/about-illustration.svg"}" alt="${"acmCSUF badges"}" class="${"svelte-1tpd2eh"}">

    <div class="${"text svelte-1tpd2eh"}"><h1 class="${"size-lg brand-header"}">About us</h1>

      <p class="${"size-sm"}">We are a student chapter of the
        <a href="${"https://acm.org"}" class="${"brand-med svelte-1tpd2eh"}" target="${"_blank"}" rel="${"noopener noreferrer"}">Association for Computing Machinery</a>, an international organization based in New York that advocates for the advancement of
        computer science as a science and profession. Based in California State University,
        Fullerton, we strive to bring passionate Titans together into a community that promotes
        innovation, collaboration, creativity, and inclusivity within tech.
      </p></div></div>
</section>`;
    });
    css9 = {
      code: "h1.svelte-o7zg6s{display:flex;justify-content:center}",
      map: null
    };
    About = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      let $termIndex, $$unsubscribe_termIndex;
      $$unsubscribe_termIndex = subscribe(termIndex, (value) => $termIndex = value);
      function filterOfficers(officer) {
        const isCurrentTerm = officer.positions[VISIBLE_TERMS[$termIndex]] !== void 0;
        return isCurrentTerm;
      }
      $$result.css.add(css9);
      $$unsubscribe_termIndex();
      return `${$$result.head += `${$$result.title = `<title>About | ACM at CSUF</title>`, ""}`, ""}

<div style="display: contents; --min:${"175px"}; --med:${"200px"}; --max:${"200px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

${validate_component(About_us, "AboutUs").$$render($$result, {}, {}, {})}

<div style="display: contents; --min:${"120px"}; --med:${"150px"}; --max:${"200px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

<h1 class="${"size-lg brand-header svelte-o7zg6s"}">Board members</h1>

<div style="display: contents; --min:${"16px"}; --med:${"16px"}; --max:${"16px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

${validate_component(Officer_profile_list, "OfficerProfileList").$$render($$result, {
        filter: filterOfficers,
        placeholderPicture: "placeholder.png"
      }, {}, {})}

<div style="display: contents; --min:${"40px"}; --med:${"95px"}; --max:${"120px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/2.js
var __exports4 = {};
__export(__exports4, {
  css: () => css10,
  entry: () => entry4,
  js: () => js4,
  module: () => index_svelte_exports2
});
var entry4, js4, css10;
var init__4 = __esm({
  ".svelte-kit/output/server/nodes/2.js"() {
    init_index_svelte2();
    entry4 = "pages/about/index.svelte-f07d4905.js";
    js4 = ["pages/about/index.svelte-f07d4905.js", "chunks/index-462fa7ca.js", "chunks/spacing-fc7d06b9.js", "chunks/officer-profile-list-3690987d.js", "chunks/index-cc4b3e8c.js", "chunks/index-af743adc.js"];
    css10 = ["assets/pages/about/index.svelte-165e2d32.css", "assets/spacing-b2079594.css", "assets/officer-profile-list-9f843ddf.css"];
  }
});

// node_modules/jsbi/dist/jsbi-cjs.js
var require_jsbi_cjs = __commonJS({
  "node_modules/jsbi/dist/jsbi-cjs.js"(exports, module2) {
    "use strict";
    var JSBI2 = class extends Array {
      constructor(i2, _) {
        if (super(i2), this.sign = _, Object.setPrototypeOf(this, JSBI2.prototype), i2 > JSBI2.__kMaxLength)
          throw new RangeError("Maximum BigInt size exceeded");
      }
      static BigInt(i2) {
        var _ = Math.floor, t2 = Number.isFinite;
        if (typeof i2 == "number") {
          if (i2 === 0)
            return JSBI2.__zero();
          if (JSBI2.__isOneDigitInt(i2))
            return 0 > i2 ? JSBI2.__oneDigit(-i2, true) : JSBI2.__oneDigit(i2, false);
          if (!t2(i2) || _(i2) !== i2)
            throw new RangeError("The number " + i2 + " cannot be converted to BigInt because it is not an integer");
          return JSBI2.__fromDouble(i2);
        }
        if (typeof i2 == "string") {
          const _2 = JSBI2.__fromString(i2);
          if (_2 === null)
            throw new SyntaxError("Cannot convert " + i2 + " to a BigInt");
          return _2;
        }
        if (typeof i2 == "boolean")
          return i2 === true ? JSBI2.__oneDigit(1, false) : JSBI2.__zero();
        if (typeof i2 == "object") {
          if (i2.constructor === JSBI2)
            return i2;
          const _2 = JSBI2.__toPrimitive(i2);
          return JSBI2.BigInt(_2);
        }
        throw new TypeError("Cannot convert " + i2 + " to a BigInt");
      }
      toDebugString() {
        const i2 = ["BigInt["];
        for (const _ of this)
          i2.push((_ ? (_ >>> 0).toString(16) : _) + ", ");
        return i2.push("]"), i2.join("");
      }
      toString(i2 = 10) {
        if (2 > i2 || 36 < i2)
          throw new RangeError("toString() radix argument must be between 2 and 36");
        return this.length === 0 ? "0" : (i2 & i2 - 1) == 0 ? JSBI2.__toStringBasePowerOfTwo(this, i2) : JSBI2.__toStringGeneric(this, i2, false);
      }
      valueOf() {
        throw new Error("Convert JSBI instances to native numbers using `toNumber`.");
      }
      static toNumber(i2) {
        const _ = i2.length;
        if (_ === 0)
          return 0;
        if (_ === 1) {
          const _2 = i2.__unsignedDigit(0);
          return i2.sign ? -_2 : _2;
        }
        const t2 = i2.__digit(_ - 1), e2 = JSBI2.__clz30(t2), n = 30 * _ - e2;
        if (1024 < n)
          return i2.sign ? -Infinity : 1 / 0;
        let g = n - 1, s3 = t2, o = _ - 1;
        const l = e2 + 3;
        let r2 = l === 32 ? 0 : s3 << l;
        r2 >>>= 12;
        const a = l - 12;
        let u = 12 <= l ? 0 : s3 << 20 + l, d = 20 + l;
        for (0 < a && 0 < o && (o--, s3 = i2.__digit(o), r2 |= s3 >>> 30 - a, u = s3 << a + 2, d = a + 2); 0 < d && 0 < o; )
          o--, s3 = i2.__digit(o), u |= 30 <= d ? s3 << d - 30 : s3 >>> 30 - d, d -= 30;
        const h2 = JSBI2.__decideRounding(i2, d, o, s3);
        if ((h2 === 1 || h2 === 0 && (1 & u) == 1) && (u = u + 1 >>> 0, u === 0 && (r2++, r2 >>> 20 != 0 && (r2 = 0, g++, 1023 < g))))
          return i2.sign ? -Infinity : 1 / 0;
        const m2 = i2.sign ? -2147483648 : 0;
        return g = g + 1023 << 20, JSBI2.__kBitConversionInts[1] = m2 | g | r2, JSBI2.__kBitConversionInts[0] = u, JSBI2.__kBitConversionDouble[0];
      }
      static unaryMinus(i2) {
        if (i2.length === 0)
          return i2;
        const _ = i2.__copy();
        return _.sign = !i2.sign, _;
      }
      static bitwiseNot(i2) {
        return i2.sign ? JSBI2.__absoluteSubOne(i2).__trim() : JSBI2.__absoluteAddOne(i2, true);
      }
      static exponentiate(i2, _) {
        if (_.sign)
          throw new RangeError("Exponent must be positive");
        if (_.length === 0)
          return JSBI2.__oneDigit(1, false);
        if (i2.length === 0)
          return i2;
        if (i2.length === 1 && i2.__digit(0) === 1)
          return i2.sign && (1 & _.__digit(0)) == 0 ? JSBI2.unaryMinus(i2) : i2;
        if (1 < _.length)
          throw new RangeError("BigInt too big");
        let t2 = _.__unsignedDigit(0);
        if (t2 === 1)
          return i2;
        if (t2 >= JSBI2.__kMaxLengthBits)
          throw new RangeError("BigInt too big");
        if (i2.length === 1 && i2.__digit(0) === 2) {
          const _2 = 1 + (0 | t2 / 30), e3 = i2.sign && (1 & t2) != 0, n2 = new JSBI2(_2, e3);
          n2.__initializeDigits();
          const g = 1 << t2 % 30;
          return n2.__setDigit(_2 - 1, g), n2;
        }
        let e2 = null, n = i2;
        for ((1 & t2) != 0 && (e2 = i2), t2 >>= 1; t2 !== 0; t2 >>= 1)
          n = JSBI2.multiply(n, n), (1 & t2) != 0 && (e2 === null ? e2 = n : e2 = JSBI2.multiply(e2, n));
        return e2;
      }
      static multiply(_, t2) {
        if (_.length === 0)
          return _;
        if (t2.length === 0)
          return t2;
        let i2 = _.length + t2.length;
        30 <= _.__clzmsd() + t2.__clzmsd() && i2--;
        const e2 = new JSBI2(i2, _.sign !== t2.sign);
        e2.__initializeDigits();
        for (let n = 0; n < _.length; n++)
          JSBI2.__multiplyAccumulate(t2, _.__digit(n), e2, n);
        return e2.__trim();
      }
      static divide(i2, _) {
        if (_.length === 0)
          throw new RangeError("Division by zero");
        if (0 > JSBI2.__absoluteCompare(i2, _))
          return JSBI2.__zero();
        const t2 = i2.sign !== _.sign, e2 = _.__unsignedDigit(0);
        let n;
        if (_.length === 1 && 32767 >= e2) {
          if (e2 === 1)
            return t2 === i2.sign ? i2 : JSBI2.unaryMinus(i2);
          n = JSBI2.__absoluteDivSmall(i2, e2, null);
        } else
          n = JSBI2.__absoluteDivLarge(i2, _, true, false);
        return n.sign = t2, n.__trim();
      }
      static remainder(i2, _) {
        if (_.length === 0)
          throw new RangeError("Division by zero");
        if (0 > JSBI2.__absoluteCompare(i2, _))
          return i2;
        const t2 = _.__unsignedDigit(0);
        if (_.length === 1 && 32767 >= t2) {
          if (t2 === 1)
            return JSBI2.__zero();
          const _2 = JSBI2.__absoluteModSmall(i2, t2);
          return _2 === 0 ? JSBI2.__zero() : JSBI2.__oneDigit(_2, i2.sign);
        }
        const e2 = JSBI2.__absoluteDivLarge(i2, _, false, true);
        return e2.sign = i2.sign, e2.__trim();
      }
      static add(i2, _) {
        const t2 = i2.sign;
        return t2 === _.sign ? JSBI2.__absoluteAdd(i2, _, t2) : 0 <= JSBI2.__absoluteCompare(i2, _) ? JSBI2.__absoluteSub(i2, _, t2) : JSBI2.__absoluteSub(_, i2, !t2);
      }
      static subtract(i2, _) {
        const t2 = i2.sign;
        return t2 === _.sign ? 0 <= JSBI2.__absoluteCompare(i2, _) ? JSBI2.__absoluteSub(i2, _, t2) : JSBI2.__absoluteSub(_, i2, !t2) : JSBI2.__absoluteAdd(i2, _, t2);
      }
      static leftShift(i2, _) {
        return _.length === 0 || i2.length === 0 ? i2 : _.sign ? JSBI2.__rightShiftByAbsolute(i2, _) : JSBI2.__leftShiftByAbsolute(i2, _);
      }
      static signedRightShift(i2, _) {
        return _.length === 0 || i2.length === 0 ? i2 : _.sign ? JSBI2.__leftShiftByAbsolute(i2, _) : JSBI2.__rightShiftByAbsolute(i2, _);
      }
      static unsignedRightShift() {
        throw new TypeError("BigInts have no unsigned right shift; use >> instead");
      }
      static lessThan(i2, _) {
        return 0 > JSBI2.__compareToBigInt(i2, _);
      }
      static lessThanOrEqual(i2, _) {
        return 0 >= JSBI2.__compareToBigInt(i2, _);
      }
      static greaterThan(i2, _) {
        return 0 < JSBI2.__compareToBigInt(i2, _);
      }
      static greaterThanOrEqual(i2, _) {
        return 0 <= JSBI2.__compareToBigInt(i2, _);
      }
      static equal(_, t2) {
        if (_.sign !== t2.sign)
          return false;
        if (_.length !== t2.length)
          return false;
        for (let e2 = 0; e2 < _.length; e2++)
          if (_.__digit(e2) !== t2.__digit(e2))
            return false;
        return true;
      }
      static notEqual(i2, _) {
        return !JSBI2.equal(i2, _);
      }
      static bitwiseAnd(i2, _) {
        var t2 = Math.max;
        if (!i2.sign && !_.sign)
          return JSBI2.__absoluteAnd(i2, _).__trim();
        if (i2.sign && _.sign) {
          const e2 = t2(i2.length, _.length) + 1;
          let n = JSBI2.__absoluteSubOne(i2, e2);
          const g = JSBI2.__absoluteSubOne(_);
          return n = JSBI2.__absoluteOr(n, g, n), JSBI2.__absoluteAddOne(n, true, n).__trim();
        }
        return i2.sign && ([i2, _] = [_, i2]), JSBI2.__absoluteAndNot(i2, JSBI2.__absoluteSubOne(_)).__trim();
      }
      static bitwiseXor(i2, _) {
        var t2 = Math.max;
        if (!i2.sign && !_.sign)
          return JSBI2.__absoluteXor(i2, _).__trim();
        if (i2.sign && _.sign) {
          const e3 = t2(i2.length, _.length), n2 = JSBI2.__absoluteSubOne(i2, e3), g = JSBI2.__absoluteSubOne(_);
          return JSBI2.__absoluteXor(n2, g, n2).__trim();
        }
        const e2 = t2(i2.length, _.length) + 1;
        i2.sign && ([i2, _] = [_, i2]);
        let n = JSBI2.__absoluteSubOne(_, e2);
        return n = JSBI2.__absoluteXor(n, i2, n), JSBI2.__absoluteAddOne(n, true, n).__trim();
      }
      static bitwiseOr(i2, _) {
        var t2 = Math.max;
        const e2 = t2(i2.length, _.length);
        if (!i2.sign && !_.sign)
          return JSBI2.__absoluteOr(i2, _).__trim();
        if (i2.sign && _.sign) {
          let t3 = JSBI2.__absoluteSubOne(i2, e2);
          const n2 = JSBI2.__absoluteSubOne(_);
          return t3 = JSBI2.__absoluteAnd(t3, n2, t3), JSBI2.__absoluteAddOne(t3, true, t3).__trim();
        }
        i2.sign && ([i2, _] = [_, i2]);
        let n = JSBI2.__absoluteSubOne(_, e2);
        return n = JSBI2.__absoluteAndNot(n, i2, n), JSBI2.__absoluteAddOne(n, true, n).__trim();
      }
      static asIntN(_, t2) {
        var i2 = Math.floor;
        if (t2.length === 0)
          return t2;
        if (_ = i2(_), 0 > _)
          throw new RangeError("Invalid value: not (convertible to) a safe integer");
        if (_ === 0)
          return JSBI2.__zero();
        if (_ >= JSBI2.__kMaxLengthBits)
          return t2;
        const e2 = 0 | (_ + 29) / 30;
        if (t2.length < e2)
          return t2;
        const g = t2.__unsignedDigit(e2 - 1), s3 = 1 << (_ - 1) % 30;
        if (t2.length === e2 && g < s3)
          return t2;
        if (!((g & s3) === s3))
          return JSBI2.__truncateToNBits(_, t2);
        if (!t2.sign)
          return JSBI2.__truncateAndSubFromPowerOfTwo(_, t2, true);
        if ((g & s3 - 1) == 0) {
          for (let n = e2 - 2; 0 <= n; n--)
            if (t2.__digit(n) !== 0)
              return JSBI2.__truncateAndSubFromPowerOfTwo(_, t2, false);
          return t2.length === e2 && g === s3 ? t2 : JSBI2.__truncateToNBits(_, t2);
        }
        return JSBI2.__truncateAndSubFromPowerOfTwo(_, t2, false);
      }
      static asUintN(i2, _) {
        var t2 = Math.floor;
        if (_.length === 0)
          return _;
        if (i2 = t2(i2), 0 > i2)
          throw new RangeError("Invalid value: not (convertible to) a safe integer");
        if (i2 === 0)
          return JSBI2.__zero();
        if (_.sign) {
          if (i2 > JSBI2.__kMaxLengthBits)
            throw new RangeError("BigInt too big");
          return JSBI2.__truncateAndSubFromPowerOfTwo(i2, _, false);
        }
        if (i2 >= JSBI2.__kMaxLengthBits)
          return _;
        const e2 = 0 | (i2 + 29) / 30;
        if (_.length < e2)
          return _;
        const g = i2 % 30;
        if (_.length == e2) {
          if (g === 0)
            return _;
          const i3 = _.__digit(e2 - 1);
          if (i3 >>> g == 0)
            return _;
        }
        return JSBI2.__truncateToNBits(i2, _);
      }
      static ADD(i2, _) {
        if (i2 = JSBI2.__toPrimitive(i2), _ = JSBI2.__toPrimitive(_), typeof i2 == "string")
          return typeof _ != "string" && (_ = _.toString()), i2 + _;
        if (typeof _ == "string")
          return i2.toString() + _;
        if (i2 = JSBI2.__toNumeric(i2), _ = JSBI2.__toNumeric(_), JSBI2.__isBigInt(i2) && JSBI2.__isBigInt(_))
          return JSBI2.add(i2, _);
        if (typeof i2 == "number" && typeof _ == "number")
          return i2 + _;
        throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
      }
      static LT(i2, _) {
        return JSBI2.__compare(i2, _, 0);
      }
      static LE(i2, _) {
        return JSBI2.__compare(i2, _, 1);
      }
      static GT(i2, _) {
        return JSBI2.__compare(i2, _, 2);
      }
      static GE(i2, _) {
        return JSBI2.__compare(i2, _, 3);
      }
      static EQ(i2, _) {
        for (; ; ) {
          if (JSBI2.__isBigInt(i2))
            return JSBI2.__isBigInt(_) ? JSBI2.equal(i2, _) : JSBI2.EQ(_, i2);
          if (typeof i2 == "number") {
            if (JSBI2.__isBigInt(_))
              return JSBI2.__equalToNumber(_, i2);
            if (typeof _ != "object")
              return i2 == _;
            _ = JSBI2.__toPrimitive(_);
          } else if (typeof i2 == "string") {
            if (JSBI2.__isBigInt(_))
              return i2 = JSBI2.__fromString(i2), i2 !== null && JSBI2.equal(i2, _);
            if (typeof _ != "object")
              return i2 == _;
            _ = JSBI2.__toPrimitive(_);
          } else if (typeof i2 == "boolean") {
            if (JSBI2.__isBigInt(_))
              return JSBI2.__equalToNumber(_, +i2);
            if (typeof _ != "object")
              return i2 == _;
            _ = JSBI2.__toPrimitive(_);
          } else if (typeof i2 == "symbol") {
            if (JSBI2.__isBigInt(_))
              return false;
            if (typeof _ != "object")
              return i2 == _;
            _ = JSBI2.__toPrimitive(_);
          } else if (typeof i2 == "object") {
            if (typeof _ == "object" && _.constructor !== JSBI2)
              return i2 == _;
            i2 = JSBI2.__toPrimitive(i2);
          } else
            return i2 == _;
        }
      }
      static NE(i2, _) {
        return !JSBI2.EQ(i2, _);
      }
      static DataViewGetBigInt64(i2, _, t2 = false) {
        return JSBI2.asIntN(64, JSBI2.DataViewGetBigUint64(i2, _, t2));
      }
      static DataViewGetBigUint64(i2, _, t2 = false) {
        const [e2, n] = t2 ? [4, 0] : [0, 4], g = i2.getUint32(_ + e2, t2), s3 = i2.getUint32(_ + n, t2), o = new JSBI2(3, false);
        return o.__setDigit(0, 1073741823 & s3), o.__setDigit(1, (268435455 & g) << 2 | s3 >>> 30), o.__setDigit(2, g >>> 28), o.__trim();
      }
      static DataViewSetBigInt64(i2, _, t2, e2 = false) {
        JSBI2.DataViewSetBigUint64(i2, _, t2, e2);
      }
      static DataViewSetBigUint64(i2, _, t2, e2 = false) {
        t2 = JSBI2.asUintN(64, t2);
        let n = 0, g = 0;
        if (0 < t2.length && (g = t2.__digit(0), 1 < t2.length)) {
          const i3 = t2.__digit(1);
          g |= i3 << 30, n = i3 >>> 2, 2 < t2.length && (n |= t2.__digit(2) << 28);
        }
        const [s3, o] = e2 ? [4, 0] : [0, 4];
        i2.setUint32(_ + s3, n, e2), i2.setUint32(_ + o, g, e2);
      }
      static __zero() {
        return new JSBI2(0, false);
      }
      static __oneDigit(i2, _) {
        const t2 = new JSBI2(1, _);
        return t2.__setDigit(0, i2), t2;
      }
      __copy() {
        const _ = new JSBI2(this.length, this.sign);
        for (let t2 = 0; t2 < this.length; t2++)
          _[t2] = this[t2];
        return _;
      }
      __trim() {
        let i2 = this.length, _ = this[i2 - 1];
        for (; _ === 0; )
          i2--, _ = this[i2 - 1], this.pop();
        return i2 === 0 && (this.sign = false), this;
      }
      __initializeDigits() {
        for (let _ = 0; _ < this.length; _++)
          this[_] = 0;
      }
      static __decideRounding(i2, _, t2, e2) {
        if (0 < _)
          return -1;
        let n;
        if (0 > _)
          n = -_ - 1;
        else {
          if (t2 === 0)
            return -1;
          t2--, e2 = i2.__digit(t2), n = 29;
        }
        let g = 1 << n;
        if ((e2 & g) == 0)
          return -1;
        if (g -= 1, (e2 & g) != 0)
          return 1;
        for (; 0 < t2; )
          if (t2--, i2.__digit(t2) !== 0)
            return 1;
        return 0;
      }
      static __fromDouble(i2) {
        JSBI2.__kBitConversionDouble[0] = i2;
        const _ = 2047 & JSBI2.__kBitConversionInts[1] >>> 20, t2 = _ - 1023, e2 = (0 | t2 / 30) + 1, n = new JSBI2(e2, 0 > i2);
        let g = 1048575 & JSBI2.__kBitConversionInts[1] | 1048576, s3 = JSBI2.__kBitConversionInts[0];
        const o = 20, l = t2 % 30;
        let r2, a = 0;
        if (l < 20) {
          const i3 = o - l;
          a = i3 + 32, r2 = g >>> i3, g = g << 32 - i3 | s3 >>> i3, s3 <<= 32 - i3;
        } else if (l === 20)
          a = 32, r2 = g, g = s3, s3 = 0;
        else {
          const i3 = l - o;
          a = 32 - i3, r2 = g << i3 | s3 >>> 32 - i3, g = s3 << i3, s3 = 0;
        }
        n.__setDigit(e2 - 1, r2);
        for (let _2 = e2 - 2; 0 <= _2; _2--)
          0 < a ? (a -= 30, r2 = g >>> 2, g = g << 30 | s3 >>> 2, s3 <<= 30) : r2 = 0, n.__setDigit(_2, r2);
        return n.__trim();
      }
      static __isWhitespace(i2) {
        return !!(13 >= i2 && 9 <= i2) || (159 >= i2 ? i2 == 32 : 131071 >= i2 ? i2 == 160 || i2 == 5760 : 196607 >= i2 ? (i2 &= 131071, 10 >= i2 || i2 == 40 || i2 == 41 || i2 == 47 || i2 == 95 || i2 == 4096) : i2 == 65279);
      }
      static __fromString(i2, _ = 0) {
        let t2 = 0;
        const e2 = i2.length;
        let n = 0;
        if (n === e2)
          return JSBI2.__zero();
        let g = i2.charCodeAt(n);
        for (; JSBI2.__isWhitespace(g); ) {
          if (++n === e2)
            return JSBI2.__zero();
          g = i2.charCodeAt(n);
        }
        if (g === 43) {
          if (++n === e2)
            return null;
          g = i2.charCodeAt(n), t2 = 1;
        } else if (g === 45) {
          if (++n === e2)
            return null;
          g = i2.charCodeAt(n), t2 = -1;
        }
        if (_ === 0) {
          if (_ = 10, g === 48) {
            if (++n === e2)
              return JSBI2.__zero();
            if (g = i2.charCodeAt(n), g === 88 || g === 120) {
              if (_ = 16, ++n === e2)
                return null;
              g = i2.charCodeAt(n);
            } else if (g === 79 || g === 111) {
              if (_ = 8, ++n === e2)
                return null;
              g = i2.charCodeAt(n);
            } else if (g === 66 || g === 98) {
              if (_ = 2, ++n === e2)
                return null;
              g = i2.charCodeAt(n);
            }
          }
        } else if (_ === 16 && g === 48) {
          if (++n === e2)
            return JSBI2.__zero();
          if (g = i2.charCodeAt(n), g === 88 || g === 120) {
            if (++n === e2)
              return null;
            g = i2.charCodeAt(n);
          }
        }
        if (t2 != 0 && _ !== 10)
          return null;
        for (; g === 48; ) {
          if (++n === e2)
            return JSBI2.__zero();
          g = i2.charCodeAt(n);
        }
        const s3 = e2 - n;
        let o = JSBI2.__kMaxBitsPerChar[_], l = JSBI2.__kBitsPerCharTableMultiplier - 1;
        if (s3 > 1073741824 / o)
          return null;
        const r2 = o * s3 + l >>> JSBI2.__kBitsPerCharTableShift, a = new JSBI2(0 | (r2 + 29) / 30, false), u = 10 > _ ? _ : 10, h2 = 10 < _ ? _ - 10 : 0;
        if ((_ & _ - 1) == 0) {
          o >>= JSBI2.__kBitsPerCharTableShift;
          const _2 = [], t3 = [];
          let s4 = false;
          do {
            let l2 = 0, r3 = 0;
            for (; ; ) {
              let _3;
              if (g - 48 >>> 0 < u)
                _3 = g - 48;
              else if ((32 | g) - 97 >>> 0 < h2)
                _3 = (32 | g) - 87;
              else {
                s4 = true;
                break;
              }
              if (r3 += o, l2 = l2 << o | _3, ++n === e2) {
                s4 = true;
                break;
              }
              if (g = i2.charCodeAt(n), 30 < r3 + o)
                break;
            }
            _2.push(l2), t3.push(r3);
          } while (!s4);
          JSBI2.__fillFromParts(a, _2, t3);
        } else {
          a.__initializeDigits();
          let t3 = false, s4 = 0;
          do {
            let r3 = 0, b = 1;
            for (; ; ) {
              let o2;
              if (g - 48 >>> 0 < u)
                o2 = g - 48;
              else if ((32 | g) - 97 >>> 0 < h2)
                o2 = (32 | g) - 87;
              else {
                t3 = true;
                break;
              }
              const l2 = b * _;
              if (1073741823 < l2)
                break;
              if (b = l2, r3 = r3 * _ + o2, s4++, ++n === e2) {
                t3 = true;
                break;
              }
              g = i2.charCodeAt(n);
            }
            l = 30 * JSBI2.__kBitsPerCharTableMultiplier - 1;
            const D = 0 | (o * s4 + l >>> JSBI2.__kBitsPerCharTableShift) / 30;
            a.__inplaceMultiplyAdd(b, r3, D);
          } while (!t3);
        }
        if (n !== e2) {
          if (!JSBI2.__isWhitespace(g))
            return null;
          for (n++; n < e2; n++)
            if (g = i2.charCodeAt(n), !JSBI2.__isWhitespace(g))
              return null;
        }
        return a.sign = t2 == -1, a.__trim();
      }
      static __fillFromParts(_, t2, e2) {
        let n = 0, g = 0, s3 = 0;
        for (let o = t2.length - 1; 0 <= o; o--) {
          const i2 = t2[o], l = e2[o];
          g |= i2 << s3, s3 += l, s3 === 30 ? (_.__setDigit(n++, g), s3 = 0, g = 0) : 30 < s3 && (_.__setDigit(n++, 1073741823 & g), s3 -= 30, g = i2 >>> l - s3);
        }
        if (g !== 0) {
          if (n >= _.length)
            throw new Error("implementation bug");
          _.__setDigit(n++, g);
        }
        for (; n < _.length; n++)
          _.__setDigit(n, 0);
      }
      static __toStringBasePowerOfTwo(_, i2) {
        const t2 = _.length;
        let e2 = i2 - 1;
        e2 = (85 & e2 >>> 1) + (85 & e2), e2 = (51 & e2 >>> 2) + (51 & e2), e2 = (15 & e2 >>> 4) + (15 & e2);
        const n = e2, g = i2 - 1, s3 = _.__digit(t2 - 1), o = JSBI2.__clz30(s3);
        let l = 0 | (30 * t2 - o + n - 1) / n;
        if (_.sign && l++, 268435456 < l)
          throw new Error("string too long");
        const r2 = Array(l);
        let a = l - 1, u = 0, d = 0;
        for (let e3 = 0; e3 < t2 - 1; e3++) {
          const i3 = _.__digit(e3), t3 = (u | i3 << d) & g;
          r2[a--] = JSBI2.__kConversionChars[t3];
          const s4 = n - d;
          for (u = i3 >>> s4, d = 30 - s4; d >= n; )
            r2[a--] = JSBI2.__kConversionChars[u & g], u >>>= n, d -= n;
        }
        const h2 = (u | s3 << d) & g;
        for (r2[a--] = JSBI2.__kConversionChars[h2], u = s3 >>> n - d; u !== 0; )
          r2[a--] = JSBI2.__kConversionChars[u & g], u >>>= n;
        if (_.sign && (r2[a--] = "-"), a != -1)
          throw new Error("implementation bug");
        return r2.join("");
      }
      static __toStringGeneric(_, i2, t2) {
        const e2 = _.length;
        if (e2 === 0)
          return "";
        if (e2 === 1) {
          let e3 = _.__unsignedDigit(0).toString(i2);
          return t2 === false && _.sign && (e3 = "-" + e3), e3;
        }
        const n = 30 * e2 - JSBI2.__clz30(_.__digit(e2 - 1)), g = JSBI2.__kMaxBitsPerChar[i2], s3 = g - 1;
        let o = n * JSBI2.__kBitsPerCharTableMultiplier;
        o += s3 - 1, o = 0 | o / s3;
        const l = o + 1 >> 1, r2 = JSBI2.exponentiate(JSBI2.__oneDigit(i2, false), JSBI2.__oneDigit(l, false));
        let a, u;
        const d = r2.__unsignedDigit(0);
        if (r2.length === 1 && 32767 >= d) {
          a = new JSBI2(_.length, false), a.__initializeDigits();
          let t3 = 0;
          for (let e3 = 2 * _.length - 1; 0 <= e3; e3--) {
            const i3 = t3 << 15 | _.__halfDigit(e3);
            a.__setHalfDigit(e3, 0 | i3 / d), t3 = 0 | i3 % d;
          }
          u = t3.toString(i2);
        } else {
          const t3 = JSBI2.__absoluteDivLarge(_, r2, true, true);
          a = t3.quotient;
          const e3 = t3.remainder.__trim();
          u = JSBI2.__toStringGeneric(e3, i2, true);
        }
        a.__trim();
        let h2 = JSBI2.__toStringGeneric(a, i2, true);
        for (; u.length < l; )
          u = "0" + u;
        return t2 === false && _.sign && (h2 = "-" + h2), h2 + u;
      }
      static __unequalSign(i2) {
        return i2 ? -1 : 1;
      }
      static __absoluteGreater(i2) {
        return i2 ? -1 : 1;
      }
      static __absoluteLess(i2) {
        return i2 ? 1 : -1;
      }
      static __compareToBigInt(i2, _) {
        const t2 = i2.sign;
        if (t2 !== _.sign)
          return JSBI2.__unequalSign(t2);
        const e2 = JSBI2.__absoluteCompare(i2, _);
        return 0 < e2 ? JSBI2.__absoluteGreater(t2) : 0 > e2 ? JSBI2.__absoluteLess(t2) : 0;
      }
      static __compareToNumber(i2, _) {
        if (JSBI2.__isOneDigitInt(_)) {
          const t2 = i2.sign, e2 = 0 > _;
          if (t2 !== e2)
            return JSBI2.__unequalSign(t2);
          if (i2.length === 0) {
            if (e2)
              throw new Error("implementation bug");
            return _ === 0 ? 0 : -1;
          }
          if (1 < i2.length)
            return JSBI2.__absoluteGreater(t2);
          const n = Math.abs(_), g = i2.__unsignedDigit(0);
          return g > n ? JSBI2.__absoluteGreater(t2) : g < n ? JSBI2.__absoluteLess(t2) : 0;
        }
        return JSBI2.__compareToDouble(i2, _);
      }
      static __compareToDouble(i2, _) {
        if (_ !== _)
          return _;
        if (_ === 1 / 0)
          return -1;
        if (_ === -Infinity)
          return 1;
        const t2 = i2.sign;
        if (t2 !== 0 > _)
          return JSBI2.__unequalSign(t2);
        if (_ === 0)
          throw new Error("implementation bug: should be handled elsewhere");
        if (i2.length === 0)
          return -1;
        JSBI2.__kBitConversionDouble[0] = _;
        const e2 = 2047 & JSBI2.__kBitConversionInts[1] >>> 20;
        if (e2 == 2047)
          throw new Error("implementation bug: handled elsewhere");
        const n = e2 - 1023;
        if (0 > n)
          return JSBI2.__absoluteGreater(t2);
        const g = i2.length;
        let s3 = i2.__digit(g - 1);
        const o = JSBI2.__clz30(s3), l = 30 * g - o, r2 = n + 1;
        if (l < r2)
          return JSBI2.__absoluteLess(t2);
        if (l > r2)
          return JSBI2.__absoluteGreater(t2);
        let a = 1048576 | 1048575 & JSBI2.__kBitConversionInts[1], u = JSBI2.__kBitConversionInts[0];
        const d = 20, h2 = 29 - o;
        if (h2 !== (0 | (l - 1) % 30))
          throw new Error("implementation bug");
        let m2, b = 0;
        if (20 > h2) {
          const i3 = d - h2;
          b = i3 + 32, m2 = a >>> i3, a = a << 32 - i3 | u >>> i3, u <<= 32 - i3;
        } else if (h2 === 20)
          b = 32, m2 = a, a = u, u = 0;
        else {
          const i3 = h2 - d;
          b = 32 - i3, m2 = a << i3 | u >>> 32 - i3, a = u << i3, u = 0;
        }
        if (s3 >>>= 0, m2 >>>= 0, s3 > m2)
          return JSBI2.__absoluteGreater(t2);
        if (s3 < m2)
          return JSBI2.__absoluteLess(t2);
        for (let e3 = g - 2; 0 <= e3; e3--) {
          0 < b ? (b -= 30, m2 = a >>> 2, a = a << 30 | u >>> 2, u <<= 30) : m2 = 0;
          const _2 = i2.__unsignedDigit(e3);
          if (_2 > m2)
            return JSBI2.__absoluteGreater(t2);
          if (_2 < m2)
            return JSBI2.__absoluteLess(t2);
        }
        if (a !== 0 || u !== 0) {
          if (b === 0)
            throw new Error("implementation bug");
          return JSBI2.__absoluteLess(t2);
        }
        return 0;
      }
      static __equalToNumber(i2, _) {
        var t2 = Math.abs;
        return JSBI2.__isOneDigitInt(_) ? _ === 0 ? i2.length === 0 : i2.length === 1 && i2.sign === 0 > _ && i2.__unsignedDigit(0) === t2(_) : JSBI2.__compareToDouble(i2, _) === 0;
      }
      static __comparisonResultToBool(i2, _) {
        return _ === 0 ? 0 > i2 : _ === 1 ? 0 >= i2 : _ === 2 ? 0 < i2 : _ === 3 ? 0 <= i2 : void 0;
      }
      static __compare(i2, _, t2) {
        if (i2 = JSBI2.__toPrimitive(i2), _ = JSBI2.__toPrimitive(_), typeof i2 == "string" && typeof _ == "string")
          switch (t2) {
            case 0:
              return i2 < _;
            case 1:
              return i2 <= _;
            case 2:
              return i2 > _;
            case 3:
              return i2 >= _;
          }
        if (JSBI2.__isBigInt(i2) && typeof _ == "string")
          return _ = JSBI2.__fromString(_), _ !== null && JSBI2.__comparisonResultToBool(JSBI2.__compareToBigInt(i2, _), t2);
        if (typeof i2 == "string" && JSBI2.__isBigInt(_))
          return i2 = JSBI2.__fromString(i2), i2 !== null && JSBI2.__comparisonResultToBool(JSBI2.__compareToBigInt(i2, _), t2);
        if (i2 = JSBI2.__toNumeric(i2), _ = JSBI2.__toNumeric(_), JSBI2.__isBigInt(i2)) {
          if (JSBI2.__isBigInt(_))
            return JSBI2.__comparisonResultToBool(JSBI2.__compareToBigInt(i2, _), t2);
          if (typeof _ != "number")
            throw new Error("implementation bug");
          return JSBI2.__comparisonResultToBool(JSBI2.__compareToNumber(i2, _), t2);
        }
        if (typeof i2 != "number")
          throw new Error("implementation bug");
        if (JSBI2.__isBigInt(_))
          return JSBI2.__comparisonResultToBool(JSBI2.__compareToNumber(_, i2), 2 ^ t2);
        if (typeof _ != "number")
          throw new Error("implementation bug");
        return t2 === 0 ? i2 < _ : t2 === 1 ? i2 <= _ : t2 === 2 ? i2 > _ : t2 === 3 ? i2 >= _ : void 0;
      }
      __clzmsd() {
        return JSBI2.__clz30(this.__digit(this.length - 1));
      }
      static __absoluteAdd(_, t2, e2) {
        if (_.length < t2.length)
          return JSBI2.__absoluteAdd(t2, _, e2);
        if (_.length === 0)
          return _;
        if (t2.length === 0)
          return _.sign === e2 ? _ : JSBI2.unaryMinus(_);
        let n = _.length;
        (_.__clzmsd() === 0 || t2.length === _.length && t2.__clzmsd() === 0) && n++;
        const g = new JSBI2(n, e2);
        let s3 = 0, o = 0;
        for (; o < t2.length; o++) {
          const i2 = _.__digit(o) + t2.__digit(o) + s3;
          s3 = i2 >>> 30, g.__setDigit(o, 1073741823 & i2);
        }
        for (; o < _.length; o++) {
          const i2 = _.__digit(o) + s3;
          s3 = i2 >>> 30, g.__setDigit(o, 1073741823 & i2);
        }
        return o < g.length && g.__setDigit(o, s3), g.__trim();
      }
      static __absoluteSub(_, t2, e2) {
        if (_.length === 0)
          return _;
        if (t2.length === 0)
          return _.sign === e2 ? _ : JSBI2.unaryMinus(_);
        const n = new JSBI2(_.length, e2);
        let g = 0, s3 = 0;
        for (; s3 < t2.length; s3++) {
          const i2 = _.__digit(s3) - t2.__digit(s3) - g;
          g = 1 & i2 >>> 30, n.__setDigit(s3, 1073741823 & i2);
        }
        for (; s3 < _.length; s3++) {
          const i2 = _.__digit(s3) - g;
          g = 1 & i2 >>> 30, n.__setDigit(s3, 1073741823 & i2);
        }
        return n.__trim();
      }
      static __absoluteAddOne(_, i2, t2 = null) {
        const e2 = _.length;
        t2 === null ? t2 = new JSBI2(e2, i2) : t2.sign = i2;
        let n = 1;
        for (let g = 0; g < e2; g++) {
          const i3 = _.__digit(g) + n;
          n = i3 >>> 30, t2.__setDigit(g, 1073741823 & i3);
        }
        return n != 0 && t2.__setDigitGrow(e2, 1), t2;
      }
      static __absoluteSubOne(_, t2) {
        const e2 = _.length;
        t2 = t2 || e2;
        const n = new JSBI2(t2, false);
        let g = 1;
        for (let s3 = 0; s3 < e2; s3++) {
          const i2 = _.__digit(s3) - g;
          g = 1 & i2 >>> 30, n.__setDigit(s3, 1073741823 & i2);
        }
        if (g != 0)
          throw new Error("implementation bug");
        for (let g2 = e2; g2 < t2; g2++)
          n.__setDigit(g2, 0);
        return n;
      }
      static __absoluteAnd(_, t2, e2 = null) {
        let n = _.length, g = t2.length, s3 = g;
        if (n < g) {
          s3 = n;
          const i2 = _, e3 = n;
          _ = t2, n = g, t2 = i2, g = e3;
        }
        let o = s3;
        e2 === null ? e2 = new JSBI2(o, false) : o = e2.length;
        let l = 0;
        for (; l < s3; l++)
          e2.__setDigit(l, _.__digit(l) & t2.__digit(l));
        for (; l < o; l++)
          e2.__setDigit(l, 0);
        return e2;
      }
      static __absoluteAndNot(_, t2, e2 = null) {
        const n = _.length, g = t2.length;
        let s3 = g;
        n < g && (s3 = n);
        let o = n;
        e2 === null ? e2 = new JSBI2(o, false) : o = e2.length;
        let l = 0;
        for (; l < s3; l++)
          e2.__setDigit(l, _.__digit(l) & ~t2.__digit(l));
        for (; l < n; l++)
          e2.__setDigit(l, _.__digit(l));
        for (; l < o; l++)
          e2.__setDigit(l, 0);
        return e2;
      }
      static __absoluteOr(_, t2, e2 = null) {
        let n = _.length, g = t2.length, s3 = g;
        if (n < g) {
          s3 = n;
          const i2 = _, e3 = n;
          _ = t2, n = g, t2 = i2, g = e3;
        }
        let o = n;
        e2 === null ? e2 = new JSBI2(o, false) : o = e2.length;
        let l = 0;
        for (; l < s3; l++)
          e2.__setDigit(l, _.__digit(l) | t2.__digit(l));
        for (; l < n; l++)
          e2.__setDigit(l, _.__digit(l));
        for (; l < o; l++)
          e2.__setDigit(l, 0);
        return e2;
      }
      static __absoluteXor(_, t2, e2 = null) {
        let n = _.length, g = t2.length, s3 = g;
        if (n < g) {
          s3 = n;
          const i2 = _, e3 = n;
          _ = t2, n = g, t2 = i2, g = e3;
        }
        let o = n;
        e2 === null ? e2 = new JSBI2(o, false) : o = e2.length;
        let l = 0;
        for (; l < s3; l++)
          e2.__setDigit(l, _.__digit(l) ^ t2.__digit(l));
        for (; l < n; l++)
          e2.__setDigit(l, _.__digit(l));
        for (; l < o; l++)
          e2.__setDigit(l, 0);
        return e2;
      }
      static __absoluteCompare(_, t2) {
        const e2 = _.length - t2.length;
        if (e2 != 0)
          return e2;
        let n = _.length - 1;
        for (; 0 <= n && _.__digit(n) === t2.__digit(n); )
          n--;
        return 0 > n ? 0 : _.__unsignedDigit(n) > t2.__unsignedDigit(n) ? 1 : -1;
      }
      static __multiplyAccumulate(_, t2, e2, n) {
        if (t2 === 0)
          return;
        const g = 32767 & t2, s3 = t2 >>> 15;
        let o = 0, l = 0;
        for (let r2, a = 0; a < _.length; a++, n++) {
          r2 = e2.__digit(n);
          const i2 = _.__digit(a), t3 = 32767 & i2, u = i2 >>> 15, d = JSBI2.__imul(t3, g), h2 = JSBI2.__imul(t3, s3), m2 = JSBI2.__imul(u, g), b = JSBI2.__imul(u, s3);
          r2 += l + d + o, o = r2 >>> 30, r2 &= 1073741823, r2 += ((32767 & h2) << 15) + ((32767 & m2) << 15), o += r2 >>> 30, l = b + (h2 >>> 15) + (m2 >>> 15), e2.__setDigit(n, 1073741823 & r2);
        }
        for (; o != 0 || l !== 0; n++) {
          let i2 = e2.__digit(n);
          i2 += o + l, l = 0, o = i2 >>> 30, e2.__setDigit(n, 1073741823 & i2);
        }
      }
      static __internalMultiplyAdd(_, t2, e2, g, s3) {
        let o = e2, l = 0;
        for (let n = 0; n < g; n++) {
          const i2 = _.__digit(n), e3 = JSBI2.__imul(32767 & i2, t2), g2 = JSBI2.__imul(i2 >>> 15, t2), a = e3 + ((32767 & g2) << 15) + l + o;
          o = a >>> 30, l = g2 >>> 15, s3.__setDigit(n, 1073741823 & a);
        }
        if (s3.length > g)
          for (s3.__setDigit(g++, o + l); g < s3.length; )
            s3.__setDigit(g++, 0);
        else if (o + l !== 0)
          throw new Error("implementation bug");
      }
      __inplaceMultiplyAdd(i2, _, t2) {
        t2 > this.length && (t2 = this.length);
        const e2 = 32767 & i2, n = i2 >>> 15;
        let g = 0, s3 = _;
        for (let o = 0; o < t2; o++) {
          const i3 = this.__digit(o), _2 = 32767 & i3, t3 = i3 >>> 15, l = JSBI2.__imul(_2, e2), r2 = JSBI2.__imul(_2, n), a = JSBI2.__imul(t3, e2), u = JSBI2.__imul(t3, n);
          let d = s3 + l + g;
          g = d >>> 30, d &= 1073741823, d += ((32767 & r2) << 15) + ((32767 & a) << 15), g += d >>> 30, s3 = u + (r2 >>> 15) + (a >>> 15), this.__setDigit(o, 1073741823 & d);
        }
        if (g != 0 || s3 !== 0)
          throw new Error("implementation bug");
      }
      static __absoluteDivSmall(_, t2, e2 = null) {
        e2 === null && (e2 = new JSBI2(_.length, false));
        let n = 0;
        for (let g, s3 = 2 * _.length - 1; 0 <= s3; s3 -= 2) {
          g = (n << 15 | _.__halfDigit(s3)) >>> 0;
          const i2 = 0 | g / t2;
          n = 0 | g % t2, g = (n << 15 | _.__halfDigit(s3 - 1)) >>> 0;
          const o = 0 | g / t2;
          n = 0 | g % t2, e2.__setDigit(s3 >>> 1, i2 << 15 | o);
        }
        return e2;
      }
      static __absoluteModSmall(_, t2) {
        let e2 = 0;
        for (let n = 2 * _.length - 1; 0 <= n; n--) {
          const i2 = (e2 << 15 | _.__halfDigit(n)) >>> 0;
          e2 = 0 | i2 % t2;
        }
        return e2;
      }
      static __absoluteDivLarge(i2, _, t2, e2) {
        const g = _.__halfDigitLength(), n = _.length, s3 = i2.__halfDigitLength() - g;
        let o = null;
        t2 && (o = new JSBI2(s3 + 2 >>> 1, false), o.__initializeDigits());
        const l = new JSBI2(g + 2 >>> 1, false);
        l.__initializeDigits();
        const r2 = JSBI2.__clz15(_.__halfDigit(g - 1));
        0 < r2 && (_ = JSBI2.__specialLeftShift(_, r2, 0));
        const a = JSBI2.__specialLeftShift(i2, r2, 1), u = _.__halfDigit(g - 1);
        let d = 0;
        for (let r3, h2 = s3; 0 <= h2; h2--) {
          r3 = 32767;
          const i3 = a.__halfDigit(h2 + g);
          if (i3 !== u) {
            const t3 = (i3 << 15 | a.__halfDigit(h2 + g - 1)) >>> 0;
            r3 = 0 | t3 / u;
            let e4 = 0 | t3 % u;
            const n2 = _.__halfDigit(g - 2), s4 = a.__halfDigit(h2 + g - 2);
            for (; JSBI2.__imul(r3, n2) >>> 0 > (e4 << 16 | s4) >>> 0 && (r3--, e4 += u, !(32767 < e4)); )
              ;
          }
          JSBI2.__internalMultiplyAdd(_, r3, 0, n, l);
          let e3 = a.__inplaceSub(l, h2, g + 1);
          e3 !== 0 && (e3 = a.__inplaceAdd(_, h2, g), a.__setHalfDigit(h2 + g, 32767 & a.__halfDigit(h2 + g) + e3), r3--), t2 && (1 & h2 ? d = r3 << 15 : o.__setDigit(h2 >>> 1, d | r3));
        }
        if (e2)
          return a.__inplaceRightShift(r2), t2 ? { quotient: o, remainder: a } : a;
        if (t2)
          return o;
        throw new Error("unreachable");
      }
      static __clz15(i2) {
        return JSBI2.__clz30(i2) - 15;
      }
      __inplaceAdd(_, t2, e2) {
        let n = 0;
        for (let g = 0; g < e2; g++) {
          const i2 = this.__halfDigit(t2 + g) + _.__halfDigit(g) + n;
          n = i2 >>> 15, this.__setHalfDigit(t2 + g, 32767 & i2);
        }
        return n;
      }
      __inplaceSub(_, t2, e2) {
        let n = 0;
        if (1 & t2) {
          t2 >>= 1;
          let g = this.__digit(t2), s3 = 32767 & g, o = 0;
          for (; o < e2 - 1 >>> 1; o++) {
            const i3 = _.__digit(o), e3 = (g >>> 15) - (32767 & i3) - n;
            n = 1 & e3 >>> 15, this.__setDigit(t2 + o, (32767 & e3) << 15 | 32767 & s3), g = this.__digit(t2 + o + 1), s3 = (32767 & g) - (i3 >>> 15) - n, n = 1 & s3 >>> 15;
          }
          const i2 = _.__digit(o), l = (g >>> 15) - (32767 & i2) - n;
          n = 1 & l >>> 15, this.__setDigit(t2 + o, (32767 & l) << 15 | 32767 & s3);
          if (t2 + o + 1 >= this.length)
            throw new RangeError("out of bounds");
          (1 & e2) == 0 && (g = this.__digit(t2 + o + 1), s3 = (32767 & g) - (i2 >>> 15) - n, n = 1 & s3 >>> 15, this.__setDigit(t2 + _.length, 1073709056 & g | 32767 & s3));
        } else {
          t2 >>= 1;
          let g = 0;
          for (; g < _.length - 1; g++) {
            const i3 = this.__digit(t2 + g), e3 = _.__digit(g), s4 = (32767 & i3) - (32767 & e3) - n;
            n = 1 & s4 >>> 15;
            const o2 = (i3 >>> 15) - (e3 >>> 15) - n;
            n = 1 & o2 >>> 15, this.__setDigit(t2 + g, (32767 & o2) << 15 | 32767 & s4);
          }
          const i2 = this.__digit(t2 + g), s3 = _.__digit(g), o = (32767 & i2) - (32767 & s3) - n;
          n = 1 & o >>> 15;
          let l = 0;
          (1 & e2) == 0 && (l = (i2 >>> 15) - (s3 >>> 15) - n, n = 1 & l >>> 15), this.__setDigit(t2 + g, (32767 & l) << 15 | 32767 & o);
        }
        return n;
      }
      __inplaceRightShift(_) {
        if (_ === 0)
          return;
        let t2 = this.__digit(0) >>> _;
        const e2 = this.length - 1;
        for (let n = 0; n < e2; n++) {
          const i2 = this.__digit(n + 1);
          this.__setDigit(n, 1073741823 & i2 << 30 - _ | t2), t2 = i2 >>> _;
        }
        this.__setDigit(e2, t2);
      }
      static __specialLeftShift(_, t2, e2) {
        const g = _.length, n = new JSBI2(g + e2, false);
        if (t2 === 0) {
          for (let t3 = 0; t3 < g; t3++)
            n.__setDigit(t3, _.__digit(t3));
          return 0 < e2 && n.__setDigit(g, 0), n;
        }
        let s3 = 0;
        for (let o = 0; o < g; o++) {
          const i2 = _.__digit(o);
          n.__setDigit(o, 1073741823 & i2 << t2 | s3), s3 = i2 >>> 30 - t2;
        }
        return 0 < e2 && n.__setDigit(g, s3), n;
      }
      static __leftShiftByAbsolute(_, i2) {
        const t2 = JSBI2.__toShiftAmount(i2);
        if (0 > t2)
          throw new RangeError("BigInt too big");
        const e2 = 0 | t2 / 30, n = t2 % 30, g = _.length, s3 = n !== 0 && _.__digit(g - 1) >>> 30 - n != 0, o = g + e2 + (s3 ? 1 : 0), l = new JSBI2(o, _.sign);
        if (n === 0) {
          let t3 = 0;
          for (; t3 < e2; t3++)
            l.__setDigit(t3, 0);
          for (; t3 < o; t3++)
            l.__setDigit(t3, _.__digit(t3 - e2));
        } else {
          let t3 = 0;
          for (let _2 = 0; _2 < e2; _2++)
            l.__setDigit(_2, 0);
          for (let s4 = 0; s4 < g; s4++) {
            const i3 = _.__digit(s4);
            l.__setDigit(s4 + e2, 1073741823 & i3 << n | t3), t3 = i3 >>> 30 - n;
          }
          if (s3)
            l.__setDigit(g + e2, t3);
          else if (t3 !== 0)
            throw new Error("implementation bug");
        }
        return l.__trim();
      }
      static __rightShiftByAbsolute(_, i2) {
        const t2 = _.length, e2 = _.sign, n = JSBI2.__toShiftAmount(i2);
        if (0 > n)
          return JSBI2.__rightShiftByMaximum(e2);
        const g = 0 | n / 30, s3 = n % 30;
        let o = t2 - g;
        if (0 >= o)
          return JSBI2.__rightShiftByMaximum(e2);
        let l = false;
        if (e2) {
          if ((_.__digit(g) & (1 << s3) - 1) != 0)
            l = true;
          else
            for (let t3 = 0; t3 < g; t3++)
              if (_.__digit(t3) !== 0) {
                l = true;
                break;
              }
        }
        if (l && s3 === 0) {
          const i3 = _.__digit(t2 - 1);
          ~i3 == 0 && o++;
        }
        let r2 = new JSBI2(o, e2);
        if (s3 === 0) {
          r2.__setDigit(o - 1, 0);
          for (let e3 = g; e3 < t2; e3++)
            r2.__setDigit(e3 - g, _.__digit(e3));
        } else {
          let e3 = _.__digit(g) >>> s3;
          const n2 = t2 - g - 1;
          for (let t3 = 0; t3 < n2; t3++) {
            const i3 = _.__digit(t3 + g + 1);
            r2.__setDigit(t3, 1073741823 & i3 << 30 - s3 | e3), e3 = i3 >>> s3;
          }
          r2.__setDigit(n2, e3);
        }
        return l && (r2 = JSBI2.__absoluteAddOne(r2, true, r2)), r2.__trim();
      }
      static __rightShiftByMaximum(i2) {
        return i2 ? JSBI2.__oneDigit(1, true) : JSBI2.__zero();
      }
      static __toShiftAmount(i2) {
        if (1 < i2.length)
          return -1;
        const _ = i2.__unsignedDigit(0);
        return _ > JSBI2.__kMaxLengthBits ? -1 : _;
      }
      static __toPrimitive(i2, _ = "default") {
        if (typeof i2 != "object")
          return i2;
        if (i2.constructor === JSBI2)
          return i2;
        if (typeof Symbol != "undefined" && typeof Symbol.toPrimitive == "symbol") {
          const t3 = i2[Symbol.toPrimitive];
          if (t3) {
            const i3 = t3(_);
            if (typeof i3 != "object")
              return i3;
            throw new TypeError("Cannot convert object to primitive value");
          }
        }
        const t2 = i2.valueOf;
        if (t2) {
          const _2 = t2.call(i2);
          if (typeof _2 != "object")
            return _2;
        }
        const e2 = i2.toString;
        if (e2) {
          const _2 = e2.call(i2);
          if (typeof _2 != "object")
            return _2;
        }
        throw new TypeError("Cannot convert object to primitive value");
      }
      static __toNumeric(i2) {
        return JSBI2.__isBigInt(i2) ? i2 : +i2;
      }
      static __isBigInt(i2) {
        return typeof i2 == "object" && i2 !== null && i2.constructor === JSBI2;
      }
      static __truncateToNBits(i2, _) {
        const t2 = 0 | (i2 + 29) / 30, e2 = new JSBI2(t2, _.sign), n = t2 - 1;
        for (let t3 = 0; t3 < n; t3++)
          e2.__setDigit(t3, _.__digit(t3));
        let g = _.__digit(n);
        if (i2 % 30 != 0) {
          const _2 = 32 - i2 % 30;
          g = g << _2 >>> _2;
        }
        return e2.__setDigit(n, g), e2.__trim();
      }
      static __truncateAndSubFromPowerOfTwo(_, t2, e2) {
        var n = Math.min;
        const g = 0 | (_ + 29) / 30, s3 = new JSBI2(g, e2);
        let o = 0;
        const l = g - 1;
        let a = 0;
        for (const i2 = n(l, t2.length); o < i2; o++) {
          const i3 = 0 - t2.__digit(o) - a;
          a = 1 & i3 >>> 30, s3.__setDigit(o, 1073741823 & i3);
        }
        for (; o < l; o++)
          s3.__setDigit(o, 0 | 1073741823 & -a);
        let u = l < t2.length ? t2.__digit(l) : 0;
        const d = _ % 30;
        let h2;
        if (d == 0)
          h2 = 0 - u - a, h2 &= 1073741823;
        else {
          const i2 = 32 - d;
          u = u << i2 >>> i2;
          const _2 = 1 << 32 - i2;
          h2 = _2 - u - a, h2 &= _2 - 1;
        }
        return s3.__setDigit(l, h2), s3.__trim();
      }
      __digit(_) {
        return this[_];
      }
      __unsignedDigit(_) {
        return this[_] >>> 0;
      }
      __setDigit(_, i2) {
        this[_] = 0 | i2;
      }
      __setDigitGrow(_, i2) {
        this[_] = 0 | i2;
      }
      __halfDigitLength() {
        const i2 = this.length;
        return 32767 >= this.__unsignedDigit(i2 - 1) ? 2 * i2 - 1 : 2 * i2;
      }
      __halfDigit(_) {
        return 32767 & this[_ >>> 1] >>> 15 * (1 & _);
      }
      __setHalfDigit(_, i2) {
        const t2 = _ >>> 1, e2 = this.__digit(t2), n = 1 & _ ? 32767 & e2 | i2 << 15 : 1073709056 & e2 | 32767 & i2;
        this.__setDigit(t2, n);
      }
      static __digitPow(i2, _) {
        let t2 = 1;
        for (; 0 < _; )
          1 & _ && (t2 *= i2), _ >>>= 1, i2 *= i2;
        return t2;
      }
      static __isOneDigitInt(i2) {
        return (1073741823 & i2) === i2;
      }
    };
    JSBI2.__kMaxLength = 33554432, JSBI2.__kMaxLengthBits = JSBI2.__kMaxLength << 5, JSBI2.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], JSBI2.__kBitsPerCharTableShift = 5, JSBI2.__kBitsPerCharTableMultiplier = 1 << JSBI2.__kBitsPerCharTableShift, JSBI2.__kConversionChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], JSBI2.__kBitConversionBuffer = new ArrayBuffer(8), JSBI2.__kBitConversionDouble = new Float64Array(JSBI2.__kBitConversionBuffer), JSBI2.__kBitConversionInts = new Int32Array(JSBI2.__kBitConversionBuffer), JSBI2.__clz30 = Math.clz32 ? function(i2) {
      return Math.clz32(i2) - 2;
    } : function(i2) {
      return i2 === 0 ? 30 : 0 | 29 - (0 | Math.log(i2 >>> 0) / Math.LN2);
    }, JSBI2.__imul = Math.imul || function(i2, _) {
      return 0 | i2 * _;
    }, module2.exports = JSBI2;
  }
});

// node_modules/@js-temporal/polyfill/dist/index.esm.js
function defaultUtilInspectFormatter(depth, options) {
  return options.stylize(`${this[Symbol.toStringTag]} <${this}>`, "special");
}
function MakeIntrinsicClass(Class, name) {
  Object.defineProperty(Class.prototype, Symbol.toStringTag, {
    value: name,
    writable: false,
    enumerable: false,
    configurable: true
  });
  {
    Object.defineProperty(Class.prototype, Symbol.for("nodejs.util.inspect.custom"), {
      value: customUtilInspectFormatters[name] || defaultUtilInspectFormatter,
      writable: false,
      enumerable: false,
      configurable: true
    });
  }
  for (const prop of Object.getOwnPropertyNames(Class)) {
    const desc = Object.getOwnPropertyDescriptor(Class, prop);
    if (!desc.configurable || !desc.enumerable)
      continue;
    desc.enumerable = false;
    Object.defineProperty(Class, prop, desc);
  }
  for (const prop of Object.getOwnPropertyNames(Class.prototype)) {
    const desc = Object.getOwnPropertyDescriptor(Class.prototype, prop);
    if (!desc.configurable || !desc.enumerable)
      continue;
    desc.enumerable = false;
    Object.defineProperty(Class.prototype, prop, desc);
  }
  DefineIntrinsic(name, Class);
  DefineIntrinsic(`${name}.prototype`, Class.prototype);
}
function DefineIntrinsic(name, value) {
  const key2 = `%${name}%`;
  if (INTRINSICS[key2] !== void 0)
    throw new Error(`intrinsic ${name} already exists`);
  INTRINSICS[key2] = value;
}
function GetIntrinsic(intrinsic) {
  return INTRINSICS[intrinsic];
}
function CreateSlots(container) {
  slots.set(container, /* @__PURE__ */ Object.create(null));
}
function GetSlots(container) {
  return slots.get(container);
}
function HasSlot(container, ...ids) {
  if (!container || typeof container !== "object")
    return false;
  const myslots = GetSlots(container);
  return !!myslots && ids.reduce((all, id) => all && id in myslots, true);
}
function GetSlot(container, id) {
  const value = GetSlots(container)[id];
  if (value === void 0)
    throw new TypeError(`Missing internal slot ${id}`);
  return value;
}
function SetSlot(container, id, value) {
  GetSlots(container)[id] = value;
}
function monthCodeNumberPart(monthCode) {
  if (!monthCode.startsWith("M")) {
    throw new RangeError(`Invalid month code: ${monthCode}.  Month codes must start with M.`);
  }
  const month = +monthCode.slice(1);
  if (isNaN(month))
    throw new RangeError(`Invalid month code: ${monthCode}`);
  return month;
}
function buildMonthCode(month, leap = false) {
  return `M${month.toString().padStart(2, "0")}${leap ? "L" : ""}`;
}
function resolveNonLunisolarMonth(calendarDate, overflow = void 0, monthsPerYear = 12) {
  let { month, monthCode } = calendarDate;
  if (monthCode === void 0) {
    if (month === void 0)
      throw new TypeError("Either month or monthCode are required");
    if (overflow === "reject")
      RejectToRange(month, 1, monthsPerYear);
    if (overflow === "constrain")
      month = ConstrainToRange(month, 1, monthsPerYear);
    monthCode = buildMonthCode(month);
  } else {
    const numberPart = monthCodeNumberPart(monthCode);
    if (month !== void 0 && month !== numberPart) {
      throw new RangeError(`monthCode ${monthCode} and month ${month} must match if both are present`);
    }
    if (monthCode !== buildMonthCode(numberPart)) {
      throw new RangeError(`Invalid month code: ${monthCode}`);
    }
    month = numberPart;
    if (month < 1 || month > monthsPerYear)
      throw new RangeError(`Invalid monthCode: ${monthCode}`);
  }
  return __spreadProps(__spreadValues({}, calendarDate), { month, monthCode });
}
function toUtcIsoDateString({ isoYear, isoMonth, isoDay }) {
  const yearString = ISOYearString(isoYear);
  const monthString = ISODateTimePartString(isoMonth);
  const dayString = ISODateTimePartString(isoDay);
  return `${yearString}-${monthString}-${dayString}T00:00Z`;
}
function simpleDateDiff(one, two) {
  return {
    years: one.year - two.year,
    months: one.month - two.month,
    days: one.day - two.day
  };
}
function adjustEras(erasParam) {
  let eras = erasParam;
  if (eras.length === 0) {
    throw new RangeError("Invalid era data: eras are required");
  }
  if (eras.length === 1 && eras[0].reverseOf) {
    throw new RangeError("Invalid era data: anchor era cannot count years backwards");
  }
  if (eras.length === 1 && !eras[0].name) {
    throw new RangeError("Invalid era data: at least one named era is required");
  }
  if (eras.filter((e2) => e2.reverseOf != null).length > 1) {
    throw new RangeError("Invalid era data: only one era can count years backwards");
  }
  let anchorEra;
  eras.forEach((e2) => {
    if (e2.isAnchor || !e2.anchorEpoch && !e2.reverseOf) {
      if (anchorEra)
        throw new RangeError("Invalid era data: cannot have multiple anchor eras");
      anchorEra = e2;
      e2.anchorEpoch = { year: e2.hasYearZero ? 0 : 1 };
    } else if (!e2.name) {
      throw new RangeError("If era name is blank, it must be the anchor era");
    }
  });
  eras = eras.filter((e2) => e2.name);
  eras.forEach((e2) => {
    const { reverseOf } = e2;
    if (reverseOf) {
      const reversedEra = eras.find((era) => era.name === reverseOf);
      if (reversedEra === void 0)
        throw new RangeError(`Invalid era data: unmatched reverseOf era: ${reverseOf}`);
      e2.reverseOf = reversedEra;
      e2.anchorEpoch = reversedEra.anchorEpoch;
      e2.isoEpoch = reversedEra.isoEpoch;
    }
    if (e2.anchorEpoch.month === void 0)
      e2.anchorEpoch.month = 1;
    if (e2.anchorEpoch.day === void 0)
      e2.anchorEpoch.day = 1;
  });
  ArraySort.call(eras, (e1, e2) => {
    if (e1.reverseOf)
      return 1;
    if (e2.reverseOf)
      return -1;
    if (!e1.isoEpoch || !e2.isoEpoch)
      throw new RangeError("Invalid era data: missing ISO epoch");
    return e2.isoEpoch.year - e1.isoEpoch.year;
  });
  const lastEraReversed = eras[eras.length - 1].reverseOf;
  if (lastEraReversed) {
    if (lastEraReversed !== eras[eras.length - 2])
      throw new RangeError("Invalid era data: invalid reverse-sign era");
  }
  eras.forEach((e2, i2) => {
    e2.genericName = `era${eras.length - 1 - i2}`;
  });
  return { eras, anchorEra: anchorEra || eras[0] };
}
function isGregorianLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function IsBuiltinCalendar(id) {
  return ArrayIncludes.call(BUILTIN_CALENDAR_IDS, id);
}
function IsInteger(value) {
  if (typeof value !== "number" || !NumberIsFinite(value))
    return false;
  const abs2 = MathAbs(value);
  return MathFloor(abs2) === abs2;
}
function IsObject(value) {
  return typeof value === "object" && value !== null || typeof value === "function";
}
function ToNumber(value) {
  if (typeof value === "bigint")
    throw new TypeError("Cannot convert BigInt to number");
  return NumberCtor(value);
}
function ToInteger(value) {
  const num = ToNumber(value);
  if (NumberIsNaN(num))
    return 0;
  const integer = MathTrunc(num);
  if (num === 0)
    return 0;
  return integer;
}
function ToString(value) {
  if (typeof value === "symbol") {
    throw new TypeError("Cannot convert a Symbol value to a String");
  }
  return StringCtor(value);
}
function ToIntegerThrowOnInfinity(value) {
  const integer = ToInteger(value);
  if (!NumberIsFinite(integer)) {
    throw new RangeError("infinity is out of range");
  }
  return integer;
}
function ToPositiveInteger(valueParam, property) {
  const value = ToInteger(valueParam);
  if (!NumberIsFinite(value)) {
    throw new RangeError("infinity is out of range");
  }
  if (value < 1) {
    if (property !== void 0) {
      throw new RangeError(`property '${property}' cannot be a a number less than one`);
    }
    throw new RangeError("Cannot convert a number less than one to a positive integer");
  }
  return value;
}
function ToIntegerWithoutRounding(valueParam) {
  const value = ToNumber(valueParam);
  if (NumberIsNaN(value))
    return 0;
  if (!NumberIsFinite(value)) {
    throw new RangeError("infinity is out of range");
  }
  if (!IsInteger(value)) {
    throw new RangeError(`unsupported fractional value ${value}`);
  }
  return ToInteger(value);
}
function divmod(x2, y) {
  const quotient = import_jsbi.default.divide(x2, y);
  const remainder = import_jsbi.default.remainder(x2, y);
  return { quotient, remainder };
}
function abs(x2) {
  if (import_jsbi.default.lessThan(x2, ZERO))
    return import_jsbi.default.multiply(x2, NEGATIVE_ONE);
  return x2;
}
function getIntlDateTimeFormatEnUsForTimeZone(timeZoneIdentifier) {
  let instance = IntlDateTimeFormatEnUsCache.get(timeZoneIdentifier);
  if (instance === void 0) {
    instance = new IntlDateTimeFormat$1("en-us", {
      timeZone: StringCtor(timeZoneIdentifier),
      hour12: false,
      era: "short",
      year: "numeric",
      month: "numeric",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric"
    });
    IntlDateTimeFormatEnUsCache.set(timeZoneIdentifier, instance);
  }
  return instance;
}
function IsTemporalInstant(item) {
  return HasSlot(item, EPOCHNANOSECONDS) && !HasSlot(item, TIME_ZONE, CALENDAR);
}
function IsTemporalTimeZone(item) {
  return HasSlot(item, TIMEZONE_ID);
}
function IsTemporalCalendar(item) {
  return HasSlot(item, CALENDAR_ID);
}
function IsTemporalDuration(item) {
  return HasSlot(item, YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS);
}
function IsTemporalDate(item) {
  return HasSlot(item, DATE_BRAND);
}
function IsTemporalTime(item) {
  return HasSlot(item, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND) && !HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY);
}
function IsTemporalDateTime(item) {
  return HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND);
}
function IsTemporalYearMonth(item) {
  return HasSlot(item, YEAR_MONTH_BRAND);
}
function IsTemporalMonthDay(item) {
  return HasSlot(item, MONTH_DAY_BRAND);
}
function IsTemporalZonedDateTime(item) {
  return HasSlot(item, EPOCHNANOSECONDS, TIME_ZONE, CALENDAR);
}
function RejectObjectWithCalendarOrTimeZone(item) {
  if (HasSlot(item, CALENDAR) || HasSlot(item, TIME_ZONE)) {
    throw new TypeError("with() does not support a calendar or timeZone property");
  }
  if (item.calendar !== void 0) {
    throw new TypeError("with() does not support a calendar property");
  }
  if (item.timeZone !== void 0) {
    throw new TypeError("with() does not support a timeZone property");
  }
}
function ParseTemporalTimeZone(stringIdent) {
  let { ianaName, offset: offset2, z } = ParseTemporalTimeZoneString(stringIdent);
  if (ianaName)
    return ianaName;
  if (z)
    return "UTC";
  return offset2;
}
function FormatCalendarAnnotation(id, showCalendar) {
  if (showCalendar === "never")
    return "";
  if (showCalendar === "auto" && id === "iso8601")
    return "";
  return `[u-ca=${id}]`;
}
function ParseISODateTime(isoString) {
  const match2 = zoneddatetime.exec(isoString);
  if (!match2)
    throw new RangeError(`invalid ISO 8601 string: ${isoString}`);
  let yearString = match2[1];
  if (yearString[0] === "\u2212")
    yearString = `-${yearString.slice(1)}`;
  if (yearString === "-000000")
    throw new RangeError(`invalid ISO 8601 string: ${isoString}`);
  const year = ToInteger(yearString);
  const month = ToInteger(match2[2] || match2[4]);
  const day = ToInteger(match2[3] || match2[5]);
  const hour = ToInteger(match2[6]);
  const hasTime = match2[6] !== void 0;
  const minute = ToInteger(match2[7] || match2[10]);
  let second = ToInteger(match2[8] || match2[11]);
  if (second === 60)
    second = 59;
  const fraction2 = (match2[9] || match2[12]) + "000000000";
  const millisecond = ToInteger(fraction2.slice(0, 3));
  const microsecond = ToInteger(fraction2.slice(3, 6));
  const nanosecond = ToInteger(fraction2.slice(6, 9));
  let offset2;
  let z = false;
  if (match2[13]) {
    offset2 = void 0;
    z = true;
  } else if (match2[14] && match2[15]) {
    const offsetSign = match2[14] === "-" || match2[14] === "\u2212" ? "-" : "+";
    const offsetHours = match2[15] || "00";
    const offsetMinutes = match2[16] || "00";
    const offsetSeconds = match2[17] || "00";
    let offsetFraction = match2[18] || "0";
    offset2 = `${offsetSign}${offsetHours}:${offsetMinutes}`;
    if (+offsetFraction) {
      while (offsetFraction.endsWith("0"))
        offsetFraction = offsetFraction.slice(0, -1);
      offset2 += `:${offsetSeconds}.${offsetFraction}`;
    } else if (+offsetSeconds) {
      offset2 += `:${offsetSeconds}`;
    }
    if (offset2 === "-00:00")
      offset2 = "+00:00";
  }
  let ianaName = match2[19];
  if (ianaName) {
    try {
      ianaName = GetCanonicalTimeZoneIdentifier(ianaName).toString();
    } catch {
    }
  }
  const calendar2 = match2[20];
  return {
    year,
    month,
    day,
    hasTime,
    hour,
    minute,
    second,
    millisecond,
    microsecond,
    nanosecond,
    ianaName,
    offset: offset2,
    z,
    calendar: calendar2
  };
}
function ParseTemporalInstantString(isoString) {
  const result = ParseISODateTime(isoString);
  if (!result.z && !result.offset)
    throw new RangeError("Temporal.Instant requires a time zone offset");
  return result;
}
function ParseTemporalZonedDateTimeString(isoString) {
  const result = ParseISODateTime(isoString);
  if (!result.ianaName)
    throw new RangeError("Temporal.ZonedDateTime requires a time zone ID in brackets");
  return result;
}
function ParseTemporalDateTimeString(isoString) {
  return ParseISODateTime(isoString);
}
function ParseTemporalDateString(isoString) {
  return ParseISODateTime(isoString);
}
function ParseTemporalTimeString(isoString) {
  const match2 = time.exec(isoString);
  let hour, minute, second, millisecond, microsecond, nanosecond, calendar2;
  if (match2) {
    hour = ToInteger(match2[1]);
    minute = ToInteger(match2[2] || match2[5]);
    second = ToInteger(match2[3] || match2[6]);
    if (second === 60)
      second = 59;
    const fraction2 = (match2[4] || match2[7]) + "000000000";
    millisecond = ToInteger(fraction2.slice(0, 3));
    microsecond = ToInteger(fraction2.slice(3, 6));
    nanosecond = ToInteger(fraction2.slice(6, 9));
    calendar2 = match2[15];
  } else {
    let z, hasTime;
    ({ hasTime, hour, minute, second, millisecond, microsecond, nanosecond, calendar: calendar2, z } = ParseISODateTime(isoString));
    if (!hasTime)
      throw new RangeError(`time is missing in string: ${isoString}`);
    if (z)
      throw new RangeError("Z designator not supported for PlainTime");
  }
  if (/[tT ][0-9][0-9]/.test(isoString)) {
    return { hour, minute, second, millisecond, microsecond, nanosecond, calendar: calendar2 };
  }
  try {
    const { month, day } = ParseTemporalMonthDayString(isoString);
    RejectISODate(1972, month, day);
  } catch {
    try {
      const { year, month } = ParseTemporalYearMonthString(isoString);
      RejectISODate(year, month, 1);
    } catch {
      return { hour, minute, second, millisecond, microsecond, nanosecond, calendar: calendar2 };
    }
  }
  throw new RangeError(`invalid ISO 8601 time-only string ${isoString}; may need a T prefix`);
}
function ParseTemporalYearMonthString(isoString) {
  const match2 = yearmonth.exec(isoString);
  let year, month, calendar2, referenceISODay;
  if (match2) {
    let yearString = match2[1];
    if (yearString[0] === "\u2212")
      yearString = `-${yearString.slice(1)}`;
    if (yearString === "-000000")
      throw new RangeError(`invalid ISO 8601 string: ${isoString}`);
    year = ToInteger(yearString);
    month = ToInteger(match2[2]);
    calendar2 = match2[3];
  } else {
    let z;
    ({ year, month, calendar: calendar2, day: referenceISODay, z } = ParseISODateTime(isoString));
    if (z)
      throw new RangeError("Z designator not supported for PlainYearMonth");
  }
  return { year, month, calendar: calendar2, referenceISODay };
}
function ParseTemporalMonthDayString(isoString) {
  const match2 = monthday.exec(isoString);
  let month, day, calendar2, referenceISOYear;
  if (match2) {
    month = ToInteger(match2[1]);
    day = ToInteger(match2[2]);
  } else {
    let z;
    ({ month, day, calendar: calendar2, year: referenceISOYear, z } = ParseISODateTime(isoString));
    if (z)
      throw new RangeError("Z designator not supported for PlainMonthDay");
  }
  return { month, day, calendar: calendar2, referenceISOYear };
}
function ParseTemporalTimeZoneString(stringIdent) {
  try {
    let canonicalIdent = GetCanonicalTimeZoneIdentifier(stringIdent);
    if (canonicalIdent) {
      canonicalIdent = canonicalIdent.toString();
      if (TestTimeZoneOffsetString(canonicalIdent))
        return { offset: canonicalIdent };
      return { ianaName: canonicalIdent };
    }
  } catch {
  }
  try {
    const result = ParseISODateTime(stringIdent);
    if (result.z || result.offset || result.ianaName) {
      return result;
    }
  } catch {
  }
  throw new RangeError(`Invalid time zone: ${stringIdent}`);
}
function ParseTemporalDurationString(isoString) {
  const match2 = duration.exec(isoString);
  if (!match2)
    throw new RangeError(`invalid duration: ${isoString}`);
  if (match2.slice(2).every((element) => element === void 0)) {
    throw new RangeError(`invalid duration: ${isoString}`);
  }
  const sign = match2[1] === "-" || match2[1] === "\u2212" ? -1 : 1;
  const years = ToInteger(match2[2]) * sign;
  const months = ToInteger(match2[3]) * sign;
  const weeks = ToInteger(match2[4]) * sign;
  const days = ToInteger(match2[5]) * sign;
  const hours = ToInteger(match2[6]) * sign;
  let fHours = match2[7];
  let minutes = ToInteger(match2[8]) * sign;
  let fMinutes = match2[9];
  let seconds = ToInteger(match2[10]) * sign;
  const fSeconds = match2[11] + "000000000";
  let milliseconds = ToInteger(fSeconds.slice(0, 3)) * sign;
  let microseconds = ToInteger(fSeconds.slice(3, 6)) * sign;
  let nanoseconds = ToInteger(fSeconds.slice(6, 9)) * sign;
  fHours = fHours ? sign * ToInteger(fHours) / 10 ** fHours.length : 0;
  fMinutes = fMinutes ? sign * ToInteger(fMinutes) / 10 ** fMinutes.length : 0;
  ({ minutes, seconds, milliseconds, microseconds, nanoseconds } = DurationHandleFractions(fHours, minutes, fMinutes, seconds, milliseconds, microseconds, nanoseconds));
  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };
}
function ParseTemporalInstant(isoString) {
  const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offset: offset2, z } = ParseTemporalInstantString(isoString);
  const epochNs = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);
  if (epochNs === null)
    throw new RangeError("DateTime outside of supported range");
  const offsetNs = z ? 0 : ParseTimeZoneOffsetString(offset2);
  return import_jsbi.default.subtract(epochNs, import_jsbi.default.BigInt(offsetNs));
}
function RegulateISODate(yearParam, monthParam, dayParam, overflow) {
  let year = yearParam;
  let month = monthParam;
  let day = dayParam;
  switch (overflow) {
    case "reject":
      RejectISODate(year, month, day);
      break;
    case "constrain":
      ({ year, month, day } = ConstrainISODate(year, month, day));
      break;
  }
  return { year, month, day };
}
function RegulateTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, overflow) {
  let hour = hourParam;
  let minute = minuteParam;
  let second = secondParam;
  let millisecond = millisecondParam;
  let microsecond = microsecondParam;
  let nanosecond = nanosecondParam;
  switch (overflow) {
    case "reject":
      RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);
      break;
    case "constrain":
      ({ hour, minute, second, millisecond, microsecond, nanosecond } = ConstrainTime(hour, minute, second, millisecond, microsecond, nanosecond));
      break;
  }
  return { hour, minute, second, millisecond, microsecond, nanosecond };
}
function RegulateISOYearMonth(yearParam, monthParam, overflow) {
  let year = yearParam;
  let month = monthParam;
  const referenceISODay = 1;
  switch (overflow) {
    case "reject":
      RejectISODate(year, month, referenceISODay);
      break;
    case "constrain":
      ({ year, month } = ConstrainISODate(year, month));
      break;
  }
  return { year, month };
}
function DurationHandleFractions(fHoursParam, minutesParam, fMinutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam) {
  let fHours = fHoursParam;
  let minutes = minutesParam;
  let fMinutes = fMinutesParam;
  let seconds = secondsParam;
  let milliseconds = millisecondsParam;
  let microseconds = microsecondsParam;
  let nanoseconds = nanosecondsParam;
  if (fHours !== 0) {
    [minutes, fMinutes, seconds, milliseconds, microseconds, nanoseconds].forEach((val) => {
      if (val !== 0)
        throw new RangeError("only the smallest unit can be fractional");
    });
    const mins = fHours * 60;
    minutes = MathTrunc(mins);
    fMinutes = mins % 1;
  }
  if (fMinutes !== 0) {
    [seconds, milliseconds, microseconds, nanoseconds].forEach((val) => {
      if (val !== 0)
        throw new RangeError("only the smallest unit can be fractional");
    });
    const secs = fMinutes * 60;
    seconds = MathTrunc(secs);
    const fSeconds = secs % 1;
    if (fSeconds !== 0) {
      const mils = fSeconds * 1e3;
      milliseconds = MathTrunc(mils);
      const fMilliseconds = mils % 1;
      if (fMilliseconds !== 0) {
        const mics = fMilliseconds * 1e3;
        microseconds = MathTrunc(mics);
        const fMicroseconds = mics % 1;
        if (fMicroseconds !== 0) {
          const nans = fMicroseconds * 1e3;
          nanoseconds = MathTrunc(nans);
        }
      }
    }
  }
  return { minutes, seconds, milliseconds, microseconds, nanoseconds };
}
function ToTemporalDurationRecord(item) {
  if (IsTemporalDuration(item)) {
    return {
      years: GetSlot(item, YEARS),
      months: GetSlot(item, MONTHS),
      weeks: GetSlot(item, WEEKS),
      days: GetSlot(item, DAYS),
      hours: GetSlot(item, HOURS),
      minutes: GetSlot(item, MINUTES),
      seconds: GetSlot(item, SECONDS),
      milliseconds: GetSlot(item, MILLISECONDS),
      microseconds: GetSlot(item, MICROSECONDS),
      nanoseconds: GetSlot(item, NANOSECONDS)
    };
  }
  const props = ToPartialRecord(item, [
    "days",
    "hours",
    "microseconds",
    "milliseconds",
    "minutes",
    "months",
    "nanoseconds",
    "seconds",
    "weeks",
    "years"
  ]);
  if (!props)
    throw new TypeError("invalid duration-like");
  const { years = 0, months = 0, weeks = 0, days = 0, hours = 0, minutes = 0, seconds = 0, milliseconds = 0, microseconds = 0, nanoseconds = 0 } = props;
  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };
}
function ToLimitedTemporalDuration(item, disallowedProperties = []) {
  let record;
  if (IsObject(item)) {
    record = ToTemporalDurationRecord(item);
  } else {
    const str = ToString(item);
    record = ParseTemporalDurationString(str);
  }
  const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = record;
  RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);
  for (const property of disallowedProperties) {
    if (record[property] !== 0) {
      throw new RangeError(`Duration field ${property} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`);
    }
  }
  return record;
}
function ToTemporalOverflow(options) {
  return GetOption(options, "overflow", ["constrain", "reject"], "constrain");
}
function ToTemporalDisambiguation(options) {
  return GetOption(options, "disambiguation", ["compatible", "earlier", "later", "reject"], "compatible");
}
function ToTemporalRoundingMode(options, fallback) {
  return GetOption(options, "roundingMode", ["ceil", "floor", "trunc", "halfExpand"], fallback);
}
function NegateTemporalRoundingMode(roundingMode) {
  switch (roundingMode) {
    case "ceil":
      return "floor";
    case "floor":
      return "ceil";
    default:
      return roundingMode;
  }
}
function ToTemporalOffset(options, fallback) {
  return GetOption(options, "offset", ["prefer", "use", "ignore", "reject"], fallback);
}
function ToShowCalendarOption(options) {
  return GetOption(options, "calendarName", ["auto", "always", "never"], "auto");
}
function ToShowTimeZoneNameOption(options) {
  return GetOption(options, "timeZoneName", ["auto", "never"], "auto");
}
function ToShowOffsetOption(options) {
  return GetOption(options, "offset", ["auto", "never"], "auto");
}
function ToTemporalRoundingIncrement(options, dividend, inclusive) {
  let maximum = Infinity;
  if (dividend !== void 0)
    maximum = dividend;
  if (!inclusive && dividend !== void 0)
    maximum = dividend > 1 ? dividend - 1 : 1;
  const increment = GetNumberOption(options, "roundingIncrement", 1, maximum, 1);
  if (dividend !== void 0 && dividend % increment !== 0) {
    throw new RangeError(`Rounding increment must divide evenly into ${dividend}`);
  }
  return increment;
}
function ToTemporalDateTimeRoundingIncrement(options, smallestUnit) {
  const maximumIncrements = {
    year: void 0,
    month: void 0,
    week: void 0,
    day: void 0,
    hour: 24,
    minute: 60,
    second: 60,
    millisecond: 1e3,
    microsecond: 1e3,
    nanosecond: 1e3
  };
  return ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);
}
function ToSecondsStringPrecision(options) {
  const smallestUnit = ToSmallestTemporalUnit(options, void 0, ["year", "month", "week", "day", "hour"]);
  switch (smallestUnit) {
    case "minute":
      return { precision: "minute", unit: "minute", increment: 1 };
    case "second":
      return { precision: 0, unit: "second", increment: 1 };
    case "millisecond":
      return { precision: 3, unit: "millisecond", increment: 1 };
    case "microsecond":
      return { precision: 6, unit: "microsecond", increment: 1 };
    case "nanosecond":
      return { precision: 9, unit: "nanosecond", increment: 1 };
  }
  let digits = options.fractionalSecondDigits;
  if (digits === void 0)
    digits = "auto";
  if (typeof digits !== "number") {
    const stringDigits = ToString(digits);
    if (stringDigits === "auto")
      return { precision: "auto", unit: "nanosecond", increment: 1 };
    throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${stringDigits}`);
  }
  if (NumberIsNaN(digits) || digits < 0 || digits > 9) {
    throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digits}`);
  }
  const precision = MathFloor(digits);
  switch (precision) {
    case 0:
      return { precision, unit: "second", increment: 1 };
    case 1:
    case 2:
    case 3:
      return { precision, unit: "millisecond", increment: 10 ** (3 - precision) };
    case 4:
    case 5:
    case 6:
      return { precision, unit: "microsecond", increment: 10 ** (6 - precision) };
    case 7:
    case 8:
    case 9:
      return { precision, unit: "nanosecond", increment: 10 ** (9 - precision) };
    default:
      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digits}`);
  }
}
function ToLargestTemporalUnit(options, fallback, disallowedStrings = [], autoValue) {
  const singular = new Map(SINGULAR_PLURAL_UNITS.filter(([, sing]) => !disallowedStrings.includes(sing)));
  const allowed = new Set(ALLOWED_UNITS);
  for (const s3 of disallowedStrings) {
    allowed.delete(s3);
  }
  const retval = GetOption(options, "largestUnit", ["auto", ...allowed, ...singular.keys()], fallback);
  if (retval === "auto" && autoValue !== void 0)
    return autoValue;
  if (singular.has(retval)) {
    return singular.get(retval);
  }
  return retval;
}
function ToSmallestTemporalUnit(options, fallback, disallowedStrings = []) {
  const singular = new Map(SINGULAR_PLURAL_UNITS.filter(([, sing]) => !disallowedStrings.includes(sing)));
  const allowed = new Set(ALLOWED_UNITS);
  for (const s3 of disallowedStrings) {
    allowed.delete(s3);
  }
  const value = GetOption(options, "smallestUnit", [...allowed, ...singular.keys()], fallback);
  if (singular.has(value)) {
    return singular.get(value);
  }
  return value;
}
function ToTemporalDurationTotalUnit(options) {
  const singular = new Map(SINGULAR_PLURAL_UNITS);
  const value = GetOption(options, "unit", [...singular.values(), ...singular.keys()], void 0);
  if (singular.has(value)) {
    return singular.get(value);
  }
  return value;
}
function ToRelativeTemporalObject(options) {
  const relativeTo = options.relativeTo;
  if (relativeTo === void 0)
    return relativeTo;
  let offsetBehaviour = "option";
  let matchMinutes = false;
  let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar2, timeZone2, offset2;
  if (IsObject(relativeTo)) {
    if (IsTemporalZonedDateTime(relativeTo) || IsTemporalDate(relativeTo))
      return relativeTo;
    if (IsTemporalDateTime(relativeTo))
      return TemporalDateTimeToDate(relativeTo);
    calendar2 = GetTemporalCalendarWithISODefault(relativeTo);
    const fieldNames = CalendarFields(calendar2, [
      "day",
      "hour",
      "microsecond",
      "millisecond",
      "minute",
      "month",
      "monthCode",
      "nanosecond",
      "second",
      "year"
    ]);
    const fields = ToTemporalDateTimeFields(relativeTo, fieldNames);
    const dateOptions = ObjectCreate$2(null);
    dateOptions.overflow = "constrain";
    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar2, fields, dateOptions));
    offset2 = relativeTo.offset;
    if (offset2 === void 0)
      offsetBehaviour = "wall";
    timeZone2 = relativeTo.timeZone;
  } else {
    let ianaName, z;
    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar: calendar2, ianaName, offset: offset2, z } = ParseISODateTime(ToString(relativeTo)));
    if (ianaName)
      timeZone2 = ianaName;
    if (z) {
      offsetBehaviour = "exact";
    } else if (!offset2) {
      offsetBehaviour = "wall";
    }
    if (!calendar2)
      calendar2 = GetISO8601Calendar();
    calendar2 = ToTemporalCalendar(calendar2);
    matchMinutes = true;
  }
  if (timeZone2) {
    timeZone2 = ToTemporalTimeZone(timeZone2);
    let offsetNs = 0;
    if (offsetBehaviour === "option")
      offsetNs = ParseTimeZoneOffsetString(ToString(offset2));
    const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone2, "compatible", "reject", matchMinutes);
    return CreateTemporalZonedDateTime(epochNanoseconds, timeZone2, calendar2);
  }
  return CreateTemporalDate(year, month, day, calendar2);
}
function ValidateTemporalUnitRange(largestUnit, smallestUnit) {
  if (ALLOWED_UNITS.indexOf(largestUnit) > ALLOWED_UNITS.indexOf(smallestUnit)) {
    throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);
  }
}
function DefaultTemporalLargestUnit(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds) {
  const singular = new Map(SINGULAR_PLURAL_UNITS);
  for (const [prop, v] of [
    ["years", years],
    ["months", months],
    ["weeks", weeks],
    ["days", days],
    ["hours", hours],
    ["minutes", minutes],
    ["seconds", seconds],
    ["milliseconds", milliseconds],
    ["microseconds", microseconds],
    ["nanoseconds", nanoseconds]
  ]) {
    if (v !== 0)
      return singular.get(prop);
  }
  return "nanosecond";
}
function LargerOfTwoTemporalUnits(unit1, unit2) {
  if (ALLOWED_UNITS.indexOf(unit1) > ALLOWED_UNITS.indexOf(unit2))
    return unit2;
  return unit1;
}
function ToPartialRecord(bagParam, fieldsParam) {
  const bag = bagParam;
  const fields = fieldsParam;
  let any = false;
  let result = {};
  for (const property of fields) {
    const value = bag[property];
    if (value !== void 0) {
      any = true;
      if (BUILTIN_CASTS.has(property)) {
        result[property] = BUILTIN_CASTS.get(property)(value);
      } else {
        result[property] = value;
      }
    }
  }
  return any ? result : false;
}
function PrepareTemporalFields(bagParam, fieldsParam) {
  const bag = bagParam;
  const fields = fieldsParam;
  const result = {};
  let any = false;
  for (const fieldRecord of fields) {
    const [property, defaultValue] = fieldRecord;
    let value = bag[property];
    if (value === void 0) {
      if (fieldRecord.length === 1) {
        throw new TypeError(`required property '${property}' missing or undefined`);
      }
      value = defaultValue;
    } else {
      any = true;
      if (BUILTIN_CASTS.has(property)) {
        value = BUILTIN_CASTS.get(property)(value);
      }
    }
    result[property] = value;
  }
  if (!any) {
    throw new TypeError("no supported properties found");
  }
  if (result["era"] === void 0 !== (result["eraYear"] === void 0)) {
    throw new RangeError("properties 'era' and 'eraYear' must be provided together");
  }
  return result;
}
function ToTemporalDateFields(bag, fieldNames) {
  const entries = [
    ["day", void 0],
    ["month", void 0],
    ["monthCode", void 0],
    ["year", void 0]
  ];
  fieldNames.forEach((fieldName) => {
    if (!entries.some(([name]) => name === fieldName)) {
      entries.push([fieldName, void 0]);
    }
  });
  return PrepareTemporalFields(bag, entries);
}
function ToTemporalDateTimeFields(bag, fieldNames) {
  const entries = [
    ["day", void 0],
    ["hour", 0],
    ["microsecond", 0],
    ["millisecond", 0],
    ["minute", 0],
    ["month", void 0],
    ["monthCode", void 0],
    ["nanosecond", 0],
    ["second", 0],
    ["year", void 0]
  ];
  fieldNames.forEach((fieldName) => {
    if (!entries.some(([name]) => name === fieldName)) {
      entries.push([fieldName, void 0]);
    }
  });
  return PrepareTemporalFields(bag, entries);
}
function ToTemporalMonthDayFields(bag, fieldNames) {
  const entries = [
    ["day", void 0],
    ["month", void 0],
    ["monthCode", void 0],
    ["year", void 0]
  ];
  fieldNames.forEach((fieldName) => {
    if (!entries.some(([name]) => name === fieldName)) {
      entries.push([fieldName, void 0]);
    }
  });
  return PrepareTemporalFields(bag, entries);
}
function ToTemporalTimeRecord(bag) {
  return PrepareTemporalFields(bag, [
    ["hour", 0],
    ["microsecond", 0],
    ["millisecond", 0],
    ["minute", 0],
    ["nanosecond", 0],
    ["second", 0]
  ]);
}
function ToTemporalYearMonthFields(bag, fieldNames) {
  const entries = [
    ["month", void 0],
    ["monthCode", void 0],
    ["year", void 0]
  ];
  fieldNames.forEach((fieldName) => {
    if (!entries.some(([name]) => name === fieldName)) {
      entries.push([fieldName, void 0]);
    }
  });
  return PrepareTemporalFields(bag, entries);
}
function ToTemporalZonedDateTimeFields(bag, fieldNames) {
  const entries = [
    ["day", void 0],
    ["hour", 0],
    ["microsecond", 0],
    ["millisecond", 0],
    ["minute", 0],
    ["month", void 0],
    ["monthCode", void 0],
    ["nanosecond", 0],
    ["second", 0],
    ["year", void 0],
    ["offset", void 0],
    ["timeZone"]
  ];
  fieldNames.forEach((fieldName) => {
    if (!entries.some(([name]) => name === fieldName)) {
      entries.push([fieldName, void 0]);
    }
  });
  return PrepareTemporalFields(bag, entries);
}
function ToTemporalDate(itemParam, options = ObjectCreate$2(null)) {
  let item = itemParam;
  if (IsObject(item)) {
    if (IsTemporalDate(item))
      return item;
    if (IsTemporalZonedDateTime(item)) {
      item = BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));
    }
    if (IsTemporalDateTime(item)) {
      return CreateTemporalDate(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR));
    }
    const calendar3 = GetTemporalCalendarWithISODefault(item);
    const fieldNames = CalendarFields(calendar3, ["day", "month", "monthCode", "year"]);
    const fields = ToTemporalDateFields(item, fieldNames);
    return DateFromFields(calendar3, fields, options);
  }
  ToTemporalOverflow(options);
  const { year, month, day, calendar: calendar2, z } = ParseTemporalDateString(ToString(item));
  if (z)
    throw new RangeError("Z designator not supported for PlainDate");
  const TemporalPlainDate = GetIntrinsic("%Temporal.PlainDate%");
  return new TemporalPlainDate(year, month, day, calendar2);
}
function InterpretTemporalDateTimeFields(calendar2, fields, options) {
  let { hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(fields);
  const overflow = ToTemporalOverflow(options);
  const date = DateFromFields(calendar2, fields, options);
  const year = GetSlot(date, ISO_YEAR);
  const month = GetSlot(date, ISO_MONTH);
  const day = GetSlot(date, ISO_DAY);
  ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));
  return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };
}
function ToTemporalDateTime(item, options = ObjectCreate$2(null)) {
  let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar2;
  if (IsObject(item)) {
    if (IsTemporalDateTime(item))
      return item;
    if (IsTemporalZonedDateTime(item)) {
      return BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));
    }
    if (IsTemporalDate(item)) {
      return CreateTemporalDateTime(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), 0, 0, 0, 0, 0, 0, GetSlot(item, CALENDAR));
    }
    calendar2 = GetTemporalCalendarWithISODefault(item);
    const fieldNames = CalendarFields(calendar2, [
      "day",
      "hour",
      "microsecond",
      "millisecond",
      "minute",
      "month",
      "monthCode",
      "nanosecond",
      "second",
      "year"
    ]);
    const fields = ToTemporalDateTimeFields(item, fieldNames);
    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar2, fields, options));
  } else {
    ToTemporalOverflow(options);
    let z;
    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar: calendar2, z } = ParseTemporalDateTimeString(ToString(item)));
    if (z)
      throw new RangeError("Z designator not supported for PlainDateTime");
    RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);
    if (calendar2 === void 0)
      calendar2 = GetISO8601Calendar();
    calendar2 = ToTemporalCalendar(calendar2);
  }
  return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar2);
}
function ToTemporalDuration(item) {
  let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;
  if (IsObject(item)) {
    if (IsTemporalDuration(item))
      return item;
    ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToTemporalDurationRecord(item));
  } else {
    ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ParseTemporalDurationString(ToString(item)));
  }
  const TemporalDuration = GetIntrinsic("%Temporal.Duration%");
  return new TemporalDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);
}
function ToTemporalInstant(item) {
  if (IsTemporalInstant(item))
    return item;
  if (IsTemporalZonedDateTime(item)) {
    const TemporalInstant2 = GetIntrinsic("%Temporal.Instant%");
    return new TemporalInstant2(GetSlot(item, EPOCHNANOSECONDS));
  }
  const ns = ParseTemporalInstant(ToString(item));
  const TemporalInstant = GetIntrinsic("%Temporal.Instant%");
  return new TemporalInstant(ns);
}
function ToTemporalMonthDay(item, options = ObjectCreate$2(null)) {
  if (IsObject(item)) {
    if (IsTemporalMonthDay(item))
      return item;
    let calendar3, calendarAbsent;
    if (HasSlot(item, CALENDAR)) {
      calendar3 = GetSlot(item, CALENDAR);
      calendarAbsent = false;
    } else {
      let maybeStringCalendar2 = item.calendar;
      calendarAbsent = maybeStringCalendar2 === void 0;
      if (maybeStringCalendar2 === void 0)
        maybeStringCalendar2 = GetISO8601Calendar();
      calendar3 = ToTemporalCalendar(maybeStringCalendar2);
    }
    const fieldNames = CalendarFields(calendar3, ["day", "month", "monthCode", "year"]);
    const fields = ToTemporalMonthDayFields(item, fieldNames);
    if (calendarAbsent && fields.month !== void 0 && fields.monthCode === void 0 && fields.year === void 0) {
      fields.year = 1972;
    }
    return MonthDayFromFields(calendar3, fields, options);
  }
  ToTemporalOverflow(options);
  let { month, day, referenceISOYear, calendar: maybeStringCalendar } = ParseTemporalMonthDayString(ToString(item));
  let calendar2 = maybeStringCalendar;
  if (calendar2 === void 0)
    calendar2 = GetISO8601Calendar();
  calendar2 = ToTemporalCalendar(calendar2);
  if (referenceISOYear === void 0) {
    RejectISODate(1972, month, day);
    return CreateTemporalMonthDay(month, day, calendar2);
  }
  const result = CreateTemporalMonthDay(month, day, calendar2, referenceISOYear);
  const canonicalOptions = ObjectCreate$2(null);
  return MonthDayFromFields(calendar2, result, canonicalOptions);
}
function ToTemporalTime(itemParam, overflow = "constrain") {
  let item = itemParam;
  let hour, minute, second, millisecond, microsecond, nanosecond, calendar2;
  if (IsObject(item)) {
    if (IsTemporalTime(item))
      return item;
    if (IsTemporalZonedDateTime(item)) {
      item = BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));
    }
    if (IsTemporalDateTime(item)) {
      const TemporalPlainTime2 = GetIntrinsic("%Temporal.PlainTime%");
      return new TemporalPlainTime2(GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND));
    }
    calendar2 = GetTemporalCalendarWithISODefault(item);
    if (ToString(calendar2) !== "iso8601") {
      throw new RangeError("PlainTime can only have iso8601 calendar");
    }
    ({ hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(item));
    ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));
  } else {
    ({ hour, minute, second, millisecond, microsecond, nanosecond, calendar: calendar2 } = ParseTemporalTimeString(ToString(item)));
    RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);
    if (calendar2 !== void 0 && calendar2 !== "iso8601") {
      throw new RangeError("PlainTime can only have iso8601 calendar");
    }
  }
  const TemporalPlainTime = GetIntrinsic("%Temporal.PlainTime%");
  return new TemporalPlainTime(hour, minute, second, millisecond, microsecond, nanosecond);
}
function ToTemporalYearMonth(item, options = ObjectCreate$2(null)) {
  if (IsObject(item)) {
    if (IsTemporalYearMonth(item))
      return item;
    const calendar3 = GetTemporalCalendarWithISODefault(item);
    const fieldNames = CalendarFields(calendar3, ["month", "monthCode", "year"]);
    const fields = ToTemporalYearMonthFields(item, fieldNames);
    return YearMonthFromFields(calendar3, fields, options);
  }
  ToTemporalOverflow(options);
  let { year, month, referenceISODay, calendar: maybeStringCalendar } = ParseTemporalYearMonthString(ToString(item));
  let calendar2 = maybeStringCalendar;
  if (calendar2 === void 0)
    calendar2 = GetISO8601Calendar();
  calendar2 = ToTemporalCalendar(calendar2);
  if (referenceISODay === void 0) {
    RejectISODate(year, month, 1);
    return CreateTemporalYearMonth(year, month, calendar2);
  }
  const result = CreateTemporalYearMonth(year, month, calendar2, referenceISODay);
  const canonicalOptions = ObjectCreate$2(null);
  return YearMonthFromFields(calendar2, result, canonicalOptions);
}
function InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone2, disambiguation, offsetOpt, matchMinute) {
  const DateTime = GetIntrinsic("%Temporal.PlainDateTime%");
  const dt = new DateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);
  if (offsetBehaviour === "wall" || offsetOpt === "ignore") {
    const instant3 = BuiltinTimeZoneGetInstantFor(timeZone2, dt, disambiguation);
    return GetSlot(instant3, EPOCHNANOSECONDS);
  }
  if (offsetBehaviour === "exact" || offsetOpt === "use") {
    const epochNs = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);
    if (epochNs === null)
      throw new RangeError("ZonedDateTime outside of supported range");
    return import_jsbi.default.subtract(epochNs, import_jsbi.default.BigInt(offsetNs));
  }
  const possibleInstants = GetPossibleInstantsFor(timeZone2, dt);
  for (const candidate of possibleInstants) {
    const candidateOffset = GetOffsetNanosecondsFor(timeZone2, candidate);
    const roundedCandidateOffset = import_jsbi.default.toNumber(RoundNumberToIncrement(import_jsbi.default.BigInt(candidateOffset), 6e10, "halfExpand"));
    if (candidateOffset === offsetNs || matchMinute && roundedCandidateOffset === offsetNs) {
      return GetSlot(candidate, EPOCHNANOSECONDS);
    }
  }
  if (offsetOpt === "reject") {
    const offsetStr = FormatTimeZoneOffsetString(offsetNs);
    const timeZoneString = IsTemporalTimeZone(timeZone2) ? GetSlot(timeZone2, TIMEZONE_ID) : "time zone";
    throw new RangeError(`Offset ${offsetStr} is invalid for ${dt.toString()} in ${timeZoneString}`);
  }
  const instant2 = DisambiguatePossibleInstants(possibleInstants, timeZone2, dt, disambiguation);
  return GetSlot(instant2, EPOCHNANOSECONDS);
}
function ToTemporalZonedDateTime(item, options = ObjectCreate$2(null)) {
  let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, timeZone2, offset2, calendar2;
  let matchMinute = false;
  let offsetBehaviour = "option";
  if (IsObject(item)) {
    if (IsTemporalZonedDateTime(item))
      return item;
    calendar2 = GetTemporalCalendarWithISODefault(item);
    const fieldNames = CalendarFields(calendar2, [
      "day",
      "hour",
      "microsecond",
      "millisecond",
      "minute",
      "month",
      "monthCode",
      "nanosecond",
      "second",
      "year"
    ]);
    const fields = ToTemporalZonedDateTimeFields(item, fieldNames);
    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar2, fields, options));
    timeZone2 = ToTemporalTimeZone(fields.timeZone);
    offset2 = fields.offset;
    if (offset2 === void 0) {
      offsetBehaviour = "wall";
    } else {
      offset2 = ToString(offset2);
    }
  } else {
    ToTemporalOverflow(options);
    let ianaName, z;
    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, ianaName, offset: offset2, z, calendar: calendar2 } = ParseTemporalZonedDateTimeString(ToString(item)));
    if (!ianaName)
      throw new RangeError("time zone ID required in brackets");
    if (z) {
      offsetBehaviour = "exact";
    } else if (!offset2) {
      offsetBehaviour = "wall";
    }
    const TemporalTimeZone = GetIntrinsic("%Temporal.TimeZone%");
    timeZone2 = new TemporalTimeZone(ianaName);
    if (!calendar2)
      calendar2 = GetISO8601Calendar();
    calendar2 = ToTemporalCalendar(calendar2);
    matchMinute = true;
  }
  let offsetNs = 0;
  if (offsetBehaviour === "option")
    offsetNs = ParseTimeZoneOffsetString(offset2);
  const disambiguation = ToTemporalDisambiguation(options);
  const offsetOpt = ToTemporalOffset(options, "reject");
  const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone2, disambiguation, offsetOpt, matchMinute);
  return CreateTemporalZonedDateTime(epochNanoseconds, timeZone2, calendar2);
}
function CreateTemporalDateSlots(result, isoYear, isoMonth, isoDay, calendar2) {
  RejectISODate(isoYear, isoMonth, isoDay);
  RejectDateRange(isoYear, isoMonth, isoDay);
  CreateSlots(result);
  SetSlot(result, ISO_YEAR, isoYear);
  SetSlot(result, ISO_MONTH, isoMonth);
  SetSlot(result, ISO_DAY, isoDay);
  SetSlot(result, CALENDAR, calendar2);
  SetSlot(result, DATE_BRAND, true);
  {
    ObjectDefineProperty(result, "_repr_", {
      value: `${result[Symbol.toStringTag]} <${TemporalDateToString(result)}>`,
      writable: false,
      enumerable: false,
      configurable: false
    });
  }
}
function CreateTemporalDate(isoYear, isoMonth, isoDay, calendar2 = GetISO8601Calendar()) {
  const TemporalPlainDate = GetIntrinsic("%Temporal.PlainDate%");
  const result = ObjectCreate$2(TemporalPlainDate.prototype);
  CreateTemporalDateSlots(result, isoYear, isoMonth, isoDay, calendar2);
  return result;
}
function CreateTemporalDateTimeSlots(result, isoYear, isoMonth, isoDay, h2, min, s3, ms, \u00B5s, ns, calendar2) {
  RejectDateTime(isoYear, isoMonth, isoDay, h2, min, s3, ms, \u00B5s, ns);
  RejectDateTimeRange(isoYear, isoMonth, isoDay, h2, min, s3, ms, \u00B5s, ns);
  CreateSlots(result);
  SetSlot(result, ISO_YEAR, isoYear);
  SetSlot(result, ISO_MONTH, isoMonth);
  SetSlot(result, ISO_DAY, isoDay);
  SetSlot(result, ISO_HOUR, h2);
  SetSlot(result, ISO_MINUTE, min);
  SetSlot(result, ISO_SECOND, s3);
  SetSlot(result, ISO_MILLISECOND, ms);
  SetSlot(result, ISO_MICROSECOND, \u00B5s);
  SetSlot(result, ISO_NANOSECOND, ns);
  SetSlot(result, CALENDAR, calendar2);
  {
    Object.defineProperty(result, "_repr_", {
      value: `${result[Symbol.toStringTag]} <${TemporalDateTimeToString(result, "auto")}>`,
      writable: false,
      enumerable: false,
      configurable: false
    });
  }
}
function CreateTemporalDateTime(isoYear, isoMonth, isoDay, h2, min, s3, ms, \u00B5s, ns, calendar2 = GetISO8601Calendar()) {
  const TemporalPlainDateTime = GetIntrinsic("%Temporal.PlainDateTime%");
  const result = ObjectCreate$2(TemporalPlainDateTime.prototype);
  CreateTemporalDateTimeSlots(result, isoYear, isoMonth, isoDay, h2, min, s3, ms, \u00B5s, ns, calendar2);
  return result;
}
function CreateTemporalMonthDaySlots(result, isoMonth, isoDay, calendar2, referenceISOYear) {
  RejectISODate(referenceISOYear, isoMonth, isoDay);
  RejectDateRange(referenceISOYear, isoMonth, isoDay);
  CreateSlots(result);
  SetSlot(result, ISO_MONTH, isoMonth);
  SetSlot(result, ISO_DAY, isoDay);
  SetSlot(result, ISO_YEAR, referenceISOYear);
  SetSlot(result, CALENDAR, calendar2);
  SetSlot(result, MONTH_DAY_BRAND, true);
  {
    Object.defineProperty(result, "_repr_", {
      value: `${result[Symbol.toStringTag]} <${TemporalMonthDayToString(result)}>`,
      writable: false,
      enumerable: false,
      configurable: false
    });
  }
}
function CreateTemporalMonthDay(isoMonth, isoDay, calendar2 = GetISO8601Calendar(), referenceISOYear = 1972) {
  const TemporalPlainMonthDay = GetIntrinsic("%Temporal.PlainMonthDay%");
  const result = ObjectCreate$2(TemporalPlainMonthDay.prototype);
  CreateTemporalMonthDaySlots(result, isoMonth, isoDay, calendar2, referenceISOYear);
  return result;
}
function CreateTemporalYearMonthSlots(result, isoYear, isoMonth, calendar2, referenceISODay) {
  RejectISODate(isoYear, isoMonth, referenceISODay);
  RejectYearMonthRange(isoYear, isoMonth);
  CreateSlots(result);
  SetSlot(result, ISO_YEAR, isoYear);
  SetSlot(result, ISO_MONTH, isoMonth);
  SetSlot(result, ISO_DAY, referenceISODay);
  SetSlot(result, CALENDAR, calendar2);
  SetSlot(result, YEAR_MONTH_BRAND, true);
  {
    Object.defineProperty(result, "_repr_", {
      value: `${result[Symbol.toStringTag]} <${TemporalYearMonthToString(result)}>`,
      writable: false,
      enumerable: false,
      configurable: false
    });
  }
}
function CreateTemporalYearMonth(isoYear, isoMonth, calendar2 = GetISO8601Calendar(), referenceISODay = 1) {
  const TemporalPlainYearMonth = GetIntrinsic("%Temporal.PlainYearMonth%");
  const result = ObjectCreate$2(TemporalPlainYearMonth.prototype);
  CreateTemporalYearMonthSlots(result, isoYear, isoMonth, calendar2, referenceISODay);
  return result;
}
function CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone2, calendar2) {
  ValidateEpochNanoseconds(epochNanoseconds);
  CreateSlots(result);
  SetSlot(result, EPOCHNANOSECONDS, epochNanoseconds);
  SetSlot(result, TIME_ZONE, timeZone2);
  SetSlot(result, CALENDAR, calendar2);
  const TemporalInstant = GetIntrinsic("%Temporal.Instant%");
  const instant2 = new TemporalInstant(GetSlot(result, EPOCHNANOSECONDS));
  SetSlot(result, INSTANT, instant2);
  {
    Object.defineProperty(result, "_repr_", {
      value: `${result[Symbol.toStringTag]} <${TemporalZonedDateTimeToString(result, "auto")}>`,
      writable: false,
      enumerable: false,
      configurable: false
    });
  }
}
function CreateTemporalZonedDateTime(epochNanoseconds, timeZone2, calendar2 = GetISO8601Calendar()) {
  const TemporalZonedDateTime = GetIntrinsic("%Temporal.ZonedDateTime%");
  const result = ObjectCreate$2(TemporalZonedDateTime.prototype);
  CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone2, calendar2);
  return result;
}
function GetISO8601Calendar() {
  const TemporalCalendar = GetIntrinsic("%Temporal.Calendar%");
  return new TemporalCalendar("iso8601");
}
function CalendarFields(calendar2, fieldNamesParam) {
  let fieldNames = fieldNamesParam;
  if (calendar2.fields) {
    fieldNames = calendar2.fields(fieldNames);
  }
  const result = [];
  for (const name of fieldNames) {
    if (typeof name !== "string")
      throw new TypeError("bad return from calendar.fields()");
    ArrayPrototypePush$1.call(result, name);
  }
  return result;
}
function CalendarMergeFields(calendar2, fields, additionalFields) {
  const calMergeFields = calendar2.mergeFields;
  if (!calMergeFields) {
    return __spreadValues(__spreadValues({}, fields), additionalFields);
  }
  const result = Reflect.apply(calMergeFields, calendar2, [fields, additionalFields]);
  if (!IsObject(result))
    throw new TypeError("bad return from calendar.mergeFields()");
  return result;
}
function CalendarDateAdd(calendar2, date, duration2, options, dateAddParam) {
  let dateAdd = dateAddParam;
  if (dateAdd === void 0) {
    dateAdd = calendar2.dateAdd;
  }
  const result = ReflectApply$1(dateAdd, calendar2, [date, duration2, options]);
  if (!IsTemporalDate(result))
    throw new TypeError("invalid result");
  return result;
}
function CalendarDateUntil(calendar2, date, otherDate, options, dateUntilParam) {
  let dateUntil = dateUntilParam;
  if (dateUntil === void 0) {
    dateUntil = calendar2.dateUntil;
  }
  const result = ReflectApply$1(dateUntil, calendar2, [date, otherDate, options]);
  if (!IsTemporalDuration(result))
    throw new TypeError("invalid result");
  return result;
}
function CalendarYear(calendar2, dateLike) {
  const result = calendar2.year(dateLike);
  if (result === void 0) {
    throw new RangeError("calendar year result must be an integer");
  }
  return ToIntegerThrowOnInfinity(result);
}
function CalendarMonth(calendar2, dateLike) {
  const result = calendar2.month(dateLike);
  if (result === void 0) {
    throw new RangeError("calendar month result must be a positive integer");
  }
  return ToPositiveInteger(result);
}
function CalendarMonthCode(calendar2, dateLike) {
  const result = calendar2.monthCode(dateLike);
  if (result === void 0) {
    throw new RangeError("calendar monthCode result must be a string");
  }
  return ToString(result);
}
function CalendarDay(calendar2, dateLike) {
  const result = calendar2.day(dateLike);
  if (result === void 0) {
    throw new RangeError("calendar day result must be a positive integer");
  }
  return ToPositiveInteger(result);
}
function CalendarEra(calendar2, dateLike) {
  let result = calendar2.era(dateLike);
  if (result !== void 0) {
    result = ToString(result);
  }
  return result;
}
function CalendarEraYear(calendar2, dateLike) {
  let result = calendar2.eraYear(dateLike);
  if (result !== void 0) {
    result = ToIntegerThrowOnInfinity(result);
  }
  return result;
}
function CalendarDayOfWeek(calendar2, dateLike) {
  return calendar2.dayOfWeek(dateLike);
}
function CalendarDayOfYear(calendar2, dateLike) {
  return calendar2.dayOfYear(dateLike);
}
function CalendarWeekOfYear(calendar2, dateLike) {
  return calendar2.weekOfYear(dateLike);
}
function CalendarDaysInWeek(calendar2, dateLike) {
  return calendar2.daysInWeek(dateLike);
}
function CalendarDaysInMonth(calendar2, dateLike) {
  return calendar2.daysInMonth(dateLike);
}
function CalendarDaysInYear(calendar2, dateLike) {
  return calendar2.daysInYear(dateLike);
}
function CalendarMonthsInYear(calendar2, dateLike) {
  return calendar2.monthsInYear(dateLike);
}
function CalendarInLeapYear(calendar2, dateLike) {
  return calendar2.inLeapYear(dateLike);
}
function ToTemporalCalendar(calendarLikeParam) {
  let calendarLike = calendarLikeParam;
  if (IsObject(calendarLike)) {
    if (HasSlot(calendarLike, CALENDAR))
      return GetSlot(calendarLike, CALENDAR);
    if (!("calendar" in calendarLike))
      return calendarLike;
    calendarLike = calendarLike.calendar;
    if (IsObject(calendarLike) && !("calendar" in calendarLike))
      return calendarLike;
  }
  const identifier = ToString(calendarLike);
  const TemporalCalendar = GetIntrinsic("%Temporal.Calendar%");
  if (IsBuiltinCalendar(identifier))
    return new TemporalCalendar(identifier);
  let calendar2;
  try {
    ({ calendar: calendar2 } = ParseISODateTime(identifier));
  } catch {
    throw new RangeError(`Invalid calendar: ${identifier}`);
  }
  if (!calendar2)
    calendar2 = "iso8601";
  return new TemporalCalendar(calendar2);
}
function GetTemporalCalendarWithISODefault(item) {
  if (HasSlot(item, CALENDAR))
    return GetSlot(item, CALENDAR);
  const { calendar: calendar2 } = item;
  if (calendar2 === void 0)
    return GetISO8601Calendar();
  return ToTemporalCalendar(calendar2);
}
function CalendarEquals(one, two) {
  if (one === two)
    return true;
  const cal1 = ToString(one);
  const cal2 = ToString(two);
  return cal1 === cal2;
}
function ConsolidateCalendars(one, two) {
  if (one === two)
    return two;
  const sOne = ToString(one);
  const sTwo = ToString(two);
  if (sOne === sTwo || sOne === "iso8601") {
    return two;
  } else if (sTwo === "iso8601") {
    return one;
  } else {
    throw new RangeError("irreconcilable calendars");
  }
}
function DateFromFields(calendar2, fields, options) {
  const result = calendar2.dateFromFields(fields, options);
  if (!IsTemporalDate(result))
    throw new TypeError("invalid result");
  return result;
}
function YearMonthFromFields(calendar2, fields, options) {
  const result = calendar2.yearMonthFromFields(fields, options);
  if (!IsTemporalYearMonth(result))
    throw new TypeError("invalid result");
  return result;
}
function MonthDayFromFields(calendar2, fields, options) {
  const result = calendar2.monthDayFromFields(fields, options);
  if (!IsTemporalMonthDay(result))
    throw new TypeError("invalid result");
  return result;
}
function ToTemporalTimeZone(temporalTimeZoneLikeParam) {
  let temporalTimeZoneLike = temporalTimeZoneLikeParam;
  if (IsObject(temporalTimeZoneLike)) {
    if (IsTemporalZonedDateTime(temporalTimeZoneLike))
      return GetSlot(temporalTimeZoneLike, TIME_ZONE);
    if (!("timeZone" in temporalTimeZoneLike))
      return temporalTimeZoneLike;
    temporalTimeZoneLike = temporalTimeZoneLike.timeZone;
    if (IsObject(temporalTimeZoneLike) && !("timeZone" in temporalTimeZoneLike)) {
      return temporalTimeZoneLike;
    }
  }
  const identifier = ToString(temporalTimeZoneLike);
  const timeZone2 = ParseTemporalTimeZone(identifier);
  const TemporalTimeZone = GetIntrinsic("%Temporal.TimeZone%");
  return new TemporalTimeZone(timeZone2);
}
function TimeZoneEquals(one, two) {
  if (one === two)
    return true;
  const tz1 = ToString(one);
  const tz2 = ToString(two);
  return tz1 === tz2;
}
function TemporalDateTimeToDate(dateTime2) {
  return CreateTemporalDate(GetSlot(dateTime2, ISO_YEAR), GetSlot(dateTime2, ISO_MONTH), GetSlot(dateTime2, ISO_DAY), GetSlot(dateTime2, CALENDAR));
}
function TemporalDateTimeToTime(dateTime2) {
  const Time = GetIntrinsic("%Temporal.PlainTime%");
  return new Time(GetSlot(dateTime2, ISO_HOUR), GetSlot(dateTime2, ISO_MINUTE), GetSlot(dateTime2, ISO_SECOND), GetSlot(dateTime2, ISO_MILLISECOND), GetSlot(dateTime2, ISO_MICROSECOND), GetSlot(dateTime2, ISO_NANOSECOND));
}
function GetOffsetNanosecondsFor(timeZone2, instant2) {
  let getOffsetNanosecondsFor = timeZone2.getOffsetNanosecondsFor;
  if (typeof getOffsetNanosecondsFor !== "function") {
    throw new TypeError("getOffsetNanosecondsFor not callable");
  }
  const offsetNs = Reflect.apply(getOffsetNanosecondsFor, timeZone2, [instant2]);
  if (typeof offsetNs !== "number") {
    throw new TypeError("bad return from getOffsetNanosecondsFor");
  }
  if (!IsInteger(offsetNs) || MathAbs(offsetNs) > 864e11) {
    throw new RangeError("out-of-range return from getOffsetNanosecondsFor");
  }
  return offsetNs;
}
function BuiltinTimeZoneGetOffsetStringFor(timeZone2, instant2) {
  const offsetNs = GetOffsetNanosecondsFor(timeZone2, instant2);
  return FormatTimeZoneOffsetString(offsetNs);
}
function BuiltinTimeZoneGetPlainDateTimeFor(timeZone2, instant2, calendar2) {
  const ns = GetSlot(instant2, EPOCHNANOSECONDS);
  const offsetNs = GetOffsetNanosecondsFor(timeZone2, instant2);
  let { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = GetISOPartsFromEpoch(ns);
  ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond + offsetNs));
  return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar2);
}
function BuiltinTimeZoneGetInstantFor(timeZone2, dateTime2, disambiguation) {
  const possibleInstants = GetPossibleInstantsFor(timeZone2, dateTime2);
  return DisambiguatePossibleInstants(possibleInstants, timeZone2, dateTime2, disambiguation);
}
function DisambiguatePossibleInstants(possibleInstants, timeZone2, dateTime2, disambiguation) {
  const Instant2 = GetIntrinsic("%Temporal.Instant%");
  const numInstants = possibleInstants.length;
  if (numInstants === 1)
    return possibleInstants[0];
  if (numInstants) {
    switch (disambiguation) {
      case "compatible":
      case "earlier":
        return possibleInstants[0];
      case "later":
        return possibleInstants[numInstants - 1];
      case "reject": {
        throw new RangeError("multiple instants found");
      }
    }
  }
  const year = GetSlot(dateTime2, ISO_YEAR);
  const month = GetSlot(dateTime2, ISO_MONTH);
  const day = GetSlot(dateTime2, ISO_DAY);
  const hour = GetSlot(dateTime2, ISO_HOUR);
  const minute = GetSlot(dateTime2, ISO_MINUTE);
  const second = GetSlot(dateTime2, ISO_SECOND);
  const millisecond = GetSlot(dateTime2, ISO_MILLISECOND);
  const microsecond = GetSlot(dateTime2, ISO_MICROSECOND);
  const nanosecond = GetSlot(dateTime2, ISO_NANOSECOND);
  const utcns = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);
  if (utcns === null)
    throw new RangeError("DateTime outside of supported range");
  const dayBefore = new Instant2(import_jsbi.default.subtract(utcns, DAY_NANOS));
  const dayAfter = new Instant2(import_jsbi.default.add(utcns, DAY_NANOS));
  const offsetBefore = GetOffsetNanosecondsFor(timeZone2, dayBefore);
  const offsetAfter = GetOffsetNanosecondsFor(timeZone2, dayAfter);
  const nanoseconds = offsetAfter - offsetBefore;
  switch (disambiguation) {
    case "earlier": {
      const calendar2 = GetSlot(dateTime2, CALENDAR);
      const PlainDateTime2 = GetIntrinsic("%Temporal.PlainDateTime%");
      const earlier = AddDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar2, 0, 0, 0, 0, 0, 0, 0, 0, 0, -nanoseconds, void 0);
      const earlierPlainDateTime = new PlainDateTime2(earlier.year, earlier.month, earlier.day, earlier.hour, earlier.minute, earlier.second, earlier.millisecond, earlier.microsecond, earlier.nanosecond, calendar2);
      return GetPossibleInstantsFor(timeZone2, earlierPlainDateTime)[0];
    }
    case "compatible":
    case "later": {
      const calendar2 = GetSlot(dateTime2, CALENDAR);
      const PlainDateTime2 = GetIntrinsic("%Temporal.PlainDateTime%");
      const later = AddDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar2, 0, 0, 0, 0, 0, 0, 0, 0, 0, nanoseconds, void 0);
      const laterPlainDateTime = new PlainDateTime2(later.year, later.month, later.day, later.hour, later.minute, later.second, later.millisecond, later.microsecond, later.nanosecond, calendar2);
      const possible = GetPossibleInstantsFor(timeZone2, laterPlainDateTime);
      return possible[possible.length - 1];
    }
    case "reject": {
      throw new RangeError("no such instant found");
    }
  }
}
function GetPossibleInstantsFor(timeZone2, dateTime2) {
  const possibleInstants = timeZone2.getPossibleInstantsFor(dateTime2);
  const result = [];
  for (const instant2 of possibleInstants) {
    if (!IsTemporalInstant(instant2)) {
      throw new TypeError("bad return from getPossibleInstantsFor");
    }
    ArrayPrototypePush$1.call(result, instant2);
  }
  return result;
}
function ISOYearString(year) {
  let yearString;
  if (year < 1e3 || year > 9999) {
    const sign = year < 0 ? "-" : "+";
    const yearNumber = MathAbs(year);
    yearString = sign + `000000${yearNumber}`.slice(-6);
  } else {
    yearString = `${year}`;
  }
  return yearString;
}
function ISODateTimePartString(part) {
  return `00${part}`.slice(-2);
}
function FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision) {
  if (precision === "minute")
    return "";
  const secs = `:${ISODateTimePartString(second)}`;
  let fractionNumber = millisecond * 1e6 + microsecond * 1e3 + nanosecond;
  let fraction2;
  if (precision === "auto") {
    if (fractionNumber === 0)
      return secs;
    fraction2 = `${fractionNumber}`.padStart(9, "0");
    while (fraction2[fraction2.length - 1] === "0")
      fraction2 = fraction2.slice(0, -1);
  } else {
    if (precision === 0)
      return secs;
    fraction2 = `${fractionNumber}`.padStart(9, "0").slice(0, precision);
  }
  return `${secs}.${fraction2}`;
}
function TemporalInstantToString(instant2, timeZone2, precision) {
  let outputTimeZone = timeZone2;
  if (outputTimeZone === void 0) {
    const TemporalTimeZone = GetIntrinsic("%Temporal.TimeZone%");
    outputTimeZone = new TemporalTimeZone("UTC");
  }
  const iso = GetISO8601Calendar();
  const dateTime2 = BuiltinTimeZoneGetPlainDateTimeFor(outputTimeZone, instant2, iso);
  const year = ISOYearString(GetSlot(dateTime2, ISO_YEAR));
  const month = ISODateTimePartString(GetSlot(dateTime2, ISO_MONTH));
  const day = ISODateTimePartString(GetSlot(dateTime2, ISO_DAY));
  const hour = ISODateTimePartString(GetSlot(dateTime2, ISO_HOUR));
  const minute = ISODateTimePartString(GetSlot(dateTime2, ISO_MINUTE));
  const seconds = FormatSecondsStringPart(GetSlot(dateTime2, ISO_SECOND), GetSlot(dateTime2, ISO_MILLISECOND), GetSlot(dateTime2, ISO_MICROSECOND), GetSlot(dateTime2, ISO_NANOSECOND), precision);
  let timeZoneString = "Z";
  if (timeZone2 !== void 0) {
    const offsetNs = GetOffsetNanosecondsFor(outputTimeZone, instant2);
    timeZoneString = FormatISOTimeZoneOffsetString(offsetNs);
  }
  return `${year}-${month}-${day}T${hour}:${minute}${seconds}${timeZoneString}`;
}
function TemporalDurationToString(duration2, precision = "auto", options = void 0) {
  function formatNumber(num) {
    if (num <= NumberMaxSafeInteger)
      return num.toString(10);
    return import_jsbi.default.BigInt(num).toString(10);
  }
  const years = GetSlot(duration2, YEARS);
  const months = GetSlot(duration2, MONTHS);
  const weeks = GetSlot(duration2, WEEKS);
  const days = GetSlot(duration2, DAYS);
  const hours = GetSlot(duration2, HOURS);
  const minutes = GetSlot(duration2, MINUTES);
  let seconds = GetSlot(duration2, SECONDS);
  let ms = GetSlot(duration2, MILLISECONDS);
  let \u00B5s = GetSlot(duration2, MICROSECONDS);
  let ns = GetSlot(duration2, NANOSECONDS);
  const sign = DurationSign(years, months, weeks, days, hours, minutes, seconds, ms, \u00B5s, ns);
  if (options) {
    const { unit, increment, roundingMode } = options;
    ({
      seconds,
      milliseconds: ms,
      microseconds: \u00B5s,
      nanoseconds: ns
    } = RoundDuration(0, 0, 0, 0, 0, 0, seconds, ms, \u00B5s, ns, increment, unit, roundingMode));
  }
  const dateParts = [];
  if (years)
    dateParts.push(`${formatNumber(MathAbs(years))}Y`);
  if (months)
    dateParts.push(`${formatNumber(MathAbs(months))}M`);
  if (weeks)
    dateParts.push(`${formatNumber(MathAbs(weeks))}W`);
  if (days)
    dateParts.push(`${formatNumber(MathAbs(days))}D`);
  const timeParts = [];
  if (hours)
    timeParts.push(`${formatNumber(MathAbs(hours))}H`);
  if (minutes)
    timeParts.push(`${formatNumber(MathAbs(minutes))}M`);
  const secondParts = [];
  let total = TotalDurationNanoseconds(0, 0, 0, seconds, ms, \u00B5s, ns, 0);
  let nsBigInt, \u00B5sBigInt, msBigInt, secondsBigInt;
  ({ quotient: total, remainder: nsBigInt } = divmod(total, THOUSAND));
  ({ quotient: total, remainder: \u00B5sBigInt } = divmod(total, THOUSAND));
  ({ quotient: secondsBigInt, remainder: msBigInt } = divmod(total, THOUSAND));
  const fraction2 = MathAbs(import_jsbi.default.toNumber(msBigInt)) * 1e6 + MathAbs(import_jsbi.default.toNumber(\u00B5sBigInt)) * 1e3 + MathAbs(import_jsbi.default.toNumber(nsBigInt));
  let decimalPart;
  if (precision === "auto") {
    if (fraction2 !== 0) {
      decimalPart = `${fraction2}`.padStart(9, "0");
      while (decimalPart[decimalPart.length - 1] === "0") {
        decimalPart = decimalPart.slice(0, -1);
      }
    }
  } else if (precision !== 0) {
    decimalPart = `${fraction2}`.padStart(9, "0").slice(0, precision);
  }
  if (decimalPart)
    secondParts.unshift(".", decimalPart);
  if (!import_jsbi.default.equal(secondsBigInt, ZERO) || secondParts.length || precision !== "auto") {
    secondParts.unshift(abs(secondsBigInt).toString());
  }
  if (secondParts.length)
    timeParts.push(`${secondParts.join("")}S`);
  if (timeParts.length)
    timeParts.unshift("T");
  if (!dateParts.length && !timeParts.length)
    return "PT0S";
  return `${sign < 0 ? "-" : ""}P${dateParts.join("")}${timeParts.join("")}`;
}
function TemporalDateToString(date, showCalendar = "auto") {
  const year = ISOYearString(GetSlot(date, ISO_YEAR));
  const month = ISODateTimePartString(GetSlot(date, ISO_MONTH));
  const day = ISODateTimePartString(GetSlot(date, ISO_DAY));
  const calendarID2 = ToString(GetSlot(date, CALENDAR));
  const calendar2 = FormatCalendarAnnotation(calendarID2, showCalendar);
  return `${year}-${month}-${day}${calendar2}`;
}
function TemporalDateTimeToString(dateTime2, precision, showCalendar = "auto", options = void 0) {
  let year = GetSlot(dateTime2, ISO_YEAR);
  let month = GetSlot(dateTime2, ISO_MONTH);
  let day = GetSlot(dateTime2, ISO_DAY);
  let hour = GetSlot(dateTime2, ISO_HOUR);
  let minute = GetSlot(dateTime2, ISO_MINUTE);
  let second = GetSlot(dateTime2, ISO_SECOND);
  let millisecond = GetSlot(dateTime2, ISO_MILLISECOND);
  let microsecond = GetSlot(dateTime2, ISO_MICROSECOND);
  let nanosecond = GetSlot(dateTime2, ISO_NANOSECOND);
  if (options) {
    const { unit, increment, roundingMode } = options;
    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode));
  }
  const yearString = ISOYearString(year);
  const monthString = ISODateTimePartString(month);
  const dayString = ISODateTimePartString(day);
  const hourString = ISODateTimePartString(hour);
  const minuteString = ISODateTimePartString(minute);
  const secondsString = FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);
  const calendarID2 = ToString(GetSlot(dateTime2, CALENDAR));
  const calendar2 = FormatCalendarAnnotation(calendarID2, showCalendar);
  return `${yearString}-${monthString}-${dayString}T${hourString}:${minuteString}${secondsString}${calendar2}`;
}
function TemporalMonthDayToString(monthDay, showCalendar = "auto") {
  const month = ISODateTimePartString(GetSlot(monthDay, ISO_MONTH));
  const day = ISODateTimePartString(GetSlot(monthDay, ISO_DAY));
  let resultString = `${month}-${day}`;
  const calendar2 = GetSlot(monthDay, CALENDAR);
  const calendarID2 = ToString(calendar2);
  if (calendarID2 !== "iso8601") {
    const year = ISOYearString(GetSlot(monthDay, ISO_YEAR));
    resultString = `${year}-${resultString}`;
  }
  const calendarString = FormatCalendarAnnotation(calendarID2, showCalendar);
  if (calendarString)
    resultString += calendarString;
  return resultString;
}
function TemporalYearMonthToString(yearMonth, showCalendar = "auto") {
  const year = ISOYearString(GetSlot(yearMonth, ISO_YEAR));
  const month = ISODateTimePartString(GetSlot(yearMonth, ISO_MONTH));
  let resultString = `${year}-${month}`;
  const calendar2 = GetSlot(yearMonth, CALENDAR);
  const calendarID2 = ToString(calendar2);
  if (calendarID2 !== "iso8601") {
    const day = ISODateTimePartString(GetSlot(yearMonth, ISO_DAY));
    resultString += `-${day}`;
  }
  const calendarString = FormatCalendarAnnotation(calendarID2, showCalendar);
  if (calendarString)
    resultString += calendarString;
  return resultString;
}
function TemporalZonedDateTimeToString(zdt, precision, showCalendar = "auto", showTimeZone = "auto", showOffset = "auto", options = void 0) {
  let instant2 = GetSlot(zdt, INSTANT);
  if (options) {
    const { unit, increment, roundingMode } = options;
    const ns = RoundInstant(GetSlot(zdt, EPOCHNANOSECONDS), increment, unit, roundingMode);
    const TemporalInstant = GetIntrinsic("%Temporal.Instant%");
    instant2 = new TemporalInstant(ns);
  }
  const tz = GetSlot(zdt, TIME_ZONE);
  const iso = GetISO8601Calendar();
  const dateTime2 = BuiltinTimeZoneGetPlainDateTimeFor(tz, instant2, iso);
  const year = ISOYearString(GetSlot(dateTime2, ISO_YEAR));
  const month = ISODateTimePartString(GetSlot(dateTime2, ISO_MONTH));
  const day = ISODateTimePartString(GetSlot(dateTime2, ISO_DAY));
  const hour = ISODateTimePartString(GetSlot(dateTime2, ISO_HOUR));
  const minute = ISODateTimePartString(GetSlot(dateTime2, ISO_MINUTE));
  const seconds = FormatSecondsStringPart(GetSlot(dateTime2, ISO_SECOND), GetSlot(dateTime2, ISO_MILLISECOND), GetSlot(dateTime2, ISO_MICROSECOND), GetSlot(dateTime2, ISO_NANOSECOND), precision);
  let result = `${year}-${month}-${day}T${hour}:${minute}${seconds}`;
  if (showOffset !== "never") {
    const offsetNs = GetOffsetNanosecondsFor(tz, instant2);
    result += FormatISOTimeZoneOffsetString(offsetNs);
  }
  if (showTimeZone !== "never")
    result += `[${tz}]`;
  const calendarID2 = ToString(GetSlot(zdt, CALENDAR));
  result += FormatCalendarAnnotation(calendarID2, showCalendar);
  return result;
}
function TestTimeZoneOffsetString(string) {
  return OFFSET.test(StringCtor(string));
}
function ParseTimeZoneOffsetString(string) {
  const match2 = OFFSET.exec(StringCtor(string));
  if (!match2) {
    throw new RangeError(`invalid time zone offset: ${string}`);
  }
  const sign = match2[1] === "-" || match2[1] === "\u2212" ? -1 : 1;
  const hours = +match2[2];
  const minutes = +(match2[3] || 0);
  const seconds = +(match2[4] || 0);
  const nanoseconds = +((match2[5] || 0) + "000000000").slice(0, 9);
  return sign * (((hours * 60 + minutes) * 60 + seconds) * 1e9 + nanoseconds);
}
function GetCanonicalTimeZoneIdentifier(timeZoneIdentifier) {
  if (TestTimeZoneOffsetString(timeZoneIdentifier)) {
    const offsetNs = ParseTimeZoneOffsetString(timeZoneIdentifier);
    return FormatTimeZoneOffsetString(offsetNs);
  }
  const formatter = getIntlDateTimeFormatEnUsForTimeZone(StringCtor(timeZoneIdentifier));
  return formatter.resolvedOptions().timeZone;
}
function GetIANATimeZoneOffsetNanoseconds(epochNanoseconds, id) {
  const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = GetIANATimeZoneDateTimeParts(epochNanoseconds, id);
  const utc = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);
  if (utc === null)
    throw new RangeError("Date outside of supported range");
  return import_jsbi.default.toNumber(import_jsbi.default.subtract(utc, epochNanoseconds));
}
function FormatTimeZoneOffsetString(offsetNanosecondsParam) {
  const sign = offsetNanosecondsParam < 0 ? "-" : "+";
  const offsetNanoseconds = MathAbs(offsetNanosecondsParam);
  const nanoseconds = offsetNanoseconds % 1e9;
  const seconds = MathFloor(offsetNanoseconds / 1e9) % 60;
  const minutes = MathFloor(offsetNanoseconds / 6e10) % 60;
  const hours = MathFloor(offsetNanoseconds / 36e11);
  const hourString = ISODateTimePartString(hours);
  const minuteString = ISODateTimePartString(minutes);
  const secondString = ISODateTimePartString(seconds);
  let post = "";
  if (nanoseconds) {
    let fraction2 = `${nanoseconds}`.padStart(9, "0");
    while (fraction2[fraction2.length - 1] === "0")
      fraction2 = fraction2.slice(0, -1);
    post = `:${secondString}.${fraction2}`;
  } else if (seconds) {
    post = `:${secondString}`;
  }
  return `${sign}${hourString}:${minuteString}${post}`;
}
function FormatISOTimeZoneOffsetString(offsetNanosecondsParam) {
  let offsetNanoseconds = import_jsbi.default.toNumber(RoundNumberToIncrement(import_jsbi.default.BigInt(offsetNanosecondsParam), 6e10, "halfExpand"));
  const sign = offsetNanoseconds < 0 ? "-" : "+";
  offsetNanoseconds = MathAbs(offsetNanoseconds);
  const minutes = offsetNanoseconds / 6e10 % 60;
  const hours = MathFloor(offsetNanoseconds / 36e11);
  const hourString = ISODateTimePartString(hours);
  const minuteString = ISODateTimePartString(minutes);
  return `${sign}${hourString}:${minuteString}`;
}
function GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {
  const legacyDate = new Date();
  legacyDate.setUTCHours(hour, minute, second, millisecond);
  legacyDate.setUTCFullYear(year, month - 1, day);
  const ms = legacyDate.getTime();
  if (NumberIsNaN(ms))
    return null;
  let ns = import_jsbi.default.multiply(import_jsbi.default.BigInt(ms), MILLION);
  ns = import_jsbi.default.add(ns, import_jsbi.default.multiply(import_jsbi.default.BigInt(microsecond), THOUSAND));
  ns = import_jsbi.default.add(ns, import_jsbi.default.BigInt(nanosecond));
  if (import_jsbi.default.lessThan(ns, NS_MIN) || import_jsbi.default.greaterThan(ns, NS_MAX))
    return null;
  return ns;
}
function GetISOPartsFromEpoch(epochNanoseconds) {
  const { quotient, remainder } = divmod(epochNanoseconds, MILLION);
  let epochMilliseconds = import_jsbi.default.toNumber(quotient);
  let nanos = import_jsbi.default.toNumber(remainder);
  if (nanos < 0) {
    nanos += 1e6;
    epochMilliseconds -= 1;
  }
  const microsecond = MathFloor(nanos / 1e3) % 1e3;
  const nanosecond = nanos % 1e3;
  const item = new Date(epochMilliseconds);
  const year = item.getUTCFullYear();
  const month = item.getUTCMonth() + 1;
  const day = item.getUTCDate();
  const hour = item.getUTCHours();
  const minute = item.getUTCMinutes();
  const second = item.getUTCSeconds();
  const millisecond = item.getUTCMilliseconds();
  return { epochMilliseconds, year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };
}
function GetIANATimeZoneDateTimeParts(epochNanoseconds, id) {
  const { epochMilliseconds, millisecond, microsecond, nanosecond } = GetISOPartsFromEpoch(epochNanoseconds);
  const { year, month, day, hour, minute, second } = GetFormatterParts(id, epochMilliseconds);
  return BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);
}
function maxJSBI(one, two) {
  return import_jsbi.default.lessThan(one, two) ? two : one;
}
function afterLatestPossibleTzdbRuleChange() {
  return import_jsbi.default.add(SystemUTCEpochNanoSeconds(), ABOUT_TEN_YEARS_NANOS);
}
function GetIANATimeZoneNextTransition(epochNanoseconds, id) {
  const oneYearLater = import_jsbi.default.add(epochNanoseconds, ABOUT_ONE_YEAR_NANOS);
  const uppercap = maxJSBI(afterLatestPossibleTzdbRuleChange(), oneYearLater);
  let leftNanos = maxJSBI(BEFORE_FIRST_OFFSET_TRANSITION, epochNanoseconds);
  const leftOffsetNs = GetIANATimeZoneOffsetNanoseconds(leftNanos, id);
  let rightNanos = leftNanos;
  let rightOffsetNs = leftOffsetNs;
  while (leftOffsetNs === rightOffsetNs && import_jsbi.default.lessThan(import_jsbi.default.BigInt(leftNanos), uppercap)) {
    rightNanos = import_jsbi.default.add(leftNanos, TWO_WEEKS_NANOS);
    rightOffsetNs = GetIANATimeZoneOffsetNanoseconds(rightNanos, id);
    if (leftOffsetNs === rightOffsetNs) {
      leftNanos = rightNanos;
    }
  }
  if (leftOffsetNs === rightOffsetNs)
    return null;
  const result = bisect((epochNs) => GetIANATimeZoneOffsetNanoseconds(epochNs, id), leftNanos, rightNanos, leftOffsetNs, rightOffsetNs);
  return result;
}
function GetIANATimeZonePreviousTransition(epochNanoseconds, id) {
  const afterLatestRule = afterLatestPossibleTzdbRuleChange();
  const isFarFuture = import_jsbi.default.greaterThan(epochNanoseconds, afterLatestRule);
  const lowercap = isFarFuture ? import_jsbi.default.subtract(epochNanoseconds, ABOUT_ONE_YEAR_NANOS) : BEFORE_FIRST_OFFSET_TRANSITION;
  let rightNanos = import_jsbi.default.subtract(epochNanoseconds, ONE);
  const rightOffsetNs = GetIANATimeZoneOffsetNanoseconds(rightNanos, id);
  let leftNanos = rightNanos;
  let leftOffsetNs = rightOffsetNs;
  while (rightOffsetNs === leftOffsetNs && import_jsbi.default.greaterThan(rightNanos, lowercap)) {
    leftNanos = import_jsbi.default.subtract(rightNanos, TWO_WEEKS_NANOS);
    leftOffsetNs = GetIANATimeZoneOffsetNanoseconds(leftNanos, id);
    if (rightOffsetNs === leftOffsetNs) {
      rightNanos = leftNanos;
    }
  }
  if (rightOffsetNs === leftOffsetNs) {
    if (isFarFuture) {
      const newTimeToCheck = import_jsbi.default.subtract(afterLatestRule, DAY_NANOS);
      return GetIANATimeZonePreviousTransition(newTimeToCheck, id);
    }
    return null;
  }
  const result = bisect((epochNs) => GetIANATimeZoneOffsetNanoseconds(epochNs, id), leftNanos, rightNanos, leftOffsetNs, rightOffsetNs);
  return result;
}
function parseFromEnUsFormat(datetime) {
  const parts = datetime.split(/[^\w]+/);
  if (parts.length !== 7) {
    throw new RangeError(`expected 7 parts in "${datetime}`);
  }
  const month = +parts[0];
  const day = +parts[1];
  let year = +parts[2];
  const era = parts[3].toUpperCase();
  if (era === "B" || era === "BC") {
    year = -year + 1;
  } else if (era !== "A" && era !== "AD") {
    throw new RangeError(`Unknown era ${era} in "${datetime}`);
  }
  let hour = +parts[4];
  if (hour === 24) {
    hour = 0;
  }
  const minute = +parts[5];
  const second = +parts[6];
  if (!NumberIsFinite(year) || !NumberIsFinite(month) || !NumberIsFinite(day) || !NumberIsFinite(hour) || !NumberIsFinite(minute) || !NumberIsFinite(second)) {
    throw new RangeError(`Invalid number in "${datetime}`);
  }
  return { year, month, day, hour, minute, second };
}
function GetFormatterParts(timeZone2, epochMilliseconds) {
  const formatter = getIntlDateTimeFormatEnUsForTimeZone(timeZone2);
  const datetime = formatter.format(new Date(epochMilliseconds));
  return parseFromEnUsFormat(datetime);
}
function GetIANATimeZoneEpochValue(id, year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {
  const ns = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);
  if (ns === null)
    throw new RangeError("DateTime outside of supported range");
  let nsEarlier = import_jsbi.default.subtract(ns, DAY_NANOS);
  if (import_jsbi.default.lessThan(nsEarlier, NS_MIN))
    nsEarlier = ns;
  let nsLater = import_jsbi.default.add(ns, DAY_NANOS);
  if (import_jsbi.default.greaterThan(nsLater, NS_MAX))
    nsLater = ns;
  const earliest = GetIANATimeZoneOffsetNanoseconds(nsEarlier, id);
  const latest = GetIANATimeZoneOffsetNanoseconds(nsLater, id);
  const found = earliest === latest ? [earliest] : [earliest, latest];
  return found.map((offsetNanoseconds) => {
    const epochNanoseconds = import_jsbi.default.subtract(ns, import_jsbi.default.BigInt(offsetNanoseconds));
    const parts = GetIANATimeZoneDateTimeParts(epochNanoseconds, id);
    if (year !== parts.year || month !== parts.month || day !== parts.day || hour !== parts.hour || minute !== parts.minute || second !== parts.second || millisecond !== parts.millisecond || microsecond !== parts.microsecond || nanosecond !== parts.nanosecond) {
      return void 0;
    }
    return epochNanoseconds;
  }).filter((x2) => x2 !== void 0);
}
function LeapYear(year) {
  if (year === void 0)
    return false;
  const isDiv4 = year % 4 === 0;
  const isDiv100 = year % 100 === 0;
  const isDiv400 = year % 400 === 0;
  return isDiv4 && (!isDiv100 || isDiv400);
}
function ISODaysInMonth(year, month) {
  const DoM = {
    standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  };
  return DoM[LeapYear(year) ? "leapyear" : "standard"][month - 1];
}
function DayOfWeek(year, month, day) {
  const m2 = month + (month < 3 ? 10 : -2);
  const Y = year - (month < 3 ? 1 : 0);
  const c = MathFloor(Y / 100);
  const y = Y - c * 100;
  const d = day;
  const pD = d;
  const pM = MathFloor(2.6 * m2 - 0.2);
  const pY = y + MathFloor(y / 4);
  const pC = MathFloor(c / 4) - 2 * c;
  const dow = (pD + pM + pY + pC) % 7;
  return dow + (dow <= 0 ? 7 : 0);
}
function DayOfYear(year, month, day) {
  let days = day;
  for (let m2 = month - 1; m2 > 0; m2--) {
    days += ISODaysInMonth(year, m2);
  }
  return days;
}
function WeekOfYear(year, month, day) {
  const doy = DayOfYear(year, month, day);
  const dow = DayOfWeek(year, month, day) || 7;
  const doj = DayOfWeek(year, 1, 1);
  const week = MathFloor((doy - dow + 10) / 7);
  if (week < 1) {
    if (doj === 5 || doj === 6 && LeapYear(year - 1)) {
      return 53;
    } else {
      return 52;
    }
  }
  if (week === 53) {
    if ((LeapYear(year) ? 366 : 365) - doy < 4 - dow) {
      return 1;
    }
  }
  return week;
}
function DurationSign(y, mon, w, d, h2, min, s3, ms, \u00B5s, ns) {
  for (const prop of [y, mon, w, d, h2, min, s3, ms, \u00B5s, ns]) {
    if (prop !== 0)
      return prop < 0 ? -1 : 1;
  }
  return 0;
}
function BalanceISOYearMonth(yearParam, monthParam) {
  let year = yearParam;
  let month = monthParam;
  if (!NumberIsFinite(year) || !NumberIsFinite(month))
    throw new RangeError("infinity is out of range");
  month -= 1;
  year += MathFloor(month / 12);
  month %= 12;
  if (month < 0)
    month += 12;
  month += 1;
  return { year, month };
}
function BalanceISODate(yearParam, monthParam, dayParam) {
  let year = yearParam;
  let month = monthParam;
  let day = dayParam;
  if (!NumberIsFinite(day))
    throw new RangeError("infinity is out of range");
  ({ year, month } = BalanceISOYearMonth(year, month));
  let daysInYear = 0;
  let testYear = month > 2 ? year : year - 1;
  while (daysInYear = LeapYear(testYear) ? 366 : 365, day < -daysInYear) {
    year -= 1;
    testYear -= 1;
    day += daysInYear;
  }
  testYear += 1;
  while (daysInYear = LeapYear(testYear) ? 366 : 365, day > daysInYear) {
    year += 1;
    testYear += 1;
    day -= daysInYear;
  }
  while (day < 1) {
    ({ year, month } = BalanceISOYearMonth(year, month - 1));
    day += ISODaysInMonth(year, month);
  }
  while (day > ISODaysInMonth(year, month)) {
    day -= ISODaysInMonth(year, month);
    ({ year, month } = BalanceISOYearMonth(year, month + 1));
  }
  return { year, month, day };
}
function BalanceISODateTime(yearParam, monthParam, dayParam, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {
  const { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam);
  const { year, month, day } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);
  return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };
}
function BalanceTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {
  let hour = hourParam;
  let minute = minuteParam;
  let second = secondParam;
  let millisecond = millisecondParam;
  let microsecond = microsecondParam;
  let nanosecond = nanosecondParam;
  if (!NumberIsFinite(hour) || !NumberIsFinite(minute) || !NumberIsFinite(second) || !NumberIsFinite(millisecond) || !NumberIsFinite(microsecond) || !NumberIsFinite(nanosecond)) {
    throw new RangeError("infinity is out of range");
  }
  microsecond += MathFloor(nanosecond / 1e3);
  nanosecond = NonNegativeModulo(nanosecond, 1e3);
  millisecond += MathFloor(microsecond / 1e3);
  microsecond = NonNegativeModulo(microsecond, 1e3);
  second += MathFloor(millisecond / 1e3);
  millisecond = NonNegativeModulo(millisecond, 1e3);
  minute += MathFloor(second / 60);
  second = NonNegativeModulo(second, 60);
  hour += MathFloor(minute / 60);
  minute = NonNegativeModulo(minute, 60);
  const deltaDays = MathFloor(hour / 24);
  hour = NonNegativeModulo(hour, 24);
  return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };
}
function TotalDurationNanoseconds(daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, offsetShift) {
  const days = import_jsbi.default.BigInt(daysParam);
  let nanoseconds = import_jsbi.default.BigInt(nanosecondsParam);
  if (daysParam !== 0)
    nanoseconds = import_jsbi.default.subtract(import_jsbi.default.BigInt(nanosecondsParam), import_jsbi.default.BigInt(offsetShift));
  const hours = import_jsbi.default.add(import_jsbi.default.BigInt(hoursParam), import_jsbi.default.multiply(days, import_jsbi.default.BigInt(24)));
  const minutes = import_jsbi.default.add(import_jsbi.default.BigInt(minutesParam), import_jsbi.default.multiply(hours, SIXTY));
  const seconds = import_jsbi.default.add(import_jsbi.default.BigInt(secondsParam), import_jsbi.default.multiply(minutes, SIXTY));
  const milliseconds = import_jsbi.default.add(import_jsbi.default.BigInt(millisecondsParam), import_jsbi.default.multiply(seconds, THOUSAND));
  const microseconds = import_jsbi.default.add(import_jsbi.default.BigInt(microsecondsParam), import_jsbi.default.multiply(milliseconds, THOUSAND));
  return import_jsbi.default.add(import_jsbi.default.BigInt(nanoseconds), import_jsbi.default.multiply(microseconds, THOUSAND));
}
function NanosecondsToDays(nanosecondsParam, relativeTo) {
  const TemporalInstant = GetIntrinsic("%Temporal.Instant%");
  const sign = MathSign(import_jsbi.default.toNumber(nanosecondsParam));
  let nanoseconds = import_jsbi.default.BigInt(nanosecondsParam);
  let dayLengthNs = 864e11;
  if (sign === 0)
    return { days: 0, nanoseconds: ZERO, dayLengthNs };
  if (!IsTemporalZonedDateTime(relativeTo)) {
    let days2;
    ({ quotient: days2, remainder: nanoseconds } = divmod(nanoseconds, import_jsbi.default.BigInt(dayLengthNs)));
    return { days: import_jsbi.default.toNumber(days2), nanoseconds, dayLengthNs };
  }
  const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);
  const start = GetSlot(relativeTo, INSTANT);
  const endNs = import_jsbi.default.add(startNs, nanoseconds);
  const end = new TemporalInstant(endNs);
  const timeZone2 = GetSlot(relativeTo, TIME_ZONE);
  const calendar2 = GetSlot(relativeTo, CALENDAR);
  const dtStart = BuiltinTimeZoneGetPlainDateTimeFor(timeZone2, start, calendar2);
  const dtEnd = BuiltinTimeZoneGetPlainDateTimeFor(timeZone2, end, calendar2);
  let { days } = DifferenceISODateTime(GetSlot(dtStart, ISO_YEAR), GetSlot(dtStart, ISO_MONTH), GetSlot(dtStart, ISO_DAY), GetSlot(dtStart, ISO_HOUR), GetSlot(dtStart, ISO_MINUTE), GetSlot(dtStart, ISO_SECOND), GetSlot(dtStart, ISO_MILLISECOND), GetSlot(dtStart, ISO_MICROSECOND), GetSlot(dtStart, ISO_NANOSECOND), GetSlot(dtEnd, ISO_YEAR), GetSlot(dtEnd, ISO_MONTH), GetSlot(dtEnd, ISO_DAY), GetSlot(dtEnd, ISO_HOUR), GetSlot(dtEnd, ISO_MINUTE), GetSlot(dtEnd, ISO_SECOND), GetSlot(dtEnd, ISO_MILLISECOND), GetSlot(dtEnd, ISO_MICROSECOND), GetSlot(dtEnd, ISO_NANOSECOND), calendar2, "day");
  let intermediateNs = AddZonedDateTime(start, timeZone2, calendar2, 0, 0, 0, days, 0, 0, 0, 0, 0, 0);
  if (sign === 1) {
    while (days > 0 && import_jsbi.default.greaterThan(intermediateNs, endNs)) {
      --days;
      intermediateNs = AddZonedDateTime(start, timeZone2, calendar2, 0, 0, 0, days, 0, 0, 0, 0, 0, 0);
    }
  }
  nanoseconds = import_jsbi.default.subtract(endNs, intermediateNs);
  let isOverflow = false;
  let relativeInstant = new TemporalInstant(intermediateNs);
  do {
    const oneDayFartherNs = AddZonedDateTime(relativeInstant, timeZone2, calendar2, 0, 0, 0, sign, 0, 0, 0, 0, 0, 0);
    const relativeNs = GetSlot(relativeInstant, EPOCHNANOSECONDS);
    dayLengthNs = import_jsbi.default.toNumber(import_jsbi.default.subtract(oneDayFartherNs, relativeNs));
    isOverflow = import_jsbi.default.greaterThan(import_jsbi.default.multiply(import_jsbi.default.subtract(nanoseconds, import_jsbi.default.BigInt(dayLengthNs)), import_jsbi.default.BigInt(sign)), ZERO);
    if (isOverflow) {
      nanoseconds = import_jsbi.default.subtract(nanoseconds, import_jsbi.default.BigInt(dayLengthNs));
      relativeInstant = new TemporalInstant(oneDayFartherNs);
      days += sign;
    }
  } while (isOverflow);
  return { days, nanoseconds, dayLengthNs: MathAbs(dayLengthNs) };
}
function BalanceDuration(daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, largestUnit, relativeTo = void 0) {
  let days = daysParam;
  let nanosecondsBigInt, microsecondsBigInt, millisecondsBigInt, secondsBigInt, minutesBigInt, hoursBigInt;
  if (IsTemporalZonedDateTime(relativeTo)) {
    const endNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), GetSlot(relativeTo, TIME_ZONE), GetSlot(relativeTo, CALENDAR), 0, 0, 0, days, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam);
    const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);
    nanosecondsBigInt = import_jsbi.default.subtract(endNs, startNs);
  } else {
    nanosecondsBigInt = TotalDurationNanoseconds(days, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, 0);
  }
  if (largestUnit === "year" || largestUnit === "month" || largestUnit === "week" || largestUnit === "day") {
    ({ days, nanoseconds: nanosecondsBigInt } = NanosecondsToDays(nanosecondsBigInt, relativeTo));
  } else {
    days = 0;
  }
  const sign = import_jsbi.default.lessThan(nanosecondsBigInt, ZERO) ? -1 : 1;
  nanosecondsBigInt = abs(nanosecondsBigInt);
  microsecondsBigInt = millisecondsBigInt = secondsBigInt = minutesBigInt = hoursBigInt = ZERO;
  switch (largestUnit) {
    case "year":
    case "month":
    case "week":
    case "day":
    case "hour":
      ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));
      ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));
      ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));
      ({ quotient: minutesBigInt, remainder: secondsBigInt } = divmod(secondsBigInt, SIXTY));
      ({ quotient: hoursBigInt, remainder: minutesBigInt } = divmod(minutesBigInt, SIXTY));
      break;
    case "minute":
      ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));
      ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));
      ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));
      ({ quotient: minutesBigInt, remainder: secondsBigInt } = divmod(secondsBigInt, SIXTY));
      break;
    case "second":
      ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));
      ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));
      ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));
      break;
    case "millisecond":
      ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));
      ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));
      break;
    case "microsecond":
      ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));
      break;
    case "nanosecond":
      break;
    default:
      throw new Error("assert not reached");
  }
  const hours = import_jsbi.default.toNumber(hoursBigInt) * sign;
  const minutes = import_jsbi.default.toNumber(minutesBigInt) * sign;
  const seconds = import_jsbi.default.toNumber(secondsBigInt) * sign;
  const milliseconds = import_jsbi.default.toNumber(millisecondsBigInt) * sign;
  const microseconds = import_jsbi.default.toNumber(microsecondsBigInt) * sign;
  const nanoseconds = import_jsbi.default.toNumber(nanosecondsBigInt) * sign;
  return { days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };
}
function UnbalanceDurationRelative(yearsParam, monthsParam, weeksParam, daysParam, largestUnit, relativeToParam) {
  let years = yearsParam;
  let months = monthsParam;
  let weeks = weeksParam;
  let days = daysParam;
  const TemporalDuration = GetIntrinsic("%Temporal.Duration%");
  const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);
  let calendar2;
  let relativeTo;
  if (relativeToParam) {
    relativeTo = ToTemporalDate(relativeToParam);
    calendar2 = GetSlot(relativeTo, CALENDAR);
  }
  const oneYear = new TemporalDuration(sign);
  const oneMonth = new TemporalDuration(0, sign);
  const oneWeek = new TemporalDuration(0, 0, sign);
  switch (largestUnit) {
    case "year":
      break;
    case "month":
      {
        if (!calendar2)
          throw new RangeError("a starting point is required for months balancing");
        const dateAdd = calendar2.dateAdd;
        const dateUntil = calendar2.dateUntil;
        let relativeToDateOnly = relativeTo;
        while (MathAbs(years) > 0) {
          const addOptions = ObjectCreate$2(null);
          const newRelativeTo = CalendarDateAdd(calendar2, relativeToDateOnly, oneYear, addOptions, dateAdd);
          const untilOptions = ObjectCreate$2(null);
          untilOptions.largestUnit = "month";
          const untilResult = CalendarDateUntil(calendar2, relativeToDateOnly, newRelativeTo, untilOptions, dateUntil);
          const oneYearMonths = GetSlot(untilResult, MONTHS);
          relativeToDateOnly = newRelativeTo;
          months += oneYearMonths;
          years -= sign;
        }
      }
      break;
    case "week":
      if (!calendar2)
        throw new RangeError("a starting point is required for weeks balancing");
      while (MathAbs(years) > 0) {
        let oneYearDays;
        ({ relativeTo, days: oneYearDays } = MoveRelativeDate(calendar2, relativeTo, oneYear));
        days += oneYearDays;
        years -= sign;
      }
      while (MathAbs(months) > 0) {
        let oneMonthDays;
        ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar2, relativeTo, oneMonth));
        days += oneMonthDays;
        months -= sign;
      }
      break;
    default:
      while (MathAbs(years) > 0) {
        if (!calendar2)
          throw new RangeError("a starting point is required for balancing calendar units");
        let oneYearDays;
        ({ relativeTo, days: oneYearDays } = MoveRelativeDate(calendar2, relativeTo, oneYear));
        days += oneYearDays;
        years -= sign;
      }
      while (MathAbs(months) > 0) {
        if (!calendar2)
          throw new RangeError("a starting point is required for balancing calendar units");
        let oneMonthDays;
        ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar2, relativeTo, oneMonth));
        days += oneMonthDays;
        months -= sign;
      }
      while (MathAbs(weeks) > 0) {
        if (!calendar2)
          throw new RangeError("a starting point is required for balancing calendar units");
        let oneWeekDays;
        ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar2, relativeTo, oneWeek));
        days += oneWeekDays;
        weeks -= sign;
      }
      break;
  }
  return { years, months, weeks, days };
}
function BalanceDurationRelative(yearsParam, monthsParam, weeksParam, daysParam, largestUnit, relativeToParam) {
  let years = yearsParam;
  let months = monthsParam;
  let weeks = weeksParam;
  let days = daysParam;
  const TemporalDuration = GetIntrinsic("%Temporal.Duration%");
  const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);
  if (sign === 0)
    return { years, months, weeks, days };
  let calendar2;
  let relativeTo;
  if (relativeToParam) {
    relativeTo = ToTemporalDate(relativeToParam);
    calendar2 = GetSlot(relativeTo, CALENDAR);
  }
  const oneYear = new TemporalDuration(sign);
  const oneMonth = new TemporalDuration(0, sign);
  const oneWeek = new TemporalDuration(0, 0, sign);
  switch (largestUnit) {
    case "year": {
      if (!calendar2)
        throw new RangeError("a starting point is required for years balancing");
      let newRelativeTo, oneYearDays;
      ({ relativeTo: newRelativeTo, days: oneYearDays } = MoveRelativeDate(calendar2, relativeTo, oneYear));
      while (MathAbs(days) >= MathAbs(oneYearDays)) {
        days -= oneYearDays;
        years += sign;
        relativeTo = newRelativeTo;
        ({ relativeTo: newRelativeTo, days: oneYearDays } = MoveRelativeDate(calendar2, relativeTo, oneYear));
      }
      let oneMonthDays;
      ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar2, relativeTo, oneMonth));
      while (MathAbs(days) >= MathAbs(oneMonthDays)) {
        days -= oneMonthDays;
        months += sign;
        relativeTo = newRelativeTo;
        ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar2, relativeTo, oneMonth));
      }
      const dateAdd = calendar2.dateAdd;
      const addOptions = ObjectCreate$2(null);
      newRelativeTo = CalendarDateAdd(calendar2, relativeTo, oneYear, addOptions, dateAdd);
      const dateUntil = calendar2.dateUntil;
      const untilOptions = ObjectCreate$2(null);
      untilOptions.largestUnit = "month";
      let untilResult = CalendarDateUntil(calendar2, relativeTo, newRelativeTo, untilOptions, dateUntil);
      let oneYearMonths = GetSlot(untilResult, MONTHS);
      while (MathAbs(months) >= MathAbs(oneYearMonths)) {
        months -= oneYearMonths;
        years += sign;
        relativeTo = newRelativeTo;
        const addOptions2 = ObjectCreate$2(null);
        newRelativeTo = CalendarDateAdd(calendar2, relativeTo, oneYear, addOptions2, dateAdd);
        const untilOptions2 = ObjectCreate$2(null);
        untilOptions2.largestUnit = "month";
        untilResult = CalendarDateUntil(calendar2, relativeTo, newRelativeTo, untilOptions2, dateUntil);
        oneYearMonths = GetSlot(untilResult, MONTHS);
      }
      break;
    }
    case "month": {
      if (!calendar2)
        throw new RangeError("a starting point is required for months balancing");
      let newRelativeTo, oneMonthDays;
      ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar2, relativeTo, oneMonth));
      while (MathAbs(days) >= MathAbs(oneMonthDays)) {
        days -= oneMonthDays;
        months += sign;
        relativeTo = newRelativeTo;
        ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar2, relativeTo, oneMonth));
      }
      break;
    }
    case "week": {
      if (!calendar2)
        throw new RangeError("a starting point is required for weeks balancing");
      let newRelativeTo, oneWeekDays;
      ({ relativeTo: newRelativeTo, days: oneWeekDays } = MoveRelativeDate(calendar2, relativeTo, oneWeek));
      while (MathAbs(days) >= MathAbs(oneWeekDays)) {
        days -= oneWeekDays;
        weeks += sign;
        relativeTo = newRelativeTo;
        ({ relativeTo: newRelativeTo, days: oneWeekDays } = MoveRelativeDate(calendar2, relativeTo, oneWeek));
      }
      break;
    }
  }
  return { years, months, weeks, days };
}
function CalculateOffsetShift(relativeTo, y, mon, w, d, h2, min, s3, ms, \u00B5s, ns) {
  if (IsTemporalZonedDateTime(relativeTo)) {
    const instant2 = GetSlot(relativeTo, INSTANT);
    const timeZone2 = GetSlot(relativeTo, TIME_ZONE);
    const calendar2 = GetSlot(relativeTo, CALENDAR);
    const offsetBefore = GetOffsetNanosecondsFor(timeZone2, instant2);
    const after = AddZonedDateTime(instant2, timeZone2, calendar2, y, mon, w, d, h2, min, s3, ms, \u00B5s, ns);
    const TemporalInstant = GetIntrinsic("%Temporal.Instant%");
    const instantAfter = new TemporalInstant(after);
    const offsetAfter = GetOffsetNanosecondsFor(timeZone2, instantAfter);
    return offsetAfter - offsetBefore;
  }
  return 0;
}
function CreateNegatedTemporalDuration(duration2) {
  const TemporalDuration = GetIntrinsic("%Temporal.Duration%");
  return new TemporalDuration(-GetSlot(duration2, YEARS), -GetSlot(duration2, MONTHS), -GetSlot(duration2, WEEKS), -GetSlot(duration2, DAYS), -GetSlot(duration2, HOURS), -GetSlot(duration2, MINUTES), -GetSlot(duration2, SECONDS), -GetSlot(duration2, MILLISECONDS), -GetSlot(duration2, MICROSECONDS), -GetSlot(duration2, NANOSECONDS));
}
function ConstrainToRange(value, min, max) {
  return MathMin(max, MathMax(min, value));
}
function ConstrainISODate(year, monthParam, dayParam) {
  const month = ConstrainToRange(monthParam, 1, 12);
  const day = ConstrainToRange(dayParam, 1, ISODaysInMonth(year, month));
  return { year, month, day };
}
function ConstrainTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {
  const hour = ConstrainToRange(hourParam, 0, 23);
  const minute = ConstrainToRange(minuteParam, 0, 59);
  const second = ConstrainToRange(secondParam, 0, 59);
  const millisecond = ConstrainToRange(millisecondParam, 0, 999);
  const microsecond = ConstrainToRange(microsecondParam, 0, 999);
  const nanosecond = ConstrainToRange(nanosecondParam, 0, 999);
  return { hour, minute, second, millisecond, microsecond, nanosecond };
}
function RejectToRange(value, min, max) {
  if (value < min || value > max)
    throw new RangeError(`value out of range: ${min} <= ${value} <= ${max}`);
}
function RejectISODate(year, month, day) {
  RejectToRange(month, 1, 12);
  RejectToRange(day, 1, ISODaysInMonth(year, month));
}
function RejectDateRange(year, month, day) {
  RejectDateTimeRange(year, month, day, 12, 0, 0, 0, 0, 0);
}
function RejectTime(hour, minute, second, millisecond, microsecond, nanosecond) {
  RejectToRange(hour, 0, 23);
  RejectToRange(minute, 0, 59);
  RejectToRange(second, 0, 59);
  RejectToRange(millisecond, 0, 999);
  RejectToRange(microsecond, 0, 999);
  RejectToRange(nanosecond, 0, 999);
}
function RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {
  RejectISODate(year, month, day);
  RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);
}
function RejectDateTimeRange(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {
  RejectToRange(year, YEAR_MIN, YEAR_MAX);
  if (year === YEAR_MIN && GetEpochFromISOParts(year, month, day + 1, hour, minute, second, millisecond, microsecond, nanosecond - 1) == null || year === YEAR_MAX && GetEpochFromISOParts(year, month, day - 1, hour, minute, second, millisecond, microsecond, nanosecond + 1) == null) {
    throw new RangeError("DateTime outside of supported range");
  }
}
function ValidateEpochNanoseconds(epochNanoseconds) {
  if (import_jsbi.default.lessThan(epochNanoseconds, NS_MIN) || import_jsbi.default.greaterThan(epochNanoseconds, NS_MAX)) {
    throw new RangeError("Instant outside of supported range");
  }
}
function RejectYearMonthRange(year, month) {
  RejectToRange(year, YEAR_MIN, YEAR_MAX);
  if (year === YEAR_MIN) {
    RejectToRange(month, 4, 12);
  } else if (year === YEAR_MAX) {
    RejectToRange(month, 1, 9);
  }
}
function RejectDuration(y, mon, w, d, h2, min, s3, ms, \u00B5s, ns) {
  const sign = DurationSign(y, mon, w, d, h2, min, s3, ms, \u00B5s, ns);
  for (const prop of [y, mon, w, d, h2, min, s3, ms, \u00B5s, ns]) {
    if (!NumberIsFinite(prop))
      throw new RangeError("infinite values not allowed as duration fields");
    const propSign = MathSign(prop);
    if (propSign !== 0 && propSign !== sign)
      throw new RangeError("mixed-sign values not allowed as duration fields");
  }
}
function DifferenceISODate(y1, m1, d1, y2, m2, d2, largestUnit) {
  switch (largestUnit) {
    case "year":
    case "month": {
      const sign = -CompareISODate(y1, m1, d1, y2, m2, d2);
      if (sign === 0)
        return { years: 0, months: 0, weeks: 0, days: 0 };
      const start = { year: y1, month: m1, day: d1 };
      const end = { year: y2, month: m2, day: d2 };
      let years = end.year - start.year;
      let mid = AddISODate(y1, m1, d1, years, 0, 0, 0, "constrain");
      let midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);
      if (midSign === 0) {
        return largestUnit === "year" ? { years, months: 0, weeks: 0, days: 0 } : { years: 0, months: years * 12, weeks: 0, days: 0 };
      }
      let months = end.month - start.month;
      if (midSign !== sign) {
        years -= sign;
        months += sign * 12;
      }
      mid = AddISODate(y1, m1, d1, years, months, 0, 0, "constrain");
      midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);
      if (midSign === 0) {
        return largestUnit === "year" ? { years, months, weeks: 0, days: 0 } : { years: 0, months: months + years * 12, weeks: 0, days: 0 };
      }
      if (midSign !== sign) {
        months -= sign;
        if (months === -sign) {
          years -= sign;
          months = 11 * sign;
        }
        mid = AddISODate(y1, m1, d1, years, months, 0, 0, "constrain");
        midSign = -CompareISODate(y1, m1, d1, mid.year, mid.month, mid.day);
      }
      let days = 0;
      if (mid.month === end.month) {
        days = end.day - mid.day;
      } else if (sign < 0) {
        days = -mid.day - (ISODaysInMonth(end.year, end.month) - end.day);
      } else {
        days = end.day + (ISODaysInMonth(mid.year, mid.month) - mid.day);
      }
      if (largestUnit === "month") {
        months += years * 12;
        years = 0;
      }
      return { years, months, weeks: 0, days };
    }
    case "week":
    case "day": {
      let larger, smaller, sign;
      if (CompareISODate(y1, m1, d1, y2, m2, d2) < 0) {
        smaller = { year: y1, month: m1, day: d1 };
        larger = { year: y2, month: m2, day: d2 };
        sign = 1;
      } else {
        smaller = { year: y2, month: m2, day: d2 };
        larger = { year: y1, month: m1, day: d1 };
        sign = -1;
      }
      let days = DayOfYear(larger.year, larger.month, larger.day) - DayOfYear(smaller.year, smaller.month, smaller.day);
      for (let year = smaller.year; year < larger.year; ++year) {
        days += LeapYear(year) ? 366 : 365;
      }
      let weeks = 0;
      if (largestUnit === "week") {
        weeks = MathFloor(days / 7);
        days %= 7;
      }
      weeks *= sign;
      days *= sign;
      return { years: 0, months: 0, weeks, days };
    }
    default:
      throw new Error("assert not reached");
  }
}
function DifferenceTime(h1, min1, s1, ms1, \u00B5s1, ns1, h2, min2, s22, ms2, \u00B5s2, ns2) {
  let hours = h2 - h1;
  let minutes = min2 - min1;
  let seconds = s22 - s1;
  let milliseconds = ms2 - ms1;
  let microseconds = \u00B5s2 - \u00B5s1;
  let nanoseconds = ns2 - ns1;
  const sign = DurationSign(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);
  hours *= sign;
  minutes *= sign;
  seconds *= sign;
  milliseconds *= sign;
  microseconds *= sign;
  nanoseconds *= sign;
  let deltaDays = 0;
  ({
    deltaDays,
    hour: hours,
    minute: minutes,
    second: seconds,
    millisecond: milliseconds,
    microsecond: microseconds,
    nanosecond: nanoseconds
  } = BalanceTime(hours, minutes, seconds, milliseconds, microseconds, nanoseconds));
  deltaDays *= sign;
  hours *= sign;
  minutes *= sign;
  seconds *= sign;
  milliseconds *= sign;
  microseconds *= sign;
  nanoseconds *= sign;
  return { deltaDays, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };
}
function DifferenceInstant(ns1, ns2, increment, unit, roundingMode) {
  const diff = import_jsbi.default.subtract(ns2, ns1);
  const remainder = import_jsbi.default.remainder(diff, import_jsbi.default.BigInt(864e11));
  const wholeDays = import_jsbi.default.subtract(diff, remainder);
  const roundedRemainder = RoundNumberToIncrement(remainder, nsPerTimeUnit[unit] * increment, roundingMode);
  const roundedDiff = import_jsbi.default.add(wholeDays, roundedRemainder);
  const nanoseconds = import_jsbi.default.toNumber(import_jsbi.default.remainder(roundedDiff, THOUSAND));
  const microseconds = import_jsbi.default.toNumber(import_jsbi.default.remainder(import_jsbi.default.divide(roundedDiff, THOUSAND), THOUSAND));
  const milliseconds = import_jsbi.default.toNumber(import_jsbi.default.remainder(import_jsbi.default.divide(roundedDiff, MILLION), THOUSAND));
  const seconds = import_jsbi.default.toNumber(import_jsbi.default.divide(roundedDiff, BILLION));
  return { seconds, milliseconds, microseconds, nanoseconds };
}
function DifferenceISODateTime(y1Param, mon1Param, d1Param, h1, min1, s1, ms1, \u00B5s1, ns1, y2, mon2, d2, h2, min2, s22, ms2, \u00B5s2, ns2, calendar2, largestUnit, options = ObjectCreate$2(null)) {
  let y1 = y1Param;
  let mon1 = mon1Param;
  let d1 = d1Param;
  let { deltaDays, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(h1, min1, s1, ms1, \u00B5s1, ns1, h2, min2, s22, ms2, \u00B5s2, ns2);
  const timeSign = DurationSign(0, 0, 0, deltaDays, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);
  ({ year: y1, month: mon1, day: d1 } = BalanceISODate(y1, mon1, d1 + deltaDays));
  const dateSign = CompareISODate(y2, mon2, d2, y1, mon1, d1);
  if (dateSign === -timeSign) {
    ({ year: y1, month: mon1, day: d1 } = BalanceISODate(y1, mon1, d1 - timeSign));
    ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(-timeSign, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));
  }
  const date1 = CreateTemporalDate(y1, mon1, d1, calendar2);
  const date2 = CreateTemporalDate(y2, mon2, d2, calendar2);
  const dateLargestUnit = LargerOfTwoTemporalUnits("day", largestUnit);
  const untilOptions = __spreadProps(__spreadValues({}, options), { largestUnit: dateLargestUnit });
  let { years, months, weeks, days } = CalendarDateUntil(calendar2, date1, date2, untilOptions);
  ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));
  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };
}
function DifferenceZonedDateTime(ns1, ns2, timeZone2, calendar2, largestUnit, options) {
  const nsDiff = import_jsbi.default.subtract(ns2, ns1);
  if (import_jsbi.default.equal(nsDiff, ZERO)) {
    return {
      years: 0,
      months: 0,
      weeks: 0,
      days: 0,
      hours: 0,
      minutes: 0,
      seconds: 0,
      milliseconds: 0,
      microseconds: 0,
      nanoseconds: 0
    };
  }
  const TemporalInstant = GetIntrinsic("%Temporal.Instant%");
  const start = new TemporalInstant(ns1);
  const end = new TemporalInstant(ns2);
  const dtStart = BuiltinTimeZoneGetPlainDateTimeFor(timeZone2, start, calendar2);
  const dtEnd = BuiltinTimeZoneGetPlainDateTimeFor(timeZone2, end, calendar2);
  let { years, months, weeks, days } = DifferenceISODateTime(GetSlot(dtStart, ISO_YEAR), GetSlot(dtStart, ISO_MONTH), GetSlot(dtStart, ISO_DAY), GetSlot(dtStart, ISO_HOUR), GetSlot(dtStart, ISO_MINUTE), GetSlot(dtStart, ISO_SECOND), GetSlot(dtStart, ISO_MILLISECOND), GetSlot(dtStart, ISO_MICROSECOND), GetSlot(dtStart, ISO_NANOSECOND), GetSlot(dtEnd, ISO_YEAR), GetSlot(dtEnd, ISO_MONTH), GetSlot(dtEnd, ISO_DAY), GetSlot(dtEnd, ISO_HOUR), GetSlot(dtEnd, ISO_MINUTE), GetSlot(dtEnd, ISO_SECOND), GetSlot(dtEnd, ISO_MILLISECOND), GetSlot(dtEnd, ISO_MICROSECOND), GetSlot(dtEnd, ISO_NANOSECOND), calendar2, largestUnit, options);
  const intermediateNs = AddZonedDateTime(start, timeZone2, calendar2, years, months, weeks, 0, 0, 0, 0, 0, 0, 0);
  let timeRemainderNs = import_jsbi.default.subtract(ns2, intermediateNs);
  const intermediate = CreateTemporalZonedDateTime(intermediateNs, timeZone2, calendar2);
  ({ nanoseconds: timeRemainderNs, days } = NanosecondsToDays(timeRemainderNs, intermediate));
  const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, 0, 0, 0, import_jsbi.default.toNumber(timeRemainderNs), "hour");
  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };
}
function AddISODate(yearParam, monthParam, dayParam, yearsParam, monthsParam, weeksParam, daysParam, overflow) {
  let year = yearParam;
  let month = monthParam;
  let day = dayParam;
  let years = yearsParam;
  let months = monthsParam;
  let weeks = weeksParam;
  let days = daysParam;
  year += years;
  month += months;
  ({ year, month } = BalanceISOYearMonth(year, month));
  ({ year, month, day } = RegulateISODate(year, month, day, overflow));
  days += 7 * weeks;
  day += days;
  ({ year, month, day } = BalanceISODate(year, month, day));
  return { year, month, day };
}
function AddTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds) {
  let hour = hourParam;
  let minute = minuteParam;
  let second = secondParam;
  let millisecond = millisecondParam;
  let microsecond = microsecondParam;
  let nanosecond = nanosecondParam;
  hour += hours;
  minute += minutes;
  second += seconds;
  millisecond += milliseconds;
  microsecond += microseconds;
  nanosecond += nanoseconds;
  let deltaDays = 0;
  ({ deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond));
  return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };
}
function AddDuration(y1, mon1, w1, d1, h1, min1, s1, ms1, \u00B5s1, ns1, y2, mon2, w2, d2, h2, min2, s22, ms2, \u00B5s2, ns2, relativeTo) {
  const largestUnit1 = DefaultTemporalLargestUnit(y1, mon1, w1, d1, h1, min1, s1, ms1, \u00B5s1, ns1);
  const largestUnit2 = DefaultTemporalLargestUnit(y2, mon2, w2, d2, h2, min2, s22, ms2, \u00B5s2, ns2);
  const largestUnit = LargerOfTwoTemporalUnits(largestUnit1, largestUnit2);
  let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;
  if (!relativeTo) {
    if (largestUnit === "year" || largestUnit === "month" || largestUnit === "week") {
      throw new RangeError("relativeTo is required for years, months, or weeks arithmetic");
    }
    years = months = weeks = 0;
    ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(d1 + d2, h1 + h2, min1 + min2, s1 + s22, ms1 + ms2, \u00B5s1 + \u00B5s2, ns1 + ns2, largestUnit));
  } else if (IsTemporalDate(relativeTo)) {
    const TemporalDuration = GetIntrinsic("%Temporal.Duration%");
    const calendar2 = GetSlot(relativeTo, CALENDAR);
    const dateDuration1 = new TemporalDuration(y1, mon1, w1, d1, 0, 0, 0, 0, 0, 0);
    const dateDuration2 = new TemporalDuration(y2, mon2, w2, d2, 0, 0, 0, 0, 0, 0);
    const dateAdd = calendar2.dateAdd;
    const firstAddOptions = ObjectCreate$2(null);
    const intermediate = CalendarDateAdd(calendar2, relativeTo, dateDuration1, firstAddOptions, dateAdd);
    const secondAddOptions = ObjectCreate$2(null);
    const end = CalendarDateAdd(calendar2, intermediate, dateDuration2, secondAddOptions, dateAdd);
    const dateLargestUnit = LargerOfTwoTemporalUnits("day", largestUnit);
    const differenceOptions = ObjectCreate$2(null);
    differenceOptions.largestUnit = dateLargestUnit;
    ({ years, months, weeks, days } = CalendarDateUntil(calendar2, relativeTo, end, differenceOptions));
    ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, h1 + h2, min1 + min2, s1 + s22, ms1 + ms2, \u00B5s1 + \u00B5s2, ns1 + ns2, largestUnit));
  } else {
    const TemporalInstant = GetIntrinsic("%Temporal.Instant%");
    const timeZone2 = GetSlot(relativeTo, TIME_ZONE);
    const calendar2 = GetSlot(relativeTo, CALENDAR);
    const intermediateNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone2, calendar2, y1, mon1, w1, d1, h1, min1, s1, ms1, \u00B5s1, ns1);
    const endNs = AddZonedDateTime(new TemporalInstant(intermediateNs), timeZone2, calendar2, y2, mon2, w2, d2, h2, min2, s22, ms2, \u00B5s2, ns2);
    if (largestUnit !== "year" && largestUnit !== "month" && largestUnit !== "week" && largestUnit !== "day") {
      years = 0;
      months = 0;
      weeks = 0;
      days = 0;
      ({ seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(GetSlot(relativeTo, EPOCHNANOSECONDS), endNs, 1, "nanosecond", "halfExpand"));
      ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));
    } else {
      ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceZonedDateTime(GetSlot(relativeTo, EPOCHNANOSECONDS), endNs, timeZone2, calendar2, largestUnit));
    }
  }
  RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);
  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };
}
function AddInstant(epochNanoseconds, h2, min, s3, ms, \u00B5s, ns) {
  let sum = ZERO;
  sum = import_jsbi.default.add(sum, import_jsbi.default.BigInt(ns));
  sum = import_jsbi.default.add(sum, import_jsbi.default.multiply(import_jsbi.default.BigInt(\u00B5s), THOUSAND));
  sum = import_jsbi.default.add(sum, import_jsbi.default.multiply(import_jsbi.default.BigInt(ms), MILLION));
  sum = import_jsbi.default.add(sum, import_jsbi.default.multiply(import_jsbi.default.BigInt(s3), BILLION));
  sum = import_jsbi.default.add(sum, import_jsbi.default.multiply(import_jsbi.default.BigInt(min), import_jsbi.default.BigInt(60 * 1e9)));
  sum = import_jsbi.default.add(sum, import_jsbi.default.multiply(import_jsbi.default.BigInt(h2), import_jsbi.default.BigInt(60 * 60 * 1e9)));
  const result = import_jsbi.default.add(epochNanoseconds, sum);
  ValidateEpochNanoseconds(result);
  return result;
}
function AddDateTime(year, month, day, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, calendar2, years, months, weeks, daysParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options) {
  let days = daysParam;
  let { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);
  days += deltaDays;
  const TemporalDuration = GetIntrinsic("%Temporal.Duration%");
  const datePart = CreateTemporalDate(year, month, day, calendar2);
  const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);
  const addedDate = CalendarDateAdd(calendar2, datePart, dateDuration, options);
  return {
    year: GetSlot(addedDate, ISO_YEAR),
    month: GetSlot(addedDate, ISO_MONTH),
    day: GetSlot(addedDate, ISO_DAY),
    hour,
    minute,
    second,
    millisecond,
    microsecond,
    nanosecond
  };
}
function AddZonedDateTime(instant2, timeZone2, calendar2, years, months, weeks, days, h2, min, s3, ms, \u00B5s, ns, options) {
  const TemporalDuration = GetIntrinsic("%Temporal.Duration%");
  if (DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0) === 0) {
    return AddInstant(GetSlot(instant2, EPOCHNANOSECONDS), h2, min, s3, ms, \u00B5s, ns);
  }
  const dt = BuiltinTimeZoneGetPlainDateTimeFor(timeZone2, instant2, calendar2);
  const datePart = CreateTemporalDate(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), calendar2);
  const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);
  const addedDate = CalendarDateAdd(calendar2, datePart, dateDuration, options);
  const dtIntermediate = CreateTemporalDateTime(GetSlot(addedDate, ISO_YEAR), GetSlot(addedDate, ISO_MONTH), GetSlot(addedDate, ISO_DAY), GetSlot(dt, ISO_HOUR), GetSlot(dt, ISO_MINUTE), GetSlot(dt, ISO_SECOND), GetSlot(dt, ISO_MILLISECOND), GetSlot(dt, ISO_MICROSECOND), GetSlot(dt, ISO_NANOSECOND), calendar2);
  const instantIntermediate = BuiltinTimeZoneGetInstantFor(timeZone2, dtIntermediate, "compatible");
  return AddInstant(GetSlot(instantIntermediate, EPOCHNANOSECONDS), h2, min, s3, ms, \u00B5s, ns);
}
function RoundNumberToIncrement(quantity, increment, mode) {
  if (increment === 1)
    return quantity;
  let { quotient, remainder } = divmod(quantity, import_jsbi.default.BigInt(increment));
  if (import_jsbi.default.equal(remainder, ZERO))
    return quantity;
  const sign = import_jsbi.default.lessThan(remainder, ZERO) ? -1 : 1;
  switch (mode) {
    case "ceil":
      if (sign > 0)
        quotient = import_jsbi.default.add(quotient, import_jsbi.default.BigInt(sign));
      break;
    case "floor":
      if (sign < 0)
        quotient = import_jsbi.default.add(quotient, import_jsbi.default.BigInt(sign));
      break;
    case "trunc":
      break;
    case "halfExpand":
      if (import_jsbi.default.toNumber(abs(import_jsbi.default.multiply(remainder, import_jsbi.default.BigInt(2)))) >= increment) {
        quotient = import_jsbi.default.add(quotient, import_jsbi.default.BigInt(sign));
      }
      break;
  }
  return import_jsbi.default.multiply(quotient, import_jsbi.default.BigInt(increment));
}
function RoundInstant(epochNs, increment, unit, roundingMode) {
  let remainder = import_jsbi.default.remainder(epochNs, import_jsbi.default.BigInt(864e11));
  if (import_jsbi.default.lessThan(remainder, ZERO))
    remainder = import_jsbi.default.add(remainder, import_jsbi.default.BigInt(864e11));
  const wholeDays = import_jsbi.default.subtract(epochNs, remainder);
  const roundedRemainder = RoundNumberToIncrement(remainder, nsPerTimeUnit[unit] * increment, roundingMode);
  return import_jsbi.default.add(wholeDays, roundedRemainder);
}
function RoundISODateTime(yearParam, monthParam, dayParam, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, increment, unit, roundingMode, dayLengthNs = 864e11) {
  const { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = RoundTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, increment, unit, roundingMode, dayLengthNs);
  const { year, month, day } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);
  return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };
}
function RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode, dayLengthNs = 864e11) {
  let quantity = ZERO;
  switch (unit) {
    case "day":
    case "hour":
      quantity = import_jsbi.default.BigInt(hour);
    case "minute":
      quantity = import_jsbi.default.add(import_jsbi.default.multiply(quantity, SIXTY), import_jsbi.default.BigInt(minute));
    case "second":
      quantity = import_jsbi.default.add(import_jsbi.default.multiply(quantity, SIXTY), import_jsbi.default.BigInt(second));
    case "millisecond":
      quantity = import_jsbi.default.add(import_jsbi.default.multiply(quantity, THOUSAND), import_jsbi.default.BigInt(millisecond));
    case "microsecond":
      quantity = import_jsbi.default.add(import_jsbi.default.multiply(quantity, THOUSAND), import_jsbi.default.BigInt(microsecond));
    case "nanosecond":
      quantity = import_jsbi.default.add(import_jsbi.default.multiply(quantity, THOUSAND), import_jsbi.default.BigInt(nanosecond));
  }
  const nsPerUnit = unit === "day" ? dayLengthNs : nsPerTimeUnit[unit];
  const rounded = RoundNumberToIncrement(quantity, nsPerUnit * increment, roundingMode);
  const result = import_jsbi.default.toNumber(import_jsbi.default.divide(rounded, import_jsbi.default.BigInt(nsPerUnit)));
  switch (unit) {
    case "day":
      return { deltaDays: result, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };
    case "hour":
      return BalanceTime(result, 0, 0, 0, 0, 0);
    case "minute":
      return BalanceTime(hour, result, 0, 0, 0, 0);
    case "second":
      return BalanceTime(hour, minute, result, 0, 0, 0);
    case "millisecond":
      return BalanceTime(hour, minute, second, result, 0, 0);
    case "microsecond":
      return BalanceTime(hour, minute, second, millisecond, result, 0);
    case "nanosecond":
      return BalanceTime(hour, minute, second, millisecond, microsecond, result);
    default:
      throw new Error(`Invalid unit ${unit}`);
  }
}
function DaysUntil(earlier, later) {
  return DifferenceISODate(GetSlot(earlier, ISO_YEAR), GetSlot(earlier, ISO_MONTH), GetSlot(earlier, ISO_DAY), GetSlot(later, ISO_YEAR), GetSlot(later, ISO_MONTH), GetSlot(later, ISO_DAY), "day").days;
}
function MoveRelativeDate(calendar2, relativeToParam, duration2) {
  const options = ObjectCreate$2(null);
  const later = CalendarDateAdd(calendar2, relativeToParam, duration2, options);
  const days = DaysUntil(relativeToParam, later);
  return { relativeTo: later, days };
}
function MoveRelativeZonedDateTime(relativeTo, years, months, weeks, days) {
  const timeZone2 = GetSlot(relativeTo, TIME_ZONE);
  const calendar2 = GetSlot(relativeTo, CALENDAR);
  const intermediateNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone2, calendar2, years, months, weeks, days, 0, 0, 0, 0, 0, 0);
  return CreateTemporalZonedDateTime(intermediateNs, timeZone2, calendar2);
}
function AdjustRoundedDurationDays(yearsParam, monthsParam, weeksParam, daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, increment, unit, roundingMode, relativeTo) {
  let years = yearsParam;
  let months = monthsParam;
  let weeks = weeksParam;
  let days = daysParam;
  let hours = hoursParam;
  let minutes = minutesParam;
  let seconds = secondsParam;
  let milliseconds = millisecondsParam;
  let microseconds = microsecondsParam;
  let nanoseconds = nanosecondsParam;
  if (!IsTemporalZonedDateTime(relativeTo) || unit === "year" || unit === "month" || unit === "week" || unit === "day" || unit === "nanosecond" && increment === 1) {
    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };
  }
  let timeRemainderNs = TotalDurationNanoseconds(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 0);
  const direction = MathSign(import_jsbi.default.toNumber(timeRemainderNs));
  const timeZone2 = GetSlot(relativeTo, TIME_ZONE);
  const calendar2 = GetSlot(relativeTo, CALENDAR);
  const dayStart = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone2, calendar2, years, months, weeks, days, 0, 0, 0, 0, 0, 0);
  const TemporalInstant = GetIntrinsic("%Temporal.Instant%");
  const dayEnd = AddZonedDateTime(new TemporalInstant(dayStart), timeZone2, calendar2, 0, 0, 0, direction, 0, 0, 0, 0, 0, 0);
  const dayLengthNs = import_jsbi.default.subtract(dayEnd, dayStart);
  if (import_jsbi.default.greaterThanOrEqual(import_jsbi.default.multiply(import_jsbi.default.subtract(timeRemainderNs, dayLengthNs), import_jsbi.default.BigInt(direction)), ZERO)) {
    ({ years, months, weeks, days } = AddDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, 0, 0, 0, direction, 0, 0, 0, 0, 0, 0, relativeTo));
    timeRemainderNs = RoundInstant(import_jsbi.default.subtract(timeRemainderNs, dayLengthNs), increment, unit, roundingMode);
    ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, 0, 0, 0, import_jsbi.default.toNumber(timeRemainderNs), "hour"));
  }
  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };
}
function RoundDuration(yearsParam, monthsParam, weeksParam, daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, increment, unit, roundingMode, relativeToParam = void 0) {
  let years = yearsParam;
  let months = monthsParam;
  let weeks = weeksParam;
  let days = daysParam;
  let hours = hoursParam;
  let minutes = minutesParam;
  let seconds = secondsParam;
  let milliseconds = millisecondsParam;
  let microseconds = microsecondsParam;
  let nanoseconds = import_jsbi.default.BigInt(nanosecondsParam);
  const TemporalDuration = GetIntrinsic("%Temporal.Duration%");
  let calendar2, zdtRelative;
  let relativeTo = relativeToParam;
  if (relativeTo) {
    if (IsTemporalZonedDateTime(relativeTo)) {
      zdtRelative = relativeTo;
      relativeTo = ToTemporalDate(relativeTo);
    } else if (!IsTemporalDate(relativeTo)) {
      throw new TypeError("starting point must be PlainDate or ZonedDateTime");
    }
    calendar2 = GetSlot(relativeTo, CALENDAR);
  }
  let dayLengthNs;
  if (unit === "year" || unit === "month" || unit === "week" || unit === "day") {
    nanoseconds = TotalDurationNanoseconds(0, hours, minutes, seconds, milliseconds, microseconds, nanosecondsParam, 0);
    let intermediate;
    if (zdtRelative) {
      intermediate = MoveRelativeZonedDateTime(zdtRelative, years, months, weeks, days);
    }
    let deltaDays;
    let dayLength;
    ({ days: deltaDays, nanoseconds, dayLengthNs: dayLength } = NanosecondsToDays(nanoseconds, intermediate));
    dayLengthNs = import_jsbi.default.BigInt(dayLength);
    days += deltaDays;
    hours = minutes = seconds = milliseconds = microseconds = 0;
  }
  let total;
  switch (unit) {
    case "year": {
      if (!calendar2)
        throw new RangeError("A starting point is required for years rounding");
      const yearsDuration = new TemporalDuration(years);
      const dateAdd = calendar2.dateAdd;
      const firstAddOptions = ObjectCreate$2(null);
      const yearsLater = CalendarDateAdd(calendar2, relativeTo, yearsDuration, firstAddOptions, dateAdd);
      const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);
      const secondAddOptions = ObjectCreate$2(null);
      const yearsMonthsWeeksLater = CalendarDateAdd(calendar2, relativeTo, yearsMonthsWeeks, secondAddOptions, dateAdd);
      const monthsWeeksInDays = DaysUntil(yearsLater, yearsMonthsWeeksLater);
      relativeTo = yearsLater;
      days += monthsWeeksInDays;
      const thirdAddOptions = ObjectCreate$2(null);
      const daysLater = CalendarDateAdd(calendar2, relativeTo, { days }, thirdAddOptions, dateAdd);
      const untilOptions = ObjectCreate$2(null);
      untilOptions.largestUnit = "year";
      const yearsPassed = CalendarDateUntil(calendar2, relativeTo, daysLater, untilOptions).years;
      years += yearsPassed;
      const oldRelativeTo = relativeTo;
      const fourthAddOptions = ObjectCreate$2(null);
      relativeTo = CalendarDateAdd(calendar2, relativeTo, { years: yearsPassed }, fourthAddOptions, dateAdd);
      const daysPassed = DaysUntil(oldRelativeTo, relativeTo);
      days -= daysPassed;
      const oneYear = new TemporalDuration(days < 0 ? -1 : 1);
      let { days: oneYearDays } = MoveRelativeDate(calendar2, relativeTo, oneYear);
      oneYearDays = MathAbs(oneYearDays);
      const divisor = import_jsbi.default.multiply(import_jsbi.default.BigInt(oneYearDays), dayLengthNs);
      nanoseconds = import_jsbi.default.add(import_jsbi.default.add(import_jsbi.default.multiply(divisor, import_jsbi.default.BigInt(years)), import_jsbi.default.multiply(import_jsbi.default.BigInt(days), dayLengthNs)), nanoseconds);
      const rounded = RoundNumberToIncrement(nanoseconds, import_jsbi.default.toNumber(import_jsbi.default.multiply(divisor, import_jsbi.default.BigInt(increment))), roundingMode);
      total = import_jsbi.default.toNumber(nanoseconds) / import_jsbi.default.toNumber(divisor);
      years = import_jsbi.default.toNumber(import_jsbi.default.divide(rounded, divisor));
      nanoseconds = ZERO;
      months = weeks = days = 0;
      break;
    }
    case "month": {
      if (!calendar2)
        throw new RangeError("A starting point is required for months rounding");
      const yearsMonths = new TemporalDuration(years, months);
      const dateAdd = calendar2.dateAdd;
      const firstAddOptions = ObjectCreate$2(null);
      const yearsMonthsLater = CalendarDateAdd(calendar2, relativeTo, yearsMonths, firstAddOptions, dateAdd);
      const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);
      const secondAddOptions = ObjectCreate$2(null);
      const yearsMonthsWeeksLater = CalendarDateAdd(calendar2, relativeTo, yearsMonthsWeeks, secondAddOptions, dateAdd);
      const weeksInDays = DaysUntil(yearsMonthsLater, yearsMonthsWeeksLater);
      relativeTo = yearsMonthsLater;
      days += weeksInDays;
      const sign = MathSign(days);
      const oneMonth = new TemporalDuration(0, days < 0 ? -1 : 1);
      let oneMonthDays;
      ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar2, relativeTo, oneMonth));
      while (MathAbs(days) >= MathAbs(oneMonthDays)) {
        months += sign;
        days -= oneMonthDays;
        ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar2, relativeTo, oneMonth));
      }
      oneMonthDays = MathAbs(oneMonthDays);
      const divisor = import_jsbi.default.multiply(import_jsbi.default.BigInt(oneMonthDays), dayLengthNs);
      nanoseconds = import_jsbi.default.add(import_jsbi.default.add(import_jsbi.default.multiply(divisor, import_jsbi.default.BigInt(months)), import_jsbi.default.multiply(import_jsbi.default.BigInt(days), dayLengthNs)), nanoseconds);
      const rounded = RoundNumberToIncrement(nanoseconds, import_jsbi.default.toNumber(import_jsbi.default.multiply(divisor, import_jsbi.default.BigInt(increment))), roundingMode);
      total = import_jsbi.default.toNumber(nanoseconds) / import_jsbi.default.toNumber(divisor);
      months = import_jsbi.default.toNumber(import_jsbi.default.divide(rounded, divisor));
      nanoseconds = ZERO;
      weeks = days = 0;
      break;
    }
    case "week": {
      if (!calendar2)
        throw new RangeError("A starting point is required for weeks rounding");
      const sign = MathSign(days);
      const oneWeek = new TemporalDuration(0, 0, days < 0 ? -1 : 1);
      let oneWeekDays;
      ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar2, relativeTo, oneWeek));
      while (MathAbs(days) >= MathAbs(oneWeekDays)) {
        weeks += sign;
        days -= oneWeekDays;
        ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar2, relativeTo, oneWeek));
      }
      oneWeekDays = MathAbs(oneWeekDays);
      const divisor = import_jsbi.default.multiply(import_jsbi.default.BigInt(oneWeekDays), dayLengthNs);
      nanoseconds = import_jsbi.default.add(import_jsbi.default.add(import_jsbi.default.multiply(divisor, import_jsbi.default.BigInt(weeks)), import_jsbi.default.multiply(import_jsbi.default.BigInt(days), dayLengthNs)), nanoseconds);
      const rounded = RoundNumberToIncrement(nanoseconds, import_jsbi.default.toNumber(import_jsbi.default.multiply(divisor, import_jsbi.default.BigInt(increment))), roundingMode);
      total = import_jsbi.default.toNumber(nanoseconds) / import_jsbi.default.toNumber(divisor);
      weeks = import_jsbi.default.toNumber(import_jsbi.default.divide(rounded, divisor));
      nanoseconds = ZERO;
      days = 0;
      break;
    }
    case "day": {
      const divisor = dayLengthNs;
      nanoseconds = import_jsbi.default.add(import_jsbi.default.multiply(divisor, import_jsbi.default.BigInt(days)), nanoseconds);
      const rounded = RoundNumberToIncrement(nanoseconds, import_jsbi.default.toNumber(import_jsbi.default.multiply(divisor, import_jsbi.default.BigInt(increment))), roundingMode);
      total = import_jsbi.default.toNumber(nanoseconds) / import_jsbi.default.toNumber(divisor);
      days = import_jsbi.default.toNumber(import_jsbi.default.divide(rounded, divisor));
      nanoseconds = ZERO;
      break;
    }
    case "hour": {
      const divisor = 36e11;
      let allNanoseconds = import_jsbi.default.multiply(import_jsbi.default.BigInt(hours), import_jsbi.default.BigInt(36e11));
      allNanoseconds = import_jsbi.default.add(allNanoseconds, import_jsbi.default.multiply(import_jsbi.default.BigInt(minutes), import_jsbi.default.BigInt(6e10)));
      allNanoseconds = import_jsbi.default.add(allNanoseconds, import_jsbi.default.multiply(import_jsbi.default.BigInt(seconds), BILLION));
      allNanoseconds = import_jsbi.default.add(allNanoseconds, import_jsbi.default.multiply(import_jsbi.default.BigInt(milliseconds), MILLION));
      allNanoseconds = import_jsbi.default.add(allNanoseconds, import_jsbi.default.multiply(import_jsbi.default.BigInt(microseconds), THOUSAND));
      allNanoseconds = import_jsbi.default.add(allNanoseconds, nanoseconds);
      total = import_jsbi.default.toNumber(allNanoseconds) / divisor;
      const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);
      hours = import_jsbi.default.toNumber(import_jsbi.default.divide(rounded, import_jsbi.default.BigInt(divisor)));
      nanoseconds = ZERO;
      minutes = seconds = milliseconds = microseconds = 0;
      break;
    }
    case "minute": {
      const divisor = 6e10;
      let allNanoseconds = import_jsbi.default.multiply(import_jsbi.default.BigInt(minutes), import_jsbi.default.BigInt(6e10));
      allNanoseconds = import_jsbi.default.add(allNanoseconds, import_jsbi.default.multiply(import_jsbi.default.BigInt(seconds), BILLION));
      allNanoseconds = import_jsbi.default.add(allNanoseconds, import_jsbi.default.multiply(import_jsbi.default.BigInt(milliseconds), MILLION));
      allNanoseconds = import_jsbi.default.add(allNanoseconds, import_jsbi.default.multiply(import_jsbi.default.BigInt(microseconds), THOUSAND));
      allNanoseconds = import_jsbi.default.add(allNanoseconds, nanoseconds);
      total = import_jsbi.default.toNumber(allNanoseconds) / divisor;
      const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);
      minutes = import_jsbi.default.toNumber(import_jsbi.default.divide(rounded, import_jsbi.default.BigInt(divisor)));
      nanoseconds = ZERO;
      seconds = milliseconds = microseconds = 0;
      break;
    }
    case "second": {
      const divisor = 1e9;
      let allNanoseconds = import_jsbi.default.multiply(import_jsbi.default.BigInt(seconds), BILLION);
      allNanoseconds = import_jsbi.default.add(allNanoseconds, import_jsbi.default.multiply(import_jsbi.default.BigInt(milliseconds), MILLION));
      allNanoseconds = import_jsbi.default.add(allNanoseconds, import_jsbi.default.multiply(import_jsbi.default.BigInt(microseconds), THOUSAND));
      allNanoseconds = import_jsbi.default.add(allNanoseconds, nanoseconds);
      total = import_jsbi.default.toNumber(allNanoseconds) / divisor;
      const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);
      seconds = import_jsbi.default.toNumber(import_jsbi.default.divide(rounded, import_jsbi.default.BigInt(divisor)));
      nanoseconds = ZERO;
      milliseconds = microseconds = 0;
      break;
    }
    case "millisecond": {
      const divisor = 1e6;
      let allNanoseconds = import_jsbi.default.multiply(import_jsbi.default.BigInt(milliseconds), MILLION);
      allNanoseconds = import_jsbi.default.add(allNanoseconds, import_jsbi.default.multiply(import_jsbi.default.BigInt(microseconds), THOUSAND));
      allNanoseconds = import_jsbi.default.add(allNanoseconds, nanoseconds);
      total = import_jsbi.default.toNumber(allNanoseconds) / divisor;
      const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);
      milliseconds = import_jsbi.default.toNumber(import_jsbi.default.divide(rounded, import_jsbi.default.BigInt(divisor)));
      nanoseconds = ZERO;
      microseconds = 0;
      break;
    }
    case "microsecond": {
      const divisor = 1e3;
      let allNanoseconds = import_jsbi.default.multiply(import_jsbi.default.BigInt(microseconds), THOUSAND);
      allNanoseconds = import_jsbi.default.add(allNanoseconds, nanoseconds);
      total = import_jsbi.default.toNumber(allNanoseconds) / divisor;
      const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);
      microseconds = import_jsbi.default.toNumber(import_jsbi.default.divide(rounded, import_jsbi.default.BigInt(divisor)));
      nanoseconds = ZERO;
      break;
    }
    case "nanosecond": {
      total = import_jsbi.default.toNumber(nanoseconds);
      nanoseconds = RoundNumberToIncrement(nanoseconds, increment, roundingMode);
      break;
    }
  }
  return {
    years,
    months,
    weeks,
    days,
    hours,
    minutes,
    seconds,
    milliseconds,
    microseconds,
    nanoseconds: import_jsbi.default.toNumber(nanoseconds),
    total
  };
}
function CompareISODate(y1, m1, d1, y2, m2, d2) {
  for (const [x2, y] of [
    [y1, y2],
    [m1, m2],
    [d1, d2]
  ]) {
    if (x2 !== y)
      return ComparisonResult(x2 - y);
  }
  return 0;
}
function NonNegativeModulo(x2, y) {
  let result = x2 % y;
  if (ObjectIs(result, -0))
    return 0;
  if (result < 0)
    result += y;
  return result;
}
function ToBigIntExternal(arg) {
  const jsbiBI = ToBigInt(arg);
  if (typeof globalThis.BigInt !== "undefined")
    return globalThis.BigInt(jsbiBI.toString(10));
  return jsbiBI;
}
function ToBigInt(arg) {
  if (arg instanceof import_jsbi.default) {
    return arg;
  }
  let prim = arg;
  if (typeof arg === "object") {
    const toPrimFn = arg[Symbol.toPrimitive];
    if (toPrimFn && typeof toPrimFn === "function") {
      prim = ReflectApply$1(toPrimFn, arg, ["number"]);
    }
  }
  switch (typeof prim) {
    case "undefined":
    case "object":
    case "number":
    case "symbol":
    default:
      throw new TypeError(`cannot convert ${typeof arg} to bigint`);
    case "string":
      if (!prim.match(/^\s*(?:[+-]?\d+\s*)?$/)) {
        throw new SyntaxError("invalid BigInt syntax");
      }
    case "bigint":
      try {
        return import_jsbi.default.BigInt(prim.toString());
      } catch (e2) {
        if (e2 instanceof Error && e2.message.startsWith("Invalid integer"))
          throw new SyntaxError(e2.message);
        throw e2;
      }
    case "boolean":
      if (prim) {
        return ONE;
      } else {
        return ZERO;
      }
  }
}
function SystemTimeZone() {
  const fmt = new IntlDateTimeFormat$1("en-us");
  const TemporalTimeZone = GetIntrinsic("%Temporal.TimeZone%");
  return new TemporalTimeZone(ParseTemporalTimeZone(fmt.resolvedOptions().timeZone));
}
function ComparisonResult(value) {
  return value < 0 ? -1 : value > 0 ? 1 : value;
}
function GetOptionsObject(options) {
  if (options === void 0)
    return ObjectCreate$2(null);
  if (IsObject(options) && options !== null)
    return options;
  throw new TypeError(`Options parameter must be an object, not ${options === null ? "null" : `${typeof options}`}`);
}
function CreateOnePropObject(propName, propValue) {
  const o = ObjectCreate$2(null);
  o[propName] = propValue;
  return o;
}
function GetOption(options, property, allowedValues, fallback) {
  let value = options[property];
  if (value !== void 0) {
    value = ToString(value);
    if (!allowedValues.includes(value)) {
      throw new RangeError(`${property} must be one of ${allowedValues.join(", ")}, not ${value}`);
    }
    return value;
  }
  return fallback;
}
function GetNumberOption(options, property, minimum, maximum, fallback) {
  let valueRaw = options[property];
  if (valueRaw === void 0)
    return fallback;
  const value = ToNumber(valueRaw);
  if (NumberIsNaN(value) || value < minimum || value > maximum) {
    throw new RangeError(`${property} must be between ${minimum} and ${maximum}, not ${value}`);
  }
  return MathFloor(value);
}
function bisect(getState, leftParam, rightParam, lstateParam = getState(leftParam), rstateParam = getState(rightParam)) {
  let left = import_jsbi.default.BigInt(leftParam);
  let right = import_jsbi.default.BigInt(rightParam);
  let lstate = lstateParam;
  let rstate = rstateParam;
  while (import_jsbi.default.greaterThan(import_jsbi.default.subtract(right, left), ONE)) {
    const middle = import_jsbi.default.divide(import_jsbi.default.add(left, right), import_jsbi.default.BigInt(2));
    const mstate = getState(middle);
    if (mstate === lstate) {
      left = middle;
      lstate = mstate;
    } else if (mstate === rstate) {
      right = middle;
      rstate = mstate;
    } else {
      throw new Error(`invalid state in bisection ${lstate} - ${mstate} - ${rstate}`);
    }
  }
  return right;
}
function getPropLazy(obj, prop) {
  let val = obj[prop];
  if (typeof val === "function") {
    val = new IntlDateTimeFormat(obj[LOCALE], val(obj[OPTIONS]));
    obj[prop] = val;
  }
  return val;
}
function getResolvedTimeZoneLazy(obj) {
  let val = obj[TZ_RESOLVED];
  if (typeof val === "string") {
    val = ToTemporalTimeZone(val);
    obj[TZ_RESOLVED] = val;
  }
  return val;
}
function DateTimeFormatImpl(locale = void 0, optionsParam = {}) {
  if (!(this instanceof DateTimeFormatImpl)) {
    return new DateTimeFormatImpl(locale, optionsParam);
  }
  const hasOptions = typeof optionsParam !== "undefined";
  const options = hasOptions ? ObjectAssign$1({}, optionsParam) : {};
  const original = new IntlDateTimeFormat(locale, options);
  const ro = original.resolvedOptions();
  if (hasOptions) {
    const clonedResolved = ObjectAssign$1({}, ro);
    for (const prop in clonedResolved) {
      if (!ReflectApply(ObjectHasOwnProperty, options, [prop])) {
        delete clonedResolved[prop];
      }
    }
    this[OPTIONS] = clonedResolved;
  } else {
    this[OPTIONS] = options;
  }
  this[TZ_GIVEN] = options.timeZone ? options.timeZone : null;
  this[LOCALE] = ro.locale;
  this[ORIGINAL] = original;
  this[TZ_RESOLVED] = ro.timeZone;
  this[CAL_ID] = ro.calendar;
  this[DATE] = dateAmend;
  this[YM] = yearMonthAmend;
  this[MD] = monthDayAmend;
  this[TIME] = timeAmend;
  this[DATETIME] = datetimeAmend;
  this[ZONED] = zonedDateTimeAmend;
  this[INST] = instantAmend;
  return void 0;
}
function resolvedOptions() {
  return this[ORIGINAL].resolvedOptions();
}
function adjustFormatterTimeZone(formatter, timeZone2) {
  if (!timeZone2)
    return formatter;
  const options = formatter.resolvedOptions();
  if (options.timeZone === timeZone2)
    return formatter;
  return new IntlDateTimeFormat(options.locale, __spreadProps(__spreadValues({}, options), { timeZone: timeZone2 }));
}
function format2(datetime, ...rest) {
  let { instant: instant2, formatter, timeZone: timeZone2 } = extractOverrides(datetime, this);
  if (instant2 && formatter) {
    formatter = adjustFormatterTimeZone(formatter, timeZone2);
    return formatter.format(instant2.epochMilliseconds);
  }
  return this[ORIGINAL].format(datetime, ...rest);
}
function formatToParts(datetime, ...rest) {
  let { instant: instant2, formatter, timeZone: timeZone2 } = extractOverrides(datetime, this);
  if (instant2 && formatter) {
    formatter = adjustFormatterTimeZone(formatter, timeZone2);
    return formatter.formatToParts(instant2.epochMilliseconds);
  }
  return this[ORIGINAL].formatToParts(datetime, ...rest);
}
function formatRange(a, b) {
  if (isTemporalObject(a) || isTemporalObject(b)) {
    if (!sameTemporalType(a, b)) {
      throw new TypeError("Intl.DateTimeFormat.formatRange accepts two values of the same type");
    }
    const { instant: aa, formatter: aformatter, timeZone: atz } = extractOverrides(a, this);
    const { instant: bb, formatter: bformatter, timeZone: btz } = extractOverrides(b, this);
    if (atz && btz && atz !== btz) {
      throw new RangeError("cannot format range between different time zones");
    }
    if (aa && bb && aformatter && bformatter && aformatter === bformatter) {
      const formatter = adjustFormatterTimeZone(aformatter, atz);
      return formatter.formatRange(aa.epochMilliseconds, bb.epochMilliseconds);
    }
  }
  return this[ORIGINAL].formatRange(a, b);
}
function formatRangeToParts(a, b) {
  if (isTemporalObject(a) || isTemporalObject(b)) {
    if (!sameTemporalType(a, b)) {
      throw new TypeError("Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type");
    }
    const { instant: aa, formatter: aformatter, timeZone: atz } = extractOverrides(a, this);
    const { instant: bb, formatter: bformatter, timeZone: btz } = extractOverrides(b, this);
    if (atz && btz && atz !== btz) {
      throw new RangeError("cannot format range between different time zones");
    }
    if (aa && bb && aformatter && bformatter && aformatter === bformatter) {
      const formatter = adjustFormatterTimeZone(aformatter, atz);
      return formatter.formatRangeToParts(aa.epochMilliseconds, bb.epochMilliseconds);
    }
  }
  return this[ORIGINAL].formatRangeToParts(a, b);
}
function amend(optionsParam = {}, amended = {}) {
  const options = ObjectAssign$1({}, optionsParam);
  for (const opt of [
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "weekday",
    "dayPeriod",
    "timeZoneName",
    "dateStyle",
    "timeStyle"
  ]) {
    options[opt] = opt in amended ? amended[opt] : options[opt];
    if (options[opt] === false || options[opt] === void 0)
      delete options[opt];
  }
  return options;
}
function timeAmend(optionsParam) {
  let options = amend(optionsParam, {
    year: false,
    month: false,
    day: false,
    weekday: false,
    timeZoneName: false,
    dateStyle: false
  });
  if (!hasTimeOptions(options)) {
    options = ObjectAssign$1({}, options, {
      hour: "numeric",
      minute: "numeric",
      second: "numeric"
    });
  }
  return options;
}
function yearMonthAmend(optionsParam) {
  let options = amend(optionsParam, {
    day: false,
    hour: false,
    minute: false,
    second: false,
    weekday: false,
    dayPeriod: false,
    timeZoneName: false,
    dateStyle: false,
    timeStyle: false
  });
  if (!("year" in options || "month" in options)) {
    options = ObjectAssign$1(options, { year: "numeric", month: "numeric" });
  }
  return options;
}
function monthDayAmend(optionsParam) {
  let options = amend(optionsParam, {
    year: false,
    hour: false,
    minute: false,
    second: false,
    weekday: false,
    dayPeriod: false,
    timeZoneName: false,
    dateStyle: false,
    timeStyle: false
  });
  if (!("month" in options || "day" in options)) {
    options = ObjectAssign$1({}, options, { month: "numeric", day: "numeric" });
  }
  return options;
}
function dateAmend(optionsParam) {
  let options = amend(optionsParam, {
    hour: false,
    minute: false,
    second: false,
    dayPeriod: false,
    timeZoneName: false,
    timeStyle: false
  });
  if (!hasDateOptions(options)) {
    options = ObjectAssign$1({}, options, {
      year: "numeric",
      month: "numeric",
      day: "numeric"
    });
  }
  return options;
}
function datetimeAmend(optionsParam) {
  let options = amend(optionsParam, { timeZoneName: false });
  if (!hasTimeOptions(options) && !hasDateOptions(options)) {
    options = ObjectAssign$1({}, options, {
      year: "numeric",
      month: "numeric",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric"
    });
  }
  return options;
}
function zonedDateTimeAmend(optionsParam) {
  let options = optionsParam;
  if (!hasTimeOptions(options) && !hasDateOptions(options)) {
    options = ObjectAssign$1({}, options, {
      year: "numeric",
      month: "numeric",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric"
    });
    if (options.timeZoneName === void 0)
      options.timeZoneName = "short";
  }
  return options;
}
function instantAmend(optionsParam) {
  let options = optionsParam;
  if (!hasTimeOptions(options) && !hasDateOptions(options)) {
    options = ObjectAssign$1({}, options, {
      year: "numeric",
      month: "numeric",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric"
    });
  }
  return options;
}
function hasDateOptions(options) {
  return "year" in options || "month" in options || "day" in options || "weekday" in options || "dateStyle" in options;
}
function hasTimeOptions(options) {
  return "hour" in options || "minute" in options || "second" in options || "timeStyle" in options || "dayPeriod" in options;
}
function isTemporalObject(obj) {
  return IsTemporalDate(obj) || IsTemporalTime(obj) || IsTemporalDateTime(obj) || IsTemporalZonedDateTime(obj) || IsTemporalYearMonth(obj) || IsTemporalMonthDay(obj) || IsTemporalInstant(obj);
}
function sameTemporalType(x2, y) {
  if (!isTemporalObject(x2) || !isTemporalObject(y))
    return false;
  if (IsTemporalTime(x2) && !IsTemporalTime(y))
    return false;
  if (IsTemporalDate(x2) && !IsTemporalDate(y))
    return false;
  if (IsTemporalDateTime(x2) && !IsTemporalDateTime(y))
    return false;
  if (IsTemporalZonedDateTime(x2) && !IsTemporalZonedDateTime(y))
    return false;
  if (IsTemporalYearMonth(x2) && !IsTemporalYearMonth(y))
    return false;
  if (IsTemporalMonthDay(x2) && !IsTemporalMonthDay(y))
    return false;
  if (IsTemporalInstant(x2) && !IsTemporalInstant(y))
    return false;
  return true;
}
function extractOverrides(temporalObj, main) {
  const DateTime = GetIntrinsic("%Temporal.PlainDateTime%");
  if (IsTemporalTime(temporalObj)) {
    const hour = GetSlot(temporalObj, ISO_HOUR);
    const minute = GetSlot(temporalObj, ISO_MINUTE);
    const second = GetSlot(temporalObj, ISO_SECOND);
    const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);
    const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);
    const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);
    const datetime = new DateTime(1970, 1, 1, hour, minute, second, millisecond, microsecond, nanosecond, main[CAL_ID]);
    return {
      instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, "compatible"),
      formatter: getPropLazy(main, TIME)
    };
  }
  if (IsTemporalYearMonth(temporalObj)) {
    const isoYear = GetSlot(temporalObj, ISO_YEAR);
    const isoMonth = GetSlot(temporalObj, ISO_MONTH);
    const referenceISODay = GetSlot(temporalObj, ISO_DAY);
    const calendar2 = ToString(GetSlot(temporalObj, CALENDAR));
    if (calendar2 !== main[CAL_ID]) {
      throw new RangeError(`cannot format PlainYearMonth with calendar ${calendar2} in locale with calendar ${main[CAL_ID]}`);
    }
    const datetime = new DateTime(isoYear, isoMonth, referenceISODay, 12, 0, 0, 0, 0, 0, calendar2);
    return {
      instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, "compatible"),
      formatter: getPropLazy(main, YM)
    };
  }
  if (IsTemporalMonthDay(temporalObj)) {
    const referenceISOYear = GetSlot(temporalObj, ISO_YEAR);
    const isoMonth = GetSlot(temporalObj, ISO_MONTH);
    const isoDay = GetSlot(temporalObj, ISO_DAY);
    const calendar2 = ToString(GetSlot(temporalObj, CALENDAR));
    if (calendar2 !== main[CAL_ID]) {
      throw new RangeError(`cannot format PlainMonthDay with calendar ${calendar2} in locale with calendar ${main[CAL_ID]}`);
    }
    const datetime = new DateTime(referenceISOYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, calendar2);
    return {
      instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, "compatible"),
      formatter: getPropLazy(main, MD)
    };
  }
  if (IsTemporalDate(temporalObj)) {
    const isoYear = GetSlot(temporalObj, ISO_YEAR);
    const isoMonth = GetSlot(temporalObj, ISO_MONTH);
    const isoDay = GetSlot(temporalObj, ISO_DAY);
    const calendar2 = ToString(GetSlot(temporalObj, CALENDAR));
    if (calendar2 !== "iso8601" && calendar2 !== main[CAL_ID]) {
      throw new RangeError(`cannot format PlainDate with calendar ${calendar2} in locale with calendar ${main[CAL_ID]}`);
    }
    const datetime = new DateTime(isoYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, main[CAL_ID]);
    return {
      instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, "compatible"),
      formatter: getPropLazy(main, DATE)
    };
  }
  if (IsTemporalDateTime(temporalObj)) {
    const isoYear = GetSlot(temporalObj, ISO_YEAR);
    const isoMonth = GetSlot(temporalObj, ISO_MONTH);
    const isoDay = GetSlot(temporalObj, ISO_DAY);
    const hour = GetSlot(temporalObj, ISO_HOUR);
    const minute = GetSlot(temporalObj, ISO_MINUTE);
    const second = GetSlot(temporalObj, ISO_SECOND);
    const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);
    const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);
    const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);
    const calendar2 = ToString(GetSlot(temporalObj, CALENDAR));
    if (calendar2 !== "iso8601" && calendar2 !== main[CAL_ID]) {
      throw new RangeError(`cannot format PlainDateTime with calendar ${calendar2} in locale with calendar ${main[CAL_ID]}`);
    }
    let datetime = temporalObj;
    if (calendar2 === "iso8601") {
      datetime = new DateTime(isoYear, isoMonth, isoDay, hour, minute, second, millisecond, microsecond, nanosecond, main[CAL_ID]);
    }
    return {
      instant: BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, "compatible"),
      formatter: getPropLazy(main, DATETIME)
    };
  }
  if (IsTemporalZonedDateTime(temporalObj)) {
    const calendar2 = ToString(GetSlot(temporalObj, CALENDAR));
    if (calendar2 !== "iso8601" && calendar2 !== main[CAL_ID]) {
      throw new RangeError(`cannot format ZonedDateTime with calendar ${calendar2} in locale with calendar ${main[CAL_ID]}`);
    }
    const timeZone2 = GetSlot(temporalObj, TIME_ZONE);
    const objTimeZone = ToString(timeZone2);
    if (main[TZ_GIVEN] && main[TZ_GIVEN] !== objTimeZone) {
      throw new RangeError(`timeZone option ${main[TZ_GIVEN]} doesn't match actual time zone ${objTimeZone}`);
    }
    return {
      instant: GetSlot(temporalObj, INSTANT),
      formatter: getPropLazy(main, ZONED),
      timeZone: objTimeZone
    };
  }
  if (IsTemporalInstant(temporalObj)) {
    return {
      instant: temporalObj,
      formatter: getPropLazy(main, INST)
    };
  }
  return {};
}
function TemporalTimeToString(time2, precision, options = void 0) {
  let hour = GetSlot(time2, ISO_HOUR);
  let minute = GetSlot(time2, ISO_MINUTE);
  let second = GetSlot(time2, ISO_SECOND);
  let millisecond = GetSlot(time2, ISO_MILLISECOND);
  let microsecond = GetSlot(time2, ISO_MICROSECOND);
  let nanosecond = GetSlot(time2, ISO_NANOSECOND);
  if (options) {
    const { unit, increment, roundingMode } = options;
    ({ hour, minute, second, millisecond, microsecond, nanosecond } = RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode));
  }
  const hourString = ISODateTimePartString(hour);
  const minuteString = ISODateTimePartString(minute);
  const seconds = FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);
  return `${hourString}:${minuteString}${seconds}`;
}
function dateTime(zdt) {
  return BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(zdt, TIME_ZONE), GetSlot(zdt, INSTANT), GetSlot(zdt, CALENDAR));
}
var import_jsbi, INTRINSICS, customUtilInspectFormatters, EPOCHNANOSECONDS, TIMEZONE_ID, ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND, CALENDAR, DATE_BRAND, YEAR_MONTH_BRAND, MONTH_DAY_BRAND, INSTANT, TIME_ZONE, YEARS, MONTHS, WEEKS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS, CALENDAR_ID, slots, ArrayIncludes, ArrayPrototypePush$2, IntlDateTimeFormat$2, ArraySort, MathAbs$1, MathFloor$1, ObjectEntries, ObjectKeys, impl, Calendar, OneObjectCache, HelperBase, HebrewHelper, IslamicBaseHelper, IslamicHelper, IslamicUmalquraHelper, IslamicTblaHelper, IslamicCivilHelper, IslamicRgsaHelper, IslamicCcHelper, PersianHelper, IndianHelper, GregorianBaseHelper, OrthodoxBaseHelper, EthioaaHelper, CopticHelper, EthiopicHelper, RocHelper, BuddhistHelper, GregoryHelper, JapaneseHelper, ChineseBaseHelper, ChineseHelper, DangiHelper, nonIsoImpl, BUILTIN_CALENDAR_IDS, tzComponent, offsetNoCapture, timeZoneID, calComponent, calendarID, yearpart, monthpart, daypart, datesplit, timesplit, offset, zonesplit, calendar, zoneddatetime, time, yearmonth, monthday, fraction, durationDate, durationTime, duration, ArrayPrototypePush$1, IntlDateTimeFormat$1, MathMin, MathMax, MathAbs, MathFloor, MathSign, MathTrunc, NumberIsNaN, NumberIsFinite, NumberCtor, StringCtor, NumberMaxSafeInteger, ObjectCreate$2, ObjectDefineProperty, ObjectIs, ReflectApply$1, ZERO, ONE, SIXTY, THOUSAND, MILLION, BILLION, NEGATIVE_ONE, DAY_SECONDS, DAY_NANOS, NS_MIN, NS_MAX, YEAR_MIN, YEAR_MAX, BEFORE_FIRST_OFFSET_TRANSITION, ABOUT_TEN_YEARS_NANOS, ABOUT_ONE_YEAR_NANOS, TWO_WEEKS_NANOS, BUILTIN_CASTS, ALLOWED_UNITS, SINGULAR_PLURAL_UNITS, IntlDateTimeFormatEnUsCache, SystemUTCEpochNanoSeconds, OFFSET, nsPerTimeUnit, DATE, YM, MD, TIME, DATETIME, ZONED, INST, ORIGINAL, TZ_RESOLVED, TZ_GIVEN, CAL_ID, LOCALE, OPTIONS, descriptor, IntlDateTimeFormat, ObjectAssign$1, ObjectHasOwnProperty, ReflectApply, properties, DateTimeFormat, DISALLOWED_UNITS$3, MAX_DIFFERENCE_INCREMENTS, Instant, DISALLOWED_UNITS$2, PlainDate, PlainDateTime, Duration, ObjectCreate$1, PlainMonthDay, instant, plainDateTime, plainDateTimeISO, zonedDateTime, zonedDateTimeISO, plainDate, plainDateISO, plainTimeISO, timeZone, Now, ObjectAssign, DISALLOWED_UNITS$1, MAX_INCREMENTS, PlainTime, TimeZone, ObjectCreate, DISALLOWED_UNITS, PlainYearMonth, ArrayPrototypePush, ZonedDateTime, temporal, types2;
var init_index_esm = __esm({
  "node_modules/@js-temporal/polyfill/dist/index.esm.js"() {
    import_jsbi = __toESM(require_jsbi_cjs(), 1);
    INTRINSICS = {};
    customUtilInspectFormatters = {
      ["Temporal.Duration"](depth, options) {
        const descr = options.stylize(`${this[Symbol.toStringTag]} <${this}>`, "special");
        if (depth < 1)
          return descr;
        const entries = [];
        for (const prop of [
          "years",
          "months",
          "weeks",
          "days",
          "hours",
          "minutes",
          "seconds",
          "milliseconds",
          "microseconds",
          "nanoseconds"
        ]) {
          if (this[prop] !== 0)
            entries.push(`  ${prop}: ${options.stylize(this[prop], "number")}`);
        }
        return descr + " {\n" + entries.join(",\n") + "\n}";
      }
    };
    EPOCHNANOSECONDS = "slot-epochNanoSeconds";
    TIMEZONE_ID = "slot-timezone-identifier";
    ISO_YEAR = "slot-year";
    ISO_MONTH = "slot-month";
    ISO_DAY = "slot-day";
    ISO_HOUR = "slot-hour";
    ISO_MINUTE = "slot-minute";
    ISO_SECOND = "slot-second";
    ISO_MILLISECOND = "slot-millisecond";
    ISO_MICROSECOND = "slot-microsecond";
    ISO_NANOSECOND = "slot-nanosecond";
    CALENDAR = "slot-calendar";
    DATE_BRAND = "slot-date-brand";
    YEAR_MONTH_BRAND = "slot-year-month-brand";
    MONTH_DAY_BRAND = "slot-month-day-brand";
    INSTANT = "slot-cached-instant";
    TIME_ZONE = "slot-time-zone";
    YEARS = "slot-years";
    MONTHS = "slot-months";
    WEEKS = "slot-weeks";
    DAYS = "slot-days";
    HOURS = "slot-hours";
    MINUTES = "slot-minutes";
    SECONDS = "slot-seconds";
    MILLISECONDS = "slot-milliseconds";
    MICROSECONDS = "slot-microseconds";
    NANOSECONDS = "slot-nanoseconds";
    CALENDAR_ID = "slot-calendar-identifier";
    slots = /* @__PURE__ */ new WeakMap();
    ArrayIncludes = Array.prototype.includes;
    ArrayPrototypePush$2 = Array.prototype.push;
    IntlDateTimeFormat$2 = globalThis.Intl.DateTimeFormat;
    ArraySort = Array.prototype.sort;
    MathAbs$1 = Math.abs;
    MathFloor$1 = Math.floor;
    ObjectEntries = Object.entries;
    ObjectKeys = Object.keys;
    impl = {};
    Calendar = class {
      constructor(idParam) {
        if (arguments.length < 1) {
          throw new RangeError("missing argument: id is required");
        }
        const id = ToString(idParam);
        if (!IsBuiltinCalendar(id))
          throw new RangeError(`invalid calendar identifier ${id}`);
        CreateSlots(this);
        SetSlot(this, CALENDAR_ID, id);
        {
          Object.defineProperty(this, "_repr_", {
            value: `${this[Symbol.toStringTag]} <${id}>`,
            writable: false,
            enumerable: false,
            configurable: false
          });
        }
      }
      get id() {
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        return ToString(this);
      }
      dateFromFields(fields, optionsParam = void 0) {
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        if (!IsObject(fields))
          throw new TypeError("invalid fields");
        const options = GetOptionsObject(optionsParam);
        return impl[GetSlot(this, CALENDAR_ID)].dateFromFields(fields, options, this);
      }
      yearMonthFromFields(fields, optionsParam = void 0) {
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        if (!IsObject(fields))
          throw new TypeError("invalid fields");
        const options = GetOptionsObject(optionsParam);
        return impl[GetSlot(this, CALENDAR_ID)].yearMonthFromFields(fields, options, this);
      }
      monthDayFromFields(fields, optionsParam = void 0) {
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        if (!IsObject(fields))
          throw new TypeError("invalid fields");
        const options = GetOptionsObject(optionsParam);
        return impl[GetSlot(this, CALENDAR_ID)].monthDayFromFields(fields, options, this);
      }
      fields(fields) {
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        const fieldsArray = [];
        const allowed = /* @__PURE__ */ new Set([
          "year",
          "month",
          "monthCode",
          "day",
          "hour",
          "minute",
          "second",
          "millisecond",
          "microsecond",
          "nanosecond"
        ]);
        for (const name of fields) {
          if (typeof name !== "string")
            throw new TypeError("invalid fields");
          if (!allowed.has(name))
            throw new RangeError(`invalid field name ${name}`);
          allowed.delete(name);
          ArrayPrototypePush$2.call(fieldsArray, name);
        }
        return impl[GetSlot(this, CALENDAR_ID)].fields(fieldsArray);
      }
      mergeFields(fields, additionalFields) {
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        return impl[GetSlot(this, CALENDAR_ID)].mergeFields(fields, additionalFields);
      }
      dateAdd(dateParam, durationParam, optionsParam = void 0) {
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        const date = ToTemporalDate(dateParam);
        const duration2 = ToTemporalDuration(durationParam);
        const options = GetOptionsObject(optionsParam);
        const overflow = ToTemporalOverflow(options);
        const { days } = BalanceDuration(GetSlot(duration2, DAYS), GetSlot(duration2, HOURS), GetSlot(duration2, MINUTES), GetSlot(duration2, SECONDS), GetSlot(duration2, MILLISECONDS), GetSlot(duration2, MICROSECONDS), GetSlot(duration2, NANOSECONDS), "day");
        return impl[GetSlot(this, CALENDAR_ID)].dateAdd(date, GetSlot(duration2, YEARS), GetSlot(duration2, MONTHS), GetSlot(duration2, WEEKS), days, overflow, this);
      }
      dateUntil(oneParam, twoParam, optionsParam = void 0) {
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        const one = ToTemporalDate(oneParam);
        const two = ToTemporalDate(twoParam);
        const options = GetOptionsObject(optionsParam);
        const largestUnit = ToLargestTemporalUnit(options, "auto", ["hour", "minute", "second", "millisecond", "microsecond", "nanosecond"], "day");
        const { years, months, weeks, days } = impl[GetSlot(this, CALENDAR_ID)].dateUntil(one, two, largestUnit);
        const Duration2 = GetIntrinsic("%Temporal.Duration%");
        return new Duration2(years, months, weeks, days, 0, 0, 0, 0, 0, 0);
      }
      year(dateParam) {
        let date = dateParam;
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        if (!IsTemporalYearMonth(date))
          date = ToTemporalDate(date);
        return impl[GetSlot(this, CALENDAR_ID)].year(date);
      }
      month(dateParam) {
        let date = dateParam;
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        if (IsTemporalMonthDay(date))
          throw new TypeError("use monthCode on PlainMonthDay instead");
        if (!IsTemporalYearMonth(date))
          date = ToTemporalDate(date);
        return impl[GetSlot(this, CALENDAR_ID)].month(date);
      }
      monthCode(dateParam) {
        let date = dateParam;
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        if (!IsTemporalYearMonth(date) && !IsTemporalMonthDay(date))
          date = ToTemporalDate(date);
        return impl[GetSlot(this, CALENDAR_ID)].monthCode(date);
      }
      day(dateParam) {
        let date = dateParam;
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        if (!IsTemporalMonthDay(date))
          date = ToTemporalDate(date);
        return impl[GetSlot(this, CALENDAR_ID)].day(date);
      }
      era(dateParam) {
        let date = dateParam;
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        if (!IsTemporalYearMonth(date))
          date = ToTemporalDate(date);
        return impl[GetSlot(this, CALENDAR_ID)].era(date);
      }
      eraYear(dateParam) {
        let date = dateParam;
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        if (!IsTemporalYearMonth(date))
          date = ToTemporalDate(date);
        return impl[GetSlot(this, CALENDAR_ID)].eraYear(date);
      }
      dayOfWeek(dateParam) {
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        const date = ToTemporalDate(dateParam);
        return impl[GetSlot(this, CALENDAR_ID)].dayOfWeek(date);
      }
      dayOfYear(dateParam) {
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        const date = ToTemporalDate(dateParam);
        return impl[GetSlot(this, CALENDAR_ID)].dayOfYear(date);
      }
      weekOfYear(dateParam) {
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        const date = ToTemporalDate(dateParam);
        return impl[GetSlot(this, CALENDAR_ID)].weekOfYear(date);
      }
      daysInWeek(dateParam) {
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        const date = ToTemporalDate(dateParam);
        return impl[GetSlot(this, CALENDAR_ID)].daysInWeek(date);
      }
      daysInMonth(dateParam) {
        let date = dateParam;
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        if (!IsTemporalYearMonth(date))
          date = ToTemporalDate(date);
        return impl[GetSlot(this, CALENDAR_ID)].daysInMonth(date);
      }
      daysInYear(dateParam) {
        let date = dateParam;
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        if (!IsTemporalYearMonth(date))
          date = ToTemporalDate(date);
        return impl[GetSlot(this, CALENDAR_ID)].daysInYear(date);
      }
      monthsInYear(dateParam) {
        let date = dateParam;
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        if (!IsTemporalYearMonth(date))
          date = ToTemporalDate(date);
        return impl[GetSlot(this, CALENDAR_ID)].monthsInYear(date);
      }
      inLeapYear(dateParam) {
        let date = dateParam;
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        if (!IsTemporalYearMonth(date))
          date = ToTemporalDate(date);
        return impl[GetSlot(this, CALENDAR_ID)].inLeapYear(date);
      }
      toString() {
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, CALENDAR_ID);
      }
      toJSON() {
        if (!IsTemporalCalendar(this))
          throw new TypeError("invalid receiver");
        return ToString(this);
      }
      static from(item) {
        return ToTemporalCalendar(item);
      }
    };
    MakeIntrinsicClass(Calendar, "Temporal.Calendar");
    DefineIntrinsic("Temporal.Calendar.from", Calendar.from);
    impl["iso8601"] = {
      dateFromFields(fieldsParam, options, calendar2) {
        const overflow = ToTemporalOverflow(options);
        let fields = PrepareTemporalFields(fieldsParam, [
          ["day"],
          ["month", void 0],
          ["monthCode", void 0],
          ["year"]
        ]);
        fields = resolveNonLunisolarMonth(fields);
        let { year, month, day } = fields;
        ({ year, month, day } = RegulateISODate(year, month, day, overflow));
        return CreateTemporalDate(year, month, day, calendar2);
      },
      yearMonthFromFields(fieldsParam, options, calendar2) {
        const overflow = ToTemporalOverflow(options);
        let fields = PrepareTemporalFields(fieldsParam, [
          ["month", void 0],
          ["monthCode", void 0],
          ["year"]
        ]);
        fields = resolveNonLunisolarMonth(fields);
        let { year, month } = fields;
        ({ year, month } = RegulateISOYearMonth(year, month, overflow));
        return CreateTemporalYearMonth(year, month, calendar2, 1);
      },
      monthDayFromFields(fieldsParam, options, calendar2) {
        const overflow = ToTemporalOverflow(options);
        let fields = PrepareTemporalFields(fieldsParam, [
          ["day"],
          ["month", void 0],
          ["monthCode", void 0],
          ["year", void 0]
        ]);
        if (fields.month !== void 0 && fields.year === void 0 && fields.monthCode === void 0) {
          throw new TypeError("either year or monthCode required with month");
        }
        const useYear = fields.monthCode === void 0;
        const referenceISOYear = 1972;
        fields = resolveNonLunisolarMonth(fields);
        let { month, day, year } = fields;
        ({ month, day } = RegulateISODate(useYear ? year : referenceISOYear, month, day, overflow));
        return CreateTemporalMonthDay(month, day, calendar2, referenceISOYear);
      },
      fields(fields) {
        return fields;
      },
      mergeFields(fields, additionalFields) {
        const merged = {};
        for (const nextKey of ObjectKeys(fields)) {
          if (nextKey === "month" || nextKey === "monthCode")
            continue;
          merged[nextKey] = fields[nextKey];
        }
        const newKeys = ObjectKeys(additionalFields);
        for (const nextKey of newKeys) {
          merged[nextKey] = additionalFields[nextKey];
        }
        if (!ArrayIncludes.call(newKeys, "month") && !ArrayIncludes.call(newKeys, "monthCode")) {
          const { month, monthCode } = fields;
          if (month !== void 0)
            merged.month = month;
          if (monthCode !== void 0)
            merged.monthCode = monthCode;
        }
        return merged;
      },
      dateAdd(date, years, months, weeks, days, overflow, calendar2) {
        let year = GetSlot(date, ISO_YEAR);
        let month = GetSlot(date, ISO_MONTH);
        let day = GetSlot(date, ISO_DAY);
        ({ year, month, day } = AddISODate(year, month, day, years, months, weeks, days, overflow));
        return CreateTemporalDate(year, month, day, calendar2);
      },
      dateUntil(one, two, largestUnit) {
        return DifferenceISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY), largestUnit);
      },
      year(date) {
        return GetSlot(date, ISO_YEAR);
      },
      era() {
        return void 0;
      },
      eraYear() {
        return void 0;
      },
      month(date) {
        return GetSlot(date, ISO_MONTH);
      },
      monthCode(date) {
        return buildMonthCode(GetSlot(date, ISO_MONTH));
      },
      day(date) {
        return GetSlot(date, ISO_DAY);
      },
      dayOfWeek(date) {
        return DayOfWeek(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));
      },
      dayOfYear(date) {
        return DayOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));
      },
      weekOfYear(date) {
        return WeekOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));
      },
      daysInWeek() {
        return 7;
      },
      daysInMonth(date) {
        return ISODaysInMonth(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH));
      },
      daysInYear(dateParam) {
        let date = dateParam;
        if (!HasSlot(date, ISO_YEAR))
          date = ToTemporalDate(date);
        return LeapYear(GetSlot(date, ISO_YEAR)) ? 366 : 365;
      },
      monthsInYear() {
        return 12;
      },
      inLeapYear(dateParam) {
        let date = dateParam;
        if (!HasSlot(date, ISO_YEAR))
          date = ToTemporalDate(date);
        return LeapYear(GetSlot(date, ISO_YEAR));
      }
    };
    OneObjectCache = class {
      constructor(cacheToClone) {
        this.map = /* @__PURE__ */ new Map();
        this.calls = 0;
        this.hits = 0;
        this.misses = 0;
        this.now = globalThis.performance ? globalThis.performance.now() : Date.now();
        if (cacheToClone !== void 0) {
          let i2 = 0;
          for (const entry11 of cacheToClone.map.entries()) {
            if (++i2 > OneObjectCache.MAX_CACHE_ENTRIES)
              break;
            this.map.set(...entry11);
          }
        }
      }
      get(key2) {
        const result = this.map.get(key2);
        if (result) {
          this.hits++;
          this.report();
        }
        this.calls++;
        return result;
      }
      set(key2, value) {
        this.map.set(key2, value);
        this.misses++;
        this.report();
      }
      report() {
      }
      setObject(obj) {
        if (OneObjectCache.objectMap.get(obj))
          throw new RangeError("object already cached");
        OneObjectCache.objectMap.set(obj, this);
        this.report();
      }
      static getCacheForObject(obj) {
        let cache = OneObjectCache.objectMap.get(obj);
        if (!cache) {
          cache = new OneObjectCache();
          OneObjectCache.objectMap.set(obj, cache);
        }
        return cache;
      }
    };
    OneObjectCache.objectMap = /* @__PURE__ */ new WeakMap();
    OneObjectCache.MAX_CACHE_ENTRIES = 1e3;
    HelperBase = class {
      constructor() {
        this.eraLength = "short";
        this.hasEra = true;
      }
      getFormatter() {
        if (typeof this.formatter === "undefined") {
          this.formatter = new IntlDateTimeFormat$2(`en-US-u-ca-${this.id}`, {
            day: "numeric",
            month: "numeric",
            year: "numeric",
            era: this.eraLength,
            timeZone: "UTC"
          });
        }
        return this.formatter;
      }
      isoToCalendarDate(isoDate, cache) {
        const { year: isoYear, month: isoMonth, day: isoDay } = isoDate;
        const key2 = JSON.stringify({ func: "isoToCalendarDate", isoYear, isoMonth, isoDay, id: this.id });
        const cached = cache.get(key2);
        if (cached)
          return cached;
        const dateTimeFormat = this.getFormatter();
        let parts, isoString;
        try {
          isoString = toUtcIsoDateString({ isoYear, isoMonth, isoDay });
          parts = dateTimeFormat.formatToParts(new Date(isoString));
        } catch (e2) {
          throw new RangeError(`Invalid ISO date: ${JSON.stringify({ isoYear, isoMonth, isoDay })}`);
        }
        const result = {};
        for (let { type, value } of parts) {
          if (type === "year")
            result.eraYear = +value;
          if (type === "relatedYear")
            result.eraYear = +value;
          if (type === "month") {
            const matches = /^([0-9]*)(.*?)$/.exec(value);
            if (!matches || matches.length != 3 || !matches[1] && !matches[2]) {
              throw new RangeError(`Unexpected month: ${value}`);
            }
            result.month = matches[1] ? +matches[1] : 1;
            if (result.month < 1) {
              throw new RangeError(`Invalid month ${value} from ${isoString}[u-ca-${this.id}] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)`);
            }
            if (result.month > 13) {
              throw new RangeError(`Invalid month ${value} from ${isoString}[u-ca-${this.id}] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)`);
            }
            if (matches[2])
              result.monthExtra = matches[2];
          }
          if (type === "day")
            result.day = +value;
          if (this.hasEra && type === "era" && value != null && value !== "") {
            value = value.split(" (")[0];
            result.era = value.normalize("NFD").replace(/[^-0-9 \p{L}]/gu, "").replace(" ", "-").toLowerCase();
          }
        }
        if (result.eraYear === void 0) {
          throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);
        }
        if (this.reviseIntlEra) {
          const { era, eraYear } = this.reviseIntlEra(result, isoDate);
          result.era = era;
          result.eraYear = eraYear;
        }
        if (this.checkIcuBugs)
          this.checkIcuBugs(isoDate);
        const calendarDate = this.adjustCalendarDate(result, cache, "constrain", true);
        if (calendarDate.year === void 0)
          throw new RangeError(`Missing year converting ${JSON.stringify(isoDate)}`);
        if (calendarDate.month === void 0)
          throw new RangeError(`Missing month converting ${JSON.stringify(isoDate)}`);
        if (calendarDate.day === void 0)
          throw new RangeError(`Missing day converting ${JSON.stringify(isoDate)}`);
        cache.set(key2, calendarDate);
        ["constrain", "reject"].forEach((overflow) => {
          const keyReverse = JSON.stringify({
            func: "calendarToIsoDate",
            year: calendarDate.year,
            month: calendarDate.month,
            day: calendarDate.day,
            overflow,
            id: this.id
          });
          cache.set(keyReverse, isoDate);
        });
        return calendarDate;
      }
      validateCalendarDate(calendarDate) {
        const { era, month, year, day, eraYear, monthCode, monthExtra } = calendarDate;
        if (monthExtra !== void 0)
          throw new RangeError("Unexpected `monthExtra` value");
        if (year === void 0 && eraYear === void 0)
          throw new TypeError("year or eraYear is required");
        if (month === void 0 && monthCode === void 0)
          throw new TypeError("month or monthCode is required");
        if (day === void 0)
          throw new RangeError("Missing day");
        if (monthCode !== void 0) {
          if (typeof monthCode !== "string") {
            throw new RangeError(`monthCode must be a string, not ${typeof monthCode}`);
          }
          if (!/^M([01]?\d)(L?)$/.test(monthCode))
            throw new RangeError(`Invalid monthCode: ${monthCode}`);
        }
        if (this.constantEra) {
          if (era !== void 0 && era !== this.constantEra) {
            throw new RangeError(`era must be ${this.constantEra}, not ${era}`);
          }
          if (eraYear !== void 0 && year !== void 0 && eraYear !== year) {
            throw new RangeError(`eraYear ${eraYear} does not match year ${year}`);
          }
        }
      }
      adjustCalendarDate(calendarDateParam, cache = void 0, overflow = "constrain", fromLegacyDate = false) {
        if (this.calendarType === "lunisolar")
          throw new RangeError("Override required for lunisolar calendars");
        let calendarDate = calendarDateParam;
        this.validateCalendarDate(calendarDate);
        if (this.constantEra) {
          const { year, eraYear } = calendarDate;
          calendarDate = __spreadProps(__spreadValues({}, calendarDate), {
            era: this.constantEra,
            year: year !== void 0 ? year : eraYear,
            eraYear: eraYear !== void 0 ? eraYear : year
          });
        }
        const largestMonth = this.monthsInYear(calendarDate, cache);
        let { month, monthCode } = calendarDate;
        ({ month, monthCode } = resolveNonLunisolarMonth(calendarDate, overflow, largestMonth));
        return __spreadProps(__spreadValues({}, calendarDate), { month, monthCode });
      }
      regulateMonthDayNaive(calendarDate, overflow, cache) {
        const largestMonth = this.monthsInYear(calendarDate, cache);
        let { month, day } = calendarDate;
        if (overflow === "reject") {
          RejectToRange(month, 1, largestMonth);
          RejectToRange(day, 1, this.maximumMonthLength(calendarDate));
        } else {
          month = ConstrainToRange(month, 1, largestMonth);
          day = ConstrainToRange(day, 1, this.maximumMonthLength(__spreadProps(__spreadValues({}, calendarDate), { month })));
        }
        return __spreadProps(__spreadValues({}, calendarDate), { month, day });
      }
      calendarToIsoDate(dateParam, overflow = "constrain", cache) {
        const originalDate = dateParam;
        let date = this.adjustCalendarDate(dateParam, cache, overflow, false);
        date = this.regulateMonthDayNaive(date, overflow, cache);
        const { year, month, day } = date;
        const key2 = JSON.stringify({ func: "calendarToIsoDate", year, month, day, overflow, id: this.id });
        let cached = cache.get(key2);
        if (cached)
          return cached;
        let keyOriginal;
        if (originalDate.year !== void 0 && originalDate.month !== void 0 && originalDate.day !== void 0 && (originalDate.year !== date.year || originalDate.month !== date.month || originalDate.day !== date.day)) {
          keyOriginal = JSON.stringify({
            func: "calendarToIsoDate",
            year: originalDate.year,
            month: originalDate.month,
            day: originalDate.day,
            overflow,
            id: this.id
          });
          cached = cache.get(keyOriginal);
          if (cached)
            return cached;
        }
        let isoEstimate = this.estimateIsoDate({ year, month, day });
        const calculateSameMonthResult = (diffDays) => {
          let testIsoEstimate = this.addDaysIso(isoEstimate, diffDays);
          if (date.day > this.minimumMonthLength(date)) {
            let testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);
            while (testCalendarDate.month !== month || testCalendarDate.year !== year) {
              if (overflow === "reject") {
                throw new RangeError(`day ${day} does not exist in month ${month} of year ${year}`);
              }
              testIsoEstimate = this.addDaysIso(testIsoEstimate, -1);
              testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);
            }
          }
          return testIsoEstimate;
        };
        let sign = 0;
        let roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);
        let diff = simpleDateDiff(date, roundtripEstimate);
        if (diff.years !== 0 || diff.months !== 0 || diff.days !== 0) {
          const diffTotalDaysEstimate = diff.years * 365 + diff.months * 30 + diff.days;
          isoEstimate = this.addDaysIso(isoEstimate, diffTotalDaysEstimate);
          roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);
          diff = simpleDateDiff(date, roundtripEstimate);
          if (diff.years === 0 && diff.months === 0) {
            isoEstimate = calculateSameMonthResult(diff.days);
          } else {
            sign = this.compareCalendarDates(date, roundtripEstimate);
          }
        }
        let increment = 8;
        let maybeConstrained = false;
        while (sign) {
          isoEstimate = this.addDaysIso(isoEstimate, sign * increment);
          const oldRoundtripEstimate = roundtripEstimate;
          roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);
          const oldSign = sign;
          sign = this.compareCalendarDates(date, roundtripEstimate);
          if (sign) {
            diff = simpleDateDiff(date, roundtripEstimate);
            if (diff.years === 0 && diff.months === 0) {
              isoEstimate = calculateSameMonthResult(diff.days);
              sign = 0;
              maybeConstrained = date.day > this.minimumMonthLength(date);
            } else if (oldSign && sign !== oldSign) {
              if (increment > 1) {
                increment /= 2;
              } else {
                if (overflow === "reject") {
                  throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify(__spreadValues({}, originalDate))}`);
                } else {
                  const order = this.compareCalendarDates(roundtripEstimate, oldRoundtripEstimate);
                  if (order > 0)
                    isoEstimate = this.addDaysIso(isoEstimate, -1);
                  maybeConstrained = true;
                  sign = 0;
                }
              }
            }
          }
        }
        cache.set(key2, isoEstimate);
        if (keyOriginal)
          cache.set(keyOriginal, isoEstimate);
        if (date.year === void 0 || date.month === void 0 || date.day === void 0 || date.monthCode === void 0 || this.hasEra && (date.era === void 0 || date.eraYear === void 0)) {
          throw new RangeError("Unexpected missing property");
        }
        if (!maybeConstrained) {
          const keyReverse = JSON.stringify({
            func: "isoToCalendarDate",
            isoYear: isoEstimate.year,
            isoMonth: isoEstimate.month,
            isoDay: isoEstimate.day,
            id: this.id
          });
          cache.set(keyReverse, date);
        }
        return isoEstimate;
      }
      temporalToCalendarDate(date, cache) {
        const isoDate = { year: GetSlot(date, ISO_YEAR), month: GetSlot(date, ISO_MONTH), day: GetSlot(date, ISO_DAY) };
        const result = this.isoToCalendarDate(isoDate, cache);
        return result;
      }
      compareCalendarDates(date1Param, date2Param) {
        const date1 = PrepareTemporalFields(date1Param, [["day"], ["month"], ["year"]]);
        const date2 = PrepareTemporalFields(date2Param, [["day"], ["month"], ["year"]]);
        if (date1.year !== date2.year)
          return ComparisonResult(date1.year - date2.year);
        if (date1.month !== date2.month)
          return ComparisonResult(date1.month - date2.month);
        if (date1.day !== date2.day)
          return ComparisonResult(date1.day - date2.day);
        return 0;
      }
      regulateDate(calendarDate, overflow = "constrain", cache) {
        const isoDate = this.calendarToIsoDate(calendarDate, overflow, cache);
        return this.isoToCalendarDate(isoDate, cache);
      }
      addDaysIso(isoDate, days) {
        const added = AddISODate(isoDate.year, isoDate.month, isoDate.day, 0, 0, 0, days, "constrain");
        return added;
      }
      addDaysCalendar(calendarDate, days, cache) {
        const isoDate = this.calendarToIsoDate(calendarDate, "constrain", cache);
        const addedIso = this.addDaysIso(isoDate, days);
        const addedCalendar = this.isoToCalendarDate(addedIso, cache);
        return addedCalendar;
      }
      addMonthsCalendar(calendarDateParam, months, overflow, cache) {
        let calendarDate = calendarDateParam;
        const { day } = calendarDate;
        for (let i2 = 0, absMonths = MathAbs$1(months); i2 < absMonths; i2++) {
          const { month } = calendarDate;
          const oldCalendarDate = calendarDate;
          const days = months < 0 ? -Math.max(day, this.daysInPreviousMonth(calendarDate, cache)) : this.daysInMonth(calendarDate, cache);
          const isoDate = this.calendarToIsoDate(calendarDate, "constrain", cache);
          let addedIso = this.addDaysIso(isoDate, days);
          calendarDate = this.isoToCalendarDate(addedIso, cache);
          if (months > 0) {
            const monthsInOldYear = this.monthsInYear(oldCalendarDate, cache);
            while (calendarDate.month - 1 !== month % monthsInOldYear) {
              addedIso = this.addDaysIso(addedIso, -1);
              calendarDate = this.isoToCalendarDate(addedIso, cache);
            }
          }
          if (calendarDate.day !== day) {
            calendarDate = this.regulateDate(__spreadProps(__spreadValues({}, calendarDate), { day }), "constrain", cache);
          }
        }
        if (overflow === "reject" && calendarDate.day !== day) {
          throw new RangeError(`Day ${day} does not exist in resulting calendar month`);
        }
        return calendarDate;
      }
      addCalendar(calendarDate, { years = 0, months = 0, weeks = 0, days = 0 }, overflow, cache) {
        const { year, month, day } = calendarDate;
        const addedMonths = this.addMonthsCalendar({ year: year + years, month, day }, months, overflow, cache);
        const initialDays = days + weeks * 7;
        const addedDays = this.addDaysCalendar(addedMonths, initialDays, cache);
        return addedDays;
      }
      untilCalendar(calendarOne, calendarTwo, largestUnit, cache) {
        let days = 0;
        let weeks = 0;
        let months = 0;
        let years = 0;
        switch (largestUnit) {
          case "day":
            days = this.calendarDaysUntil(calendarOne, calendarTwo, cache);
            break;
          case "week": {
            const totalDays = this.calendarDaysUntil(calendarOne, calendarTwo, cache);
            days = totalDays % 7;
            weeks = (totalDays - days) / 7;
            break;
          }
          case "month":
          case "year": {
            const diffYears = calendarTwo.year - calendarOne.year;
            const diffMonths = calendarTwo.month - calendarOne.month;
            const diffDays = calendarTwo.day - calendarOne.day;
            const sign = this.compareCalendarDates(calendarTwo, calendarOne);
            if (largestUnit === "year" && diffYears) {
              const isOneFurtherInYear = diffMonths * sign < 0 || diffMonths === 0 && diffDays * sign < 0;
              years = isOneFurtherInYear ? diffYears - sign : diffYears;
            }
            const yearsAdded = years ? this.addCalendar(calendarOne, { years }, "constrain", cache) : calendarOne;
            let current;
            let next = yearsAdded;
            do {
              months += sign;
              current = next;
              next = this.addMonthsCalendar(current, sign, "constrain", cache);
              if (next.day !== calendarOne.day) {
                next = this.regulateDate(__spreadProps(__spreadValues({}, next), { day: calendarOne.day }), "constrain", cache);
              }
            } while (this.compareCalendarDates(calendarTwo, next) * sign >= 0);
            months -= sign;
            const remainingDays = this.calendarDaysUntil(current, calendarTwo, cache);
            days = remainingDays;
            break;
          }
        }
        return { years, months, weeks, days };
      }
      daysInMonth(calendarDate, cache) {
        const { day } = calendarDate;
        const max = this.maximumMonthLength(calendarDate);
        const min = this.minimumMonthLength(calendarDate);
        if (min === max)
          return min;
        const increment = day <= max - min ? max : min;
        const isoDate = this.calendarToIsoDate(calendarDate, "constrain", cache);
        const addedIsoDate = this.addDaysIso(isoDate, increment);
        const addedCalendarDate = this.isoToCalendarDate(addedIsoDate, cache);
        const endOfMonthIso = this.addDaysIso(addedIsoDate, -addedCalendarDate.day);
        const endOfMonthCalendar = this.isoToCalendarDate(endOfMonthIso, cache);
        return endOfMonthCalendar.day;
      }
      daysInPreviousMonth(calendarDate, cache) {
        const { day, month, year } = calendarDate;
        const previousMonthYear = month > 1 ? year : year - 1;
        let previousMonthDate = { year: previousMonthYear, month, day: 1 };
        const previousMonth = month > 1 ? month - 1 : this.monthsInYear(previousMonthDate, cache);
        previousMonthDate = __spreadProps(__spreadValues({}, previousMonthDate), { month: previousMonth });
        const min = this.minimumMonthLength(previousMonthDate);
        const max = this.maximumMonthLength(previousMonthDate);
        if (min === max)
          return max;
        const isoDate = this.calendarToIsoDate(calendarDate, "constrain", cache);
        const lastDayOfPreviousMonthIso = this.addDaysIso(isoDate, -day);
        const lastDayOfPreviousMonthCalendar = this.isoToCalendarDate(lastDayOfPreviousMonthIso, cache);
        return lastDayOfPreviousMonthCalendar.day;
      }
      startOfCalendarYear(calendarDate) {
        return { year: calendarDate.year, month: 1, day: 1 };
      }
      startOfCalendarMonth(calendarDate) {
        return { year: calendarDate.year, month: calendarDate.month, day: 1 };
      }
      calendarDaysUntil(calendarOne, calendarTwo, cache) {
        const oneIso = this.calendarToIsoDate(calendarOne, "constrain", cache);
        const twoIso = this.calendarToIsoDate(calendarTwo, "constrain", cache);
        return this.isoDaysUntil(oneIso, twoIso);
      }
      isoDaysUntil(oneIso, twoIso) {
        const duration2 = DifferenceISODate(oneIso.year, oneIso.month, oneIso.day, twoIso.year, twoIso.month, twoIso.day, "day");
        return duration2.days;
      }
      monthDayFromFields(fields, overflow, cache) {
        let { year, month, monthCode, day, era, eraYear } = fields;
        if (monthCode === void 0) {
          if (year === void 0 && (era === void 0 || eraYear === void 0)) {
            throw new TypeError("`monthCode`, `year`, or `era` and `eraYear` is required");
          }
          ({ monthCode, year } = this.adjustCalendarDate({ year, month, monthCode, day, era, eraYear }, cache, overflow));
        }
        let isoYear, isoMonth, isoDay;
        let closestCalendar, closestIso;
        const startDateIso = { year: 1972, month: 1, day: 1 };
        const { year: calendarYear } = this.isoToCalendarDate(startDateIso, cache);
        for (let i2 = 0; i2 < 100; i2++) {
          const testCalendarDate = this.adjustCalendarDate({ day, monthCode, year: calendarYear - i2 }, cache);
          const isoDate = this.calendarToIsoDate(testCalendarDate, "constrain", cache);
          const roundTripCalendarDate = this.isoToCalendarDate(isoDate, cache);
          ({ year: isoYear, month: isoMonth, day: isoDay } = isoDate);
          if (roundTripCalendarDate.monthCode === monthCode && roundTripCalendarDate.day === day) {
            return { month: isoMonth, day: isoDay, year: isoYear };
          } else if (overflow === "constrain") {
            if (closestCalendar === void 0 || roundTripCalendarDate.monthCode === closestCalendar.monthCode && roundTripCalendarDate.day > closestCalendar.day) {
              closestCalendar = roundTripCalendarDate;
              closestIso = isoDate;
            }
          }
        }
        if (overflow === "constrain" && closestIso !== void 0)
          return closestIso;
        throw new RangeError(`No recent ${this.id} year with monthCode ${monthCode} and day ${day}`);
      }
    };
    HebrewHelper = class extends HelperBase {
      constructor() {
        super(...arguments);
        this.id = "hebrew";
        this.calendarType = "lunisolar";
        this.months = {
          Tishri: { leap: 1, regular: 1, monthCode: "M01", days: 30 },
          Heshvan: { leap: 2, regular: 2, monthCode: "M02", days: { min: 29, max: 30 } },
          Kislev: { leap: 3, regular: 3, monthCode: "M03", days: { min: 29, max: 30 } },
          Tevet: { leap: 4, regular: 4, monthCode: "M04", days: 29 },
          Shevat: { leap: 5, regular: 5, monthCode: "M05", days: 30 },
          Adar: { leap: void 0, regular: 6, monthCode: "M06", days: 29 },
          "Adar I": { leap: 6, regular: void 0, monthCode: "M05L", days: 30 },
          "Adar II": { leap: 7, regular: void 0, monthCode: "M06", days: 29 },
          Nisan: { leap: 8, regular: 7, monthCode: "M07", days: 30 },
          Iyar: { leap: 9, regular: 8, monthCode: "M08", days: 29 },
          Sivan: { leap: 10, regular: 9, monthCode: "M09", days: 30 },
          Tamuz: { leap: 11, regular: 10, monthCode: "M10", days: 29 },
          Av: { leap: 12, regular: 11, monthCode: "M11", days: 30 },
          Elul: { leap: 13, regular: 12, monthCode: "M12", days: 29 }
        };
        this.hasEra = false;
      }
      inLeapYear(calendarDate) {
        const { year } = calendarDate;
        return (7 * year + 1) % 19 < 7;
      }
      monthsInYear(calendarDate) {
        return this.inLeapYear(calendarDate) ? 13 : 12;
      }
      minimumMonthLength(calendarDate) {
        return this.minMaxMonthLength(calendarDate, "min");
      }
      maximumMonthLength(calendarDate) {
        return this.minMaxMonthLength(calendarDate, "max");
      }
      minMaxMonthLength(calendarDate, minOrMax) {
        const { month, year } = calendarDate;
        const monthCode = this.getMonthCode(year, month);
        const monthInfo = ObjectEntries(this.months).find((m2) => m2[1].monthCode === monthCode);
        if (monthInfo === void 0)
          throw new RangeError(`unmatched Hebrew month: ${month}`);
        const daysInMonth = monthInfo[1].days;
        return typeof daysInMonth === "number" ? daysInMonth : daysInMonth[minOrMax];
      }
      estimateIsoDate(calendarDate) {
        const { year } = calendarDate;
        return { year: year - 3760, month: 1, day: 1 };
      }
      getMonthCode(year, month) {
        if (this.inLeapYear({ year })) {
          return month === 6 ? buildMonthCode(5, true) : buildMonthCode(month < 6 ? month : month - 1);
        } else {
          return buildMonthCode(month);
        }
      }
      adjustCalendarDate(calendarDate, cache, overflow = "constrain", fromLegacyDate = false) {
        let { year, eraYear, month, monthCode, day, monthExtra } = calendarDate;
        if (year === void 0 && eraYear !== void 0)
          year = eraYear;
        if (eraYear === void 0 && year !== void 0)
          eraYear = year;
        if (fromLegacyDate) {
          if (monthExtra) {
            const monthInfo = this.months[monthExtra];
            if (!monthInfo)
              throw new RangeError(`Unrecognized month from formatToParts: ${monthExtra}`);
            month = this.inLeapYear({ year }) ? monthInfo.leap : monthInfo.regular;
          }
          monthCode = this.getMonthCode(year, month);
          const result = { year, month, day, era: void 0, eraYear, monthCode };
          return result;
        } else {
          this.validateCalendarDate(calendarDate);
          if (month === void 0) {
            if (monthCode.endsWith("L")) {
              if (monthCode !== "M05L") {
                throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${monthCode}`);
              }
              month = 6;
              if (!this.inLeapYear({ year })) {
                if (overflow === "reject") {
                  throw new RangeError(`Hebrew monthCode M05L is invalid in year ${year} which is not a leap year`);
                } else {
                  month = 5;
                  day = 30;
                  monthCode = "M05";
                }
              }
            } else {
              month = monthCodeNumberPart(monthCode);
              if (this.inLeapYear({ year }) && month > 6)
                month++;
              const largestMonth = this.monthsInYear({ year });
              if (month < 1 || month > largestMonth)
                throw new RangeError(`Invalid monthCode: ${monthCode}`);
            }
          } else {
            if (overflow === "reject") {
              RejectToRange(month, 1, this.monthsInYear({ year }));
              RejectToRange(day, 1, this.maximumMonthLength({ year, month }));
            } else {
              month = ConstrainToRange(month, 1, this.monthsInYear({ year }));
              day = ConstrainToRange(day, 1, this.maximumMonthLength({ year, month }));
            }
            if (monthCode === void 0) {
              monthCode = this.getMonthCode(year, month);
            } else {
              const calculatedMonthCode = this.getMonthCode(year, month);
              if (calculatedMonthCode !== monthCode) {
                throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Hebrew year ${year}`);
              }
            }
          }
          return __spreadProps(__spreadValues({}, calendarDate), { day, month, monthCode, year, eraYear });
        }
      }
    };
    IslamicBaseHelper = class extends HelperBase {
      constructor() {
        super(...arguments);
        this.calendarType = "lunar";
        this.DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30;
        this.DAYS_PER_ISO_YEAR = 365.2425;
        this.constantEra = "ah";
      }
      inLeapYear(calendarDate, cache) {
        const days = this.daysInMonth({ year: calendarDate.year, month: 12, day: 1 }, cache);
        return days === 30;
      }
      monthsInYear() {
        return 12;
      }
      minimumMonthLength() {
        return 29;
      }
      maximumMonthLength() {
        return 30;
      }
      estimateIsoDate(calendarDate) {
        const { year } = this.adjustCalendarDate(calendarDate);
        return { year: MathFloor$1(year * this.DAYS_PER_ISLAMIC_YEAR / this.DAYS_PER_ISO_YEAR) + 622, month: 1, day: 1 };
      }
    };
    IslamicHelper = class extends IslamicBaseHelper {
      constructor() {
        super(...arguments);
        this.id = "islamic";
      }
    };
    IslamicUmalquraHelper = class extends IslamicBaseHelper {
      constructor() {
        super(...arguments);
        this.id = "islamic-umalqura";
      }
    };
    IslamicTblaHelper = class extends IslamicBaseHelper {
      constructor() {
        super(...arguments);
        this.id = "islamic-tbla";
      }
    };
    IslamicCivilHelper = class extends IslamicBaseHelper {
      constructor() {
        super(...arguments);
        this.id = "islamic-civil";
      }
    };
    IslamicRgsaHelper = class extends IslamicBaseHelper {
      constructor() {
        super(...arguments);
        this.id = "islamic-rgsa";
      }
    };
    IslamicCcHelper = class extends IslamicBaseHelper {
      constructor() {
        super(...arguments);
        this.id = "islamicc";
      }
    };
    PersianHelper = class extends HelperBase {
      constructor() {
        super(...arguments);
        this.id = "persian";
        this.calendarType = "solar";
        this.constantEra = "ap";
      }
      inLeapYear(calendarDate, cache) {
        return IslamicHelper.prototype.inLeapYear.call(this, calendarDate, cache);
      }
      monthsInYear() {
        return 12;
      }
      minimumMonthLength(calendarDate) {
        const { month } = calendarDate;
        if (month === 12)
          return 29;
        return month <= 6 ? 31 : 30;
      }
      maximumMonthLength(calendarDate) {
        const { month } = calendarDate;
        if (month === 12)
          return 30;
        return month <= 6 ? 31 : 30;
      }
      estimateIsoDate(calendarDate) {
        const { year } = this.adjustCalendarDate(calendarDate);
        return { year: year + 621, month: 1, day: 1 };
      }
    };
    IndianHelper = class extends HelperBase {
      constructor() {
        super(...arguments);
        this.id = "indian";
        this.calendarType = "solar";
        this.constantEra = "saka";
        this.months = {
          1: { length: 30, month: 3, day: 22, leap: { length: 31, month: 3, day: 21 } },
          2: { length: 31, month: 4, day: 21 },
          3: { length: 31, month: 5, day: 22 },
          4: { length: 31, month: 6, day: 22 },
          5: { length: 31, month: 7, day: 23 },
          6: { length: 31, month: 8, day: 23 },
          7: { length: 30, month: 9, day: 23 },
          8: { length: 30, month: 10, day: 23 },
          9: { length: 30, month: 11, day: 22 },
          10: { length: 30, month: 12, day: 22 },
          11: { length: 30, month: 1, nextYear: true, day: 21 },
          12: { length: 30, month: 2, nextYear: true, day: 20 }
        };
        this.vulnerableToBceBug = new Date("0000-01-01T00:00Z").toLocaleDateString("en-US-u-ca-indian", { timeZone: "UTC" }) !== "10/11/-79 Saka";
      }
      inLeapYear(calendarDate) {
        return isGregorianLeapYear(calendarDate.year + 78);
      }
      monthsInYear() {
        return 12;
      }
      minimumMonthLength(calendarDate) {
        return this.getMonthInfo(calendarDate).length;
      }
      maximumMonthLength(calendarDate) {
        return this.getMonthInfo(calendarDate).length;
      }
      getMonthInfo(calendarDate) {
        const { month } = calendarDate;
        let monthInfo = this.months[month];
        if (monthInfo === void 0)
          throw new RangeError(`Invalid month: ${month}`);
        if (this.inLeapYear(calendarDate) && monthInfo.leap)
          monthInfo = monthInfo.leap;
        return monthInfo;
      }
      estimateIsoDate(calendarDateParam) {
        const calendarDate = this.adjustCalendarDate(calendarDateParam);
        const monthInfo = this.getMonthInfo(calendarDate);
        const isoYear = calendarDate.year + 78 + (monthInfo.nextYear ? 1 : 0);
        const isoMonth = monthInfo.month;
        const isoDay = monthInfo.day;
        const isoDate = AddISODate(isoYear, isoMonth, isoDay, 0, 0, 0, calendarDate.day - 1, "constrain");
        return isoDate;
      }
      checkIcuBugs(isoDate) {
        if (this.vulnerableToBceBug && isoDate.year < 1) {
          throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 0001-01-01 (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)`);
        }
      }
    };
    GregorianBaseHelper = class extends HelperBase {
      constructor(id, originalEras) {
        super();
        this.calendarType = "solar";
        this.v8IsVulnerableToJulianBug = new Date("+001001-01-01T00:00Z").toLocaleDateString("en-US-u-ca-japanese", { timeZone: "UTC" }).startsWith("12");
        this.calendarIsVulnerableToJulianBug = false;
        this.id = id;
        const { eras, anchorEra } = adjustEras(originalEras);
        this.anchorEra = anchorEra;
        this.eras = eras;
      }
      inLeapYear(calendarDate) {
        const { year } = this.estimateIsoDate({ month: 1, day: 1, year: calendarDate.year });
        return isGregorianLeapYear(year);
      }
      monthsInYear() {
        return 12;
      }
      minimumMonthLength(calendarDate) {
        const { month } = calendarDate;
        if (month === 2)
          return this.inLeapYear(calendarDate) ? 29 : 28;
        return [4, 6, 9, 11].indexOf(month) >= 0 ? 30 : 31;
      }
      maximumMonthLength(calendarDate) {
        return this.minimumMonthLength(calendarDate);
      }
      completeEraYear(calendarDate) {
        const checkField = (name, value) => {
          const currentValue = calendarDate[name];
          if (currentValue != null && currentValue != value) {
            throw new RangeError(`Input ${name} ${currentValue} doesn't match calculated value ${value}`);
          }
        };
        const eraFromYear = (year2) => {
          let eraYear2;
          const adjustedCalendarDate = __spreadProps(__spreadValues({}, calendarDate), { year: year2 });
          const matchingEra = this.eras.find((e2, i2) => {
            if (i2 === this.eras.length - 1) {
              if (e2.reverseOf) {
                if (year2 > 0)
                  throw new RangeError(`Signed year ${year2} is invalid for era ${e2.name}`);
                eraYear2 = e2.anchorEpoch.year - year2;
                return true;
              }
              eraYear2 = year2 - e2.anchorEpoch.year + (e2.hasYearZero ? 0 : 1);
              return true;
            }
            const comparison = this.compareCalendarDates(adjustedCalendarDate, e2.anchorEpoch);
            if (comparison >= 0) {
              eraYear2 = year2 - e2.anchorEpoch.year + (e2.hasYearZero ? 0 : 1);
              return true;
            }
            return false;
          });
          if (!matchingEra)
            throw new RangeError(`Year ${year2} was not matched by any era`);
          return { eraYear: eraYear2, era: matchingEra.name };
        };
        let { year, eraYear, era } = calendarDate;
        if (year != null) {
          ({ eraYear, era } = eraFromYear(year));
          checkField("era", era);
          checkField("eraYear", eraYear);
        } else if (eraYear != null) {
          const matchingEra = era === void 0 ? void 0 : this.eras.find((e2) => e2.name === era || e2.genericName === era);
          if (!matchingEra)
            throw new RangeError(`Era ${era} (ISO year ${eraYear}) was not matched by any era`);
          if (eraYear < 1 && matchingEra.reverseOf) {
            throw new RangeError(`Years in ${era} era must be positive, not ${year}`);
          }
          if (matchingEra.reverseOf) {
            year = matchingEra.anchorEpoch.year - eraYear;
          } else {
            year = eraYear + matchingEra.anchorEpoch.year - (matchingEra.hasYearZero ? 0 : 1);
          }
          checkField("year", year);
          ({ eraYear, era } = eraFromYear(year));
        } else {
          throw new RangeError("Either `year` or `eraYear` and `era` are required");
        }
        return __spreadProps(__spreadValues({}, calendarDate), { year, eraYear, era });
      }
      adjustCalendarDate(calendarDateParam, cache, overflow = "constrain") {
        let calendarDate = calendarDateParam;
        const { month, monthCode } = calendarDate;
        if (month === void 0)
          calendarDate = __spreadProps(__spreadValues({}, calendarDate), { month: monthCodeNumberPart(monthCode) });
        this.validateCalendarDate(calendarDate);
        calendarDate = this.completeEraYear(calendarDate);
        return super.adjustCalendarDate(calendarDate, cache, overflow);
      }
      estimateIsoDate(calendarDateParam) {
        const calendarDate = this.adjustCalendarDate(calendarDateParam);
        const { year, month, day } = calendarDate;
        const { anchorEra } = this;
        const isoYearEstimate = year + anchorEra.isoEpoch.year - (anchorEra.hasYearZero ? 0 : 1);
        return RegulateISODate(isoYearEstimate, month, day, "constrain");
      }
      checkIcuBugs(isoDate) {
        if (this.calendarIsVulnerableToJulianBug && this.v8IsVulnerableToJulianBug) {
          const beforeJulianSwitch = CompareISODate(isoDate.year, isoDate.month, isoDate.day, 1582, 10, 15) < 0;
          if (beforeJulianSwitch) {
            throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 1582-10-15 (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)`);
          }
        }
      }
    };
    OrthodoxBaseHelper = class extends GregorianBaseHelper {
      constructor(id, originalEras) {
        super(id, originalEras);
      }
      inLeapYear(calendarDate) {
        const { year } = calendarDate;
        return (year + 1) % 4 === 0;
      }
      monthsInYear() {
        return 13;
      }
      minimumMonthLength(calendarDate) {
        const { month } = calendarDate;
        if (month === 13)
          return this.inLeapYear(calendarDate) ? 6 : 5;
        return 30;
      }
      maximumMonthLength(calendarDate) {
        return this.minimumMonthLength(calendarDate);
      }
    };
    EthioaaHelper = class extends OrthodoxBaseHelper {
      constructor() {
        super("ethioaa", [{ name: "era0", isoEpoch: { year: -5492, month: 7, day: 17 } }]);
      }
    };
    CopticHelper = class extends OrthodoxBaseHelper {
      constructor() {
        super("coptic", [
          { name: "era1", isoEpoch: { year: 284, month: 8, day: 29 } },
          { name: "era0", reverseOf: "era1" }
        ]);
      }
    };
    EthiopicHelper = class extends OrthodoxBaseHelper {
      constructor() {
        super("ethiopic", [
          { name: "era0", isoEpoch: { year: -5492, month: 7, day: 17 } },
          { name: "era1", isoEpoch: { year: 8, month: 8, day: 27 }, anchorEpoch: { year: 5501 } }
        ]);
      }
    };
    RocHelper = class extends GregorianBaseHelper {
      constructor() {
        super("roc", [
          { name: "minguo", isoEpoch: { year: 1912, month: 1, day: 1 } },
          { name: "before-roc", reverseOf: "minguo" }
        ]);
        this.calendarIsVulnerableToJulianBug = true;
      }
    };
    BuddhistHelper = class extends GregorianBaseHelper {
      constructor() {
        super("buddhist", [{ name: "be", hasYearZero: true, isoEpoch: { year: -543, month: 1, day: 1 } }]);
        this.calendarIsVulnerableToJulianBug = true;
      }
    };
    GregoryHelper = class extends GregorianBaseHelper {
      constructor() {
        super("gregory", [
          { name: "ce", isoEpoch: { year: 1, month: 1, day: 1 } },
          { name: "bce", reverseOf: "ce" }
        ]);
      }
      reviseIntlEra(calendarDate) {
        let { era, eraYear } = calendarDate;
        if (era === "bc" || era === "b")
          era = "bce";
        if (era === "ad" || era === "a")
          era = "ce";
        return { era, eraYear };
      }
    };
    JapaneseHelper = class extends GregorianBaseHelper {
      constructor() {
        super("japanese", [
          { name: "reiwa", isoEpoch: { year: 2019, month: 5, day: 1 }, anchorEpoch: { year: 2019, month: 5, day: 1 } },
          { name: "heisei", isoEpoch: { year: 1989, month: 1, day: 8 }, anchorEpoch: { year: 1989, month: 1, day: 8 } },
          { name: "showa", isoEpoch: { year: 1926, month: 12, day: 25 }, anchorEpoch: { year: 1926, month: 12, day: 25 } },
          { name: "taisho", isoEpoch: { year: 1912, month: 7, day: 30 }, anchorEpoch: { year: 1912, month: 7, day: 30 } },
          { name: "meiji", isoEpoch: { year: 1868, month: 9, day: 8 }, anchorEpoch: { year: 1868, month: 9, day: 8 } },
          { name: "ce", isoEpoch: { year: 1, month: 1, day: 1 } },
          { name: "bce", reverseOf: "ce" }
        ]);
        this.calendarIsVulnerableToJulianBug = true;
        this.eraLength = "long";
      }
      reviseIntlEra(calendarDate, isoDate) {
        const { era, eraYear } = calendarDate;
        const { year: isoYear } = isoDate;
        if (this.eras.find((e2) => e2.name === era))
          return { era, eraYear };
        return isoYear < 1 ? { era: "bce", eraYear: 1 - isoYear } : { era: "ce", eraYear: isoYear };
      }
    };
    ChineseBaseHelper = class extends HelperBase {
      constructor() {
        super(...arguments);
        this.calendarType = "lunisolar";
        this.hasEra = false;
      }
      inLeapYear(calendarDate, cache) {
        const months = this.getMonthList(calendarDate.year, cache);
        return ObjectEntries(months).length === 13;
      }
      monthsInYear(calendarDate, cache) {
        return this.inLeapYear(calendarDate, cache) ? 13 : 12;
      }
      minimumMonthLength() {
        return 29;
      }
      maximumMonthLength() {
        return 30;
      }
      getMonthList(calendarYear, cache) {
        if (calendarYear === void 0) {
          throw new TypeError("Missing year");
        }
        const key2 = JSON.stringify({ func: "getMonthList", calendarYear, id: this.id });
        const cached = cache.get(key2);
        if (cached)
          return cached;
        const dateTimeFormat = this.getFormatter();
        const getCalendarDate = (isoYear, daysPastFeb1) => {
          const isoStringFeb1 = toUtcIsoDateString({ isoYear, isoMonth: 2, isoDay: 1 });
          const legacyDate = new Date(isoStringFeb1);
          legacyDate.setUTCDate(daysPastFeb1 + 1);
          const newYearGuess = dateTimeFormat.formatToParts(legacyDate);
          const calendarMonthString2 = newYearGuess.find((tv) => tv.type === "month").value;
          const calendarDay2 = +newYearGuess.find((tv) => tv.type === "day").value;
          let calendarYearToVerify2 = newYearGuess.find((tv) => tv.type === "relatedYear");
          if (calendarYearToVerify2 !== void 0) {
            calendarYearToVerify2 = +calendarYearToVerify2.value;
          } else {
            throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);
          }
          return { calendarMonthString: calendarMonthString2, calendarDay: calendarDay2, calendarYearToVerify: calendarYearToVerify2 };
        };
        let isoDaysDelta = 17;
        let { calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta);
        if (calendarMonthString !== "1") {
          isoDaysDelta += 29;
          ({ calendarMonthString, calendarDay } = getCalendarDate(calendarYear, isoDaysDelta));
        }
        isoDaysDelta -= calendarDay - 5;
        const result = {};
        let monthIndex = 1;
        let oldCalendarDay;
        let oldMonthString;
        let done = false;
        do {
          ({ calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta));
          if (oldCalendarDay) {
            result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;
          }
          if (calendarYearToVerify !== calendarYear) {
            done = true;
          } else {
            result[calendarMonthString] = { monthIndex: monthIndex++ };
            isoDaysDelta += 30;
          }
          oldCalendarDay = calendarDay;
          oldMonthString = calendarMonthString;
        } while (!done);
        result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;
        cache.set(key2, result);
        return result;
      }
      estimateIsoDate(calendarDate) {
        const { year, month } = calendarDate;
        return { year, month: month >= 12 ? 12 : month + 1, day: 1 };
      }
      adjustCalendarDate(calendarDate, cache, overflow = "constrain", fromLegacyDate = false) {
        let { year, month, monthExtra, day, monthCode, eraYear } = calendarDate;
        if (fromLegacyDate) {
          year = eraYear;
          if (monthExtra && monthExtra !== "bis")
            throw new RangeError(`Unexpected leap month suffix: ${monthExtra}`);
          const monthCode2 = buildMonthCode(month, monthExtra !== void 0);
          const monthString = `${month}${monthExtra || ""}`;
          const months = this.getMonthList(year, cache);
          const monthInfo = months[monthString];
          if (monthInfo === void 0)
            throw new RangeError(`Unmatched month ${monthString} in Chinese year ${year}`);
          month = monthInfo.monthIndex;
          return { year, month, day, era: void 0, eraYear, monthCode: monthCode2 };
        } else {
          this.validateCalendarDate(calendarDate);
          if (year === void 0)
            year = eraYear;
          if (eraYear === void 0)
            eraYear = year;
          if (month === void 0) {
            const months = this.getMonthList(year, cache);
            let numberPart = monthCode.replace("L", "bis").slice(1);
            if (numberPart[0] === "0")
              numberPart = numberPart.slice(1);
            let monthInfo = months[numberPart];
            month = monthInfo && monthInfo.monthIndex;
            if (month === void 0 && monthCode.endsWith("L") && !ArrayIncludes.call(["M01L", "M12L", "M13L"], monthCode) && overflow === "constrain") {
              let withoutML = monthCode.slice(1, -1);
              if (withoutML[0] === "0")
                withoutML = withoutML.slice(1);
              monthInfo = months[withoutML];
              if (monthInfo) {
                ({ daysInMonth: day, monthIndex: month } = monthInfo);
                monthCode = buildMonthCode(withoutML);
              }
            }
            if (month === void 0) {
              throw new RangeError(`Unmatched month ${monthCode} in Chinese year ${year}`);
            }
          } else if (monthCode === void 0) {
            const months = this.getMonthList(year, cache);
            const monthEntries = ObjectEntries(months);
            const largestMonth = monthEntries.length;
            if (overflow === "reject") {
              RejectToRange(month, 1, largestMonth);
              RejectToRange(day, 1, this.maximumMonthLength());
            } else {
              month = ConstrainToRange(month, 1, largestMonth);
              day = ConstrainToRange(day, 1, this.maximumMonthLength());
            }
            const matchingMonthEntry = monthEntries.find(([, v]) => v.monthIndex === month);
            if (matchingMonthEntry === void 0) {
              throw new RangeError(`Invalid month ${month} in Chinese year ${year}`);
            }
            monthCode = buildMonthCode(matchingMonthEntry[0].replace("bis", ""), matchingMonthEntry[0].indexOf("bis") !== -1);
          } else {
            const months = this.getMonthList(year, cache);
            let numberPart = monthCode.replace("L", "bis").slice(1);
            if (numberPart[0] === "0")
              numberPart = numberPart.slice(1);
            const monthInfo = months[numberPart];
            if (!monthInfo)
              throw new RangeError(`Unmatched monthCode ${monthCode} in Chinese year ${year}`);
            if (month !== monthInfo.monthIndex) {
              throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Chinese year ${year}`);
            }
          }
          return __spreadProps(__spreadValues({}, calendarDate), {
            year,
            eraYear,
            month,
            monthCode,
            day
          });
        }
      }
    };
    ChineseHelper = class extends ChineseBaseHelper {
      constructor() {
        super(...arguments);
        this.id = "chinese";
      }
    };
    DangiHelper = class extends ChineseBaseHelper {
      constructor() {
        super(...arguments);
        this.id = "dangi";
      }
    };
    nonIsoImpl = {
      helper: void 0,
      dateFromFields(fieldsParam, options, calendar2) {
        const overflow = ToTemporalOverflow(options);
        const cache = new OneObjectCache();
        const fields = PrepareTemporalFields(fieldsParam, [
          ["day"],
          ["era", void 0],
          ["eraYear", void 0],
          ["month", void 0],
          ["monthCode", void 0],
          ["year", void 0]
        ]);
        const { year, month, day } = this.helper.calendarToIsoDate(fields, overflow, cache);
        const result = CreateTemporalDate(year, month, day, calendar2);
        cache.setObject(result);
        return result;
      },
      yearMonthFromFields(fieldsParam, options, calendar2) {
        const overflow = ToTemporalOverflow(options);
        const cache = new OneObjectCache();
        const fields = PrepareTemporalFields(fieldsParam, [
          ["era", void 0],
          ["eraYear", void 0],
          ["month", void 0],
          ["monthCode", void 0],
          ["year", void 0]
        ]);
        const { year, month, day } = this.helper.calendarToIsoDate(__spreadProps(__spreadValues({}, fields), { day: 1 }), overflow, cache);
        const result = CreateTemporalYearMonth(year, month, calendar2, day);
        cache.setObject(result);
        return result;
      },
      monthDayFromFields(fieldsParam, options, calendar2) {
        const overflow = ToTemporalOverflow(options);
        const cache = new OneObjectCache();
        const fields = PrepareTemporalFields(fieldsParam, [
          ["day"],
          ["era", void 0],
          ["eraYear", void 0],
          ["month", void 0],
          ["monthCode", void 0],
          ["year", void 0]
        ]);
        const { year, month, day } = this.helper.monthDayFromFields(fields, overflow, cache);
        const result = CreateTemporalMonthDay(month, day, calendar2, year);
        cache.setObject(result);
        return result;
      },
      fields(fieldsParam) {
        let fields = fieldsParam;
        if (ArrayIncludes.call(fields, "year"))
          fields = [...fields, "era", "eraYear"];
        return fields;
      },
      mergeFields(fields, additionalFields) {
        const fieldsCopy = __spreadValues({}, fields);
        const additionalFieldsCopy = __spreadValues({}, additionalFields);
        const _a4 = fieldsCopy, { month, monthCode, year, era, eraYear } = _a4, original = __objRest(_a4, ["month", "monthCode", "year", "era", "eraYear"]);
        const { month: newMonth, monthCode: newMonthCode, year: newYear, era: newEra, eraYear: newEraYear } = additionalFieldsCopy;
        if (newMonth === void 0 && newMonthCode === void 0) {
          original.month = month;
          original.monthCode = monthCode;
        }
        if (newYear === void 0 && newEra === void 0 && newEraYear === void 0) {
          original.year = year;
        }
        return __spreadValues(__spreadValues({}, original), additionalFieldsCopy);
      },
      dateAdd(date, years, months, weeks, days, overflow, calendar2) {
        const cache = OneObjectCache.getCacheForObject(date);
        const calendarDate = this.helper.temporalToCalendarDate(date, cache);
        const added = this.helper.addCalendar(calendarDate, { years, months, weeks, days }, overflow, cache);
        const isoAdded = this.helper.calendarToIsoDate(added, "constrain", cache);
        const { year, month, day } = isoAdded;
        const newTemporalObject = CreateTemporalDate(year, month, day, calendar2);
        const newCache = new OneObjectCache(cache);
        newCache.setObject(newTemporalObject);
        return newTemporalObject;
      },
      dateUntil(one, two, largestUnit) {
        const cacheOne = OneObjectCache.getCacheForObject(one);
        const cacheTwo = OneObjectCache.getCacheForObject(two);
        const calendarOne = this.helper.temporalToCalendarDate(one, cacheOne);
        const calendarTwo = this.helper.temporalToCalendarDate(two, cacheTwo);
        const result = this.helper.untilCalendar(calendarOne, calendarTwo, largestUnit, cacheOne);
        return result;
      },
      year(date) {
        const cache = OneObjectCache.getCacheForObject(date);
        const calendarDate = this.helper.temporalToCalendarDate(date, cache);
        return calendarDate.year;
      },
      month(date) {
        const cache = OneObjectCache.getCacheForObject(date);
        const calendarDate = this.helper.temporalToCalendarDate(date, cache);
        return calendarDate.month;
      },
      day(date) {
        const cache = OneObjectCache.getCacheForObject(date);
        const calendarDate = this.helper.temporalToCalendarDate(date, cache);
        return calendarDate.day;
      },
      era(date) {
        if (!this.helper.hasEra)
          return void 0;
        const cache = OneObjectCache.getCacheForObject(date);
        const calendarDate = this.helper.temporalToCalendarDate(date, cache);
        return calendarDate.era;
      },
      eraYear(date) {
        if (!this.helper.hasEra)
          return void 0;
        const cache = OneObjectCache.getCacheForObject(date);
        const calendarDate = this.helper.temporalToCalendarDate(date, cache);
        return calendarDate.eraYear;
      },
      monthCode(date) {
        const cache = OneObjectCache.getCacheForObject(date);
        const calendarDate = this.helper.temporalToCalendarDate(date, cache);
        return calendarDate.monthCode;
      },
      dayOfWeek(date) {
        return impl["iso8601"].dayOfWeek(date);
      },
      dayOfYear(date) {
        const cache = OneObjectCache.getCacheForObject(date);
        const calendarDate = this.helper.isoToCalendarDate(date, cache);
        const startOfYear = this.helper.startOfCalendarYear(calendarDate);
        const diffDays = this.helper.calendarDaysUntil(startOfYear, calendarDate, cache);
        return diffDays + 1;
      },
      weekOfYear(date) {
        return impl["iso8601"].weekOfYear(date);
      },
      daysInWeek(date) {
        return impl["iso8601"].daysInWeek(date);
      },
      daysInMonth(date) {
        const cache = OneObjectCache.getCacheForObject(date);
        const calendarDate = this.helper.temporalToCalendarDate(date, cache);
        const max = this.helper.maximumMonthLength(calendarDate);
        const min = this.helper.minimumMonthLength(calendarDate);
        if (max === min)
          return max;
        const startOfMonthCalendar = this.helper.startOfCalendarMonth(calendarDate);
        const startOfNextMonthCalendar = this.helper.addMonthsCalendar(startOfMonthCalendar, 1, "constrain", cache);
        const result = this.helper.calendarDaysUntil(startOfMonthCalendar, startOfNextMonthCalendar, cache);
        return result;
      },
      daysInYear(dateParam) {
        let date = dateParam;
        if (!HasSlot(date, ISO_YEAR))
          date = ToTemporalDate(date);
        const cache = OneObjectCache.getCacheForObject(date);
        const calendarDate = this.helper.temporalToCalendarDate(date, cache);
        const startOfYearCalendar = this.helper.startOfCalendarYear(calendarDate);
        const startOfNextYearCalendar = this.helper.addCalendar(startOfYearCalendar, { years: 1 }, "constrain", cache);
        const result = this.helper.calendarDaysUntil(startOfYearCalendar, startOfNextYearCalendar, cache);
        return result;
      },
      monthsInYear(date) {
        const cache = OneObjectCache.getCacheForObject(date);
        const calendarDate = this.helper.temporalToCalendarDate(date, cache);
        const result = this.helper.monthsInYear(calendarDate, cache);
        return result;
      },
      inLeapYear(dateParam) {
        let date = dateParam;
        if (!HasSlot(date, ISO_YEAR))
          date = ToTemporalDate(date);
        const cache = OneObjectCache.getCacheForObject(date);
        const calendarDate = this.helper.temporalToCalendarDate(date, cache);
        const result = this.helper.inLeapYear(calendarDate, cache);
        return result;
      }
    };
    for (const Helper of [
      HebrewHelper,
      PersianHelper,
      EthiopicHelper,
      EthioaaHelper,
      CopticHelper,
      ChineseHelper,
      DangiHelper,
      RocHelper,
      IndianHelper,
      BuddhistHelper,
      GregoryHelper,
      JapaneseHelper,
      IslamicHelper,
      IslamicUmalquraHelper,
      IslamicTblaHelper,
      IslamicCivilHelper,
      IslamicRgsaHelper,
      IslamicCcHelper
    ]) {
      const helper = new Helper();
      impl[helper.id] = __spreadProps(__spreadValues({}, nonIsoImpl), { helper });
    }
    BUILTIN_CALENDAR_IDS = Object.keys(impl);
    tzComponent = /\.[-A-Za-z_]|\.\.[-A-Za-z._]{1,12}|\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/;
    offsetNoCapture = /(?:[+\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\d{1,9})?)?)?)/;
    timeZoneID = new RegExp(`(?:(?:${tzComponent.source})(?:\\/(?:${tzComponent.source}))*|Etc/GMT[-+]\\d{1,2}|${offsetNoCapture.source})`);
    calComponent = /[A-Za-z0-9]{3,8}/;
    calendarID = new RegExp(`(?:${calComponent.source}(?:-${calComponent.source})*)`);
    yearpart = /(?:[+\u2212-]\d{6}|\d{4})/;
    monthpart = /(?:0[1-9]|1[0-2])/;
    daypart = /(?:0[1-9]|[12]\d|3[01])/;
    datesplit = new RegExp(`(${yearpart.source})(?:-(${monthpart.source})-(${daypart.source})|(${monthpart.source})(${daypart.source}))`);
    timesplit = /(\d{2})(?::(\d{2})(?::(\d{2})(?:[.,](\d{1,9}))?)?|(\d{2})(?:(\d{2})(?:[.,](\d{1,9}))?)?)?/;
    offset = /([+\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\d{1,9}))?)?)?/;
    zonesplit = new RegExp(`(?:([zZ])|(?:${offset.source})?)(?:\\[(${timeZoneID.source})\\])?`);
    calendar = new RegExp(`\\[u-ca=(${calendarID.source})\\]`);
    zoneddatetime = new RegExp(`^${datesplit.source}(?:(?:T|\\s+)${timesplit.source})?${zonesplit.source}(?:${calendar.source})?$`, "i");
    time = new RegExp(`^T?${timesplit.source}(?:${zonesplit.source})?(?:${calendar.source})?$`, "i");
    yearmonth = new RegExp(`^(${yearpart.source})-?(${monthpart.source})$`);
    monthday = new RegExp(`^(?:--)?(${monthpart.source})-?(${daypart.source})$`);
    fraction = /(\d+)(?:[.,](\d{1,9}))?/;
    durationDate = /(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?/;
    durationTime = new RegExp(`(?:${fraction.source}H)?(?:${fraction.source}M)?(?:${fraction.source}S)?`);
    duration = new RegExp(`^([+\u2212-])?P${durationDate.source}(?:T(?!$)${durationTime.source})?$`, "i");
    ArrayPrototypePush$1 = Array.prototype.push;
    IntlDateTimeFormat$1 = globalThis.Intl.DateTimeFormat;
    MathMin = Math.min;
    MathMax = Math.max;
    MathAbs = Math.abs;
    MathFloor = Math.floor;
    MathSign = Math.sign;
    MathTrunc = Math.trunc;
    NumberIsNaN = Number.isNaN;
    NumberIsFinite = Number.isFinite;
    NumberCtor = Number;
    StringCtor = String;
    NumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;
    ObjectCreate$2 = Object.create;
    ObjectDefineProperty = Object.defineProperty;
    ObjectIs = Object.is;
    ReflectApply$1 = Reflect.apply;
    ZERO = import_jsbi.default.BigInt(0);
    ONE = import_jsbi.default.BigInt(1);
    SIXTY = import_jsbi.default.BigInt(60);
    THOUSAND = import_jsbi.default.BigInt(1e3);
    MILLION = import_jsbi.default.BigInt(1e6);
    BILLION = import_jsbi.default.BigInt(1e9);
    NEGATIVE_ONE = import_jsbi.default.BigInt(-1);
    DAY_SECONDS = 86400;
    DAY_NANOS = import_jsbi.default.multiply(import_jsbi.default.BigInt(DAY_SECONDS), BILLION);
    NS_MIN = import_jsbi.default.multiply(import_jsbi.default.BigInt(-86400), import_jsbi.default.BigInt(1e17));
    NS_MAX = import_jsbi.default.multiply(import_jsbi.default.BigInt(86400), import_jsbi.default.BigInt(1e17));
    YEAR_MIN = -271821;
    YEAR_MAX = 275760;
    BEFORE_FIRST_OFFSET_TRANSITION = import_jsbi.default.multiply(import_jsbi.default.BigInt(-388152), import_jsbi.default.BigInt(1e13));
    ABOUT_TEN_YEARS_NANOS = import_jsbi.default.multiply(DAY_NANOS, import_jsbi.default.BigInt(366 * 10));
    ABOUT_ONE_YEAR_NANOS = import_jsbi.default.multiply(DAY_NANOS, import_jsbi.default.BigInt(366 * 1));
    TWO_WEEKS_NANOS = import_jsbi.default.multiply(DAY_NANOS, import_jsbi.default.BigInt(2 * 7));
    BUILTIN_CASTS = /* @__PURE__ */ new Map([
      ["year", ToIntegerThrowOnInfinity],
      ["month", ToPositiveInteger],
      ["monthCode", ToString],
      ["day", ToPositiveInteger],
      ["hour", ToIntegerThrowOnInfinity],
      ["minute", ToIntegerThrowOnInfinity],
      ["second", ToIntegerThrowOnInfinity],
      ["millisecond", ToIntegerThrowOnInfinity],
      ["microsecond", ToIntegerThrowOnInfinity],
      ["nanosecond", ToIntegerThrowOnInfinity],
      ["years", ToIntegerWithoutRounding],
      ["months", ToIntegerWithoutRounding],
      ["weeks", ToIntegerWithoutRounding],
      ["days", ToIntegerWithoutRounding],
      ["hours", ToIntegerWithoutRounding],
      ["minutes", ToIntegerWithoutRounding],
      ["seconds", ToIntegerWithoutRounding],
      ["milliseconds", ToIntegerWithoutRounding],
      ["microseconds", ToIntegerWithoutRounding],
      ["nanoseconds", ToIntegerWithoutRounding],
      ["era", ToString],
      ["eraYear", ToInteger],
      ["offset", ToString]
    ]);
    ALLOWED_UNITS = [
      "year",
      "month",
      "week",
      "day",
      "hour",
      "minute",
      "second",
      "millisecond",
      "microsecond",
      "nanosecond"
    ];
    SINGULAR_PLURAL_UNITS = [
      ["years", "year"],
      ["months", "month"],
      ["weeks", "week"],
      ["days", "day"],
      ["hours", "hour"],
      ["minutes", "minute"],
      ["seconds", "second"],
      ["milliseconds", "millisecond"],
      ["microseconds", "microsecond"],
      ["nanoseconds", "nanosecond"]
    ];
    IntlDateTimeFormatEnUsCache = /* @__PURE__ */ new Map();
    SystemUTCEpochNanoSeconds = (() => {
      let ns = import_jsbi.default.BigInt(Date.now() % 1e6);
      return () => {
        const ms = import_jsbi.default.BigInt(Date.now());
        const result = import_jsbi.default.add(import_jsbi.default.multiply(ms, MILLION), ns);
        ns = import_jsbi.default.divide(ms, MILLION);
        if (import_jsbi.default.greaterThan(result, NS_MAX))
          return NS_MAX;
        if (import_jsbi.default.lessThan(result, NS_MIN))
          return NS_MIN;
        return result;
      };
    })();
    OFFSET = new RegExp(`^${offset.source}$`);
    nsPerTimeUnit = {
      hour: 36e11,
      minute: 6e10,
      second: 1e9,
      millisecond: 1e6,
      microsecond: 1e3,
      nanosecond: 1
    };
    DATE = Symbol("date");
    YM = Symbol("ym");
    MD = Symbol("md");
    TIME = Symbol("time");
    DATETIME = Symbol("datetime");
    ZONED = Symbol("zoneddatetime");
    INST = Symbol("instant");
    ORIGINAL = Symbol("original");
    TZ_RESOLVED = Symbol("timezone");
    TZ_GIVEN = Symbol("timezone-id-given");
    CAL_ID = Symbol("calendar-id");
    LOCALE = Symbol("locale");
    OPTIONS = Symbol("options");
    descriptor = (value) => {
      return {
        value,
        enumerable: true,
        writable: false,
        configurable: true
      };
    };
    IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;
    ObjectAssign$1 = Object.assign;
    ObjectHasOwnProperty = Object.prototype.hasOwnProperty;
    ReflectApply = Reflect.apply;
    Object.defineProperty(DateTimeFormatImpl, "name", {
      writable: true,
      value: "DateTimeFormat"
    });
    DateTimeFormatImpl.supportedLocalesOf = function(locales, options) {
      return IntlDateTimeFormat.supportedLocalesOf(locales, options);
    };
    properties = {
      resolvedOptions: descriptor(resolvedOptions),
      format: descriptor(format2),
      formatRange: descriptor(formatRange)
    };
    if ("formatToParts" in IntlDateTimeFormat.prototype) {
      properties.formatToParts = descriptor(formatToParts);
    }
    if ("formatRangeToParts" in IntlDateTimeFormat.prototype) {
      properties.formatRangeToParts = descriptor(formatRangeToParts);
    }
    DateTimeFormatImpl.prototype = Object.create(IntlDateTimeFormat.prototype, properties);
    Object.defineProperty(DateTimeFormatImpl, "prototype", {
      writable: false,
      enumerable: false,
      configurable: false
    });
    DateTimeFormat = DateTimeFormatImpl;
    DISALLOWED_UNITS$3 = ["year", "month", "week", "day"];
    MAX_DIFFERENCE_INCREMENTS = {
      hour: 24,
      minute: 60,
      second: 60,
      millisecond: 1e3,
      microsecond: 1e3,
      nanosecond: 1e3
    };
    Instant = class {
      constructor(epochNanoseconds) {
        if (arguments.length < 1) {
          throw new TypeError("missing argument: epochNanoseconds is required");
        }
        const ns = ToBigInt(epochNanoseconds);
        ValidateEpochNanoseconds(ns);
        CreateSlots(this);
        SetSlot(this, EPOCHNANOSECONDS, ns);
        {
          const repr = TemporalInstantToString(this, void 0, "auto");
          Object.defineProperty(this, "_repr_", {
            value: `${this[Symbol.toStringTag]} <${repr}>`,
            writable: false,
            enumerable: false,
            configurable: false
          });
        }
      }
      get epochSeconds() {
        if (!IsTemporalInstant(this))
          throw new TypeError("invalid receiver");
        const value = GetSlot(this, EPOCHNANOSECONDS);
        return import_jsbi.default.toNumber(import_jsbi.default.divide(value, BILLION));
      }
      get epochMilliseconds() {
        if (!IsTemporalInstant(this))
          throw new TypeError("invalid receiver");
        const value = import_jsbi.default.BigInt(GetSlot(this, EPOCHNANOSECONDS));
        return import_jsbi.default.toNumber(import_jsbi.default.divide(value, MILLION));
      }
      get epochMicroseconds() {
        if (!IsTemporalInstant(this))
          throw new TypeError("invalid receiver");
        const value = import_jsbi.default.BigInt(GetSlot(this, EPOCHNANOSECONDS));
        return ToBigIntExternal(import_jsbi.default.divide(value, THOUSAND));
      }
      get epochNanoseconds() {
        if (!IsTemporalInstant(this))
          throw new TypeError("invalid receiver");
        return ToBigIntExternal(import_jsbi.default.BigInt(GetSlot(this, EPOCHNANOSECONDS)));
      }
      add(temporalDurationLike) {
        if (!IsTemporalInstant(this))
          throw new TypeError("invalid receiver");
        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToLimitedTemporalDuration(temporalDurationLike, ["years", "months", "weeks", "days"]);
        const ns = AddInstant(GetSlot(this, EPOCHNANOSECONDS), hours, minutes, seconds, milliseconds, microseconds, nanoseconds);
        return new Instant(ns);
      }
      subtract(temporalDurationLike) {
        if (!IsTemporalInstant(this))
          throw new TypeError("invalid receiver");
        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToLimitedTemporalDuration(temporalDurationLike, ["years", "months", "weeks", "days"]);
        const ns = AddInstant(GetSlot(this, EPOCHNANOSECONDS), -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds);
        return new Instant(ns);
      }
      until(otherParam, optionsParam = void 0) {
        if (!IsTemporalInstant(this))
          throw new TypeError("invalid receiver");
        const other = ToTemporalInstant(otherParam);
        const options = GetOptionsObject(optionsParam);
        const smallestUnit = ToSmallestTemporalUnit(options, "nanosecond", DISALLOWED_UNITS$3);
        const defaultLargestUnit = LargerOfTwoTemporalUnits("second", smallestUnit);
        const largestUnit = ToLargestTemporalUnit(options, "auto", DISALLOWED_UNITS$3, defaultLargestUnit);
        ValidateTemporalUnitRange(largestUnit, smallestUnit);
        const roundingMode = ToTemporalRoundingMode(options, "trunc");
        const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_DIFFERENCE_INCREMENTS[smallestUnit], false);
        const onens = GetSlot(this, EPOCHNANOSECONDS);
        const twons = GetSlot(other, EPOCHNANOSECONDS);
        let { seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(onens, twons, roundingIncrement, smallestUnit, roundingMode);
        let hours, minutes;
        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));
        const Duration2 = GetIntrinsic("%Temporal.Duration%");
        return new Duration2(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);
      }
      since(otherParam, optionsParam = void 0) {
        if (!IsTemporalInstant(this))
          throw new TypeError("invalid receiver");
        const other = ToTemporalInstant(otherParam);
        const options = GetOptionsObject(optionsParam);
        const smallestUnit = ToSmallestTemporalUnit(options, "nanosecond", DISALLOWED_UNITS$3);
        const defaultLargestUnit = LargerOfTwoTemporalUnits("second", smallestUnit);
        const largestUnit = ToLargestTemporalUnit(options, "auto", DISALLOWED_UNITS$3, defaultLargestUnit);
        ValidateTemporalUnitRange(largestUnit, smallestUnit);
        const roundingMode = ToTemporalRoundingMode(options, "trunc");
        const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_DIFFERENCE_INCREMENTS[smallestUnit], false);
        const onens = GetSlot(other, EPOCHNANOSECONDS);
        const twons = GetSlot(this, EPOCHNANOSECONDS);
        let { seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(onens, twons, roundingIncrement, smallestUnit, roundingMode);
        let hours, minutes;
        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));
        const Duration2 = GetIntrinsic("%Temporal.Duration%");
        return new Duration2(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);
      }
      round(optionsParam) {
        if (!IsTemporalInstant(this))
          throw new TypeError("invalid receiver");
        if (optionsParam === void 0)
          throw new TypeError("options parameter is required");
        const options = typeof optionsParam === "string" ? CreateOnePropObject("smallestUnit", optionsParam) : GetOptionsObject(optionsParam);
        const smallestUnit = ToSmallestTemporalUnit(options, void 0, DISALLOWED_UNITS$3);
        if (smallestUnit === void 0)
          throw new RangeError("smallestUnit is required");
        const roundingMode = ToTemporalRoundingMode(options, "halfExpand");
        const maximumIncrements = {
          hour: 24,
          minute: 1440,
          second: 86400,
          millisecond: 864e5,
          microsecond: 864e8,
          nanosecond: 864e11
        };
        const roundingIncrement = ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], true);
        const ns = GetSlot(this, EPOCHNANOSECONDS);
        const roundedNs = RoundInstant(ns, roundingIncrement, smallestUnit, roundingMode);
        return new Instant(roundedNs);
      }
      equals(otherParam) {
        if (!IsTemporalInstant(this))
          throw new TypeError("invalid receiver");
        const other = ToTemporalInstant(otherParam);
        const one = GetSlot(this, EPOCHNANOSECONDS);
        const two = GetSlot(other, EPOCHNANOSECONDS);
        return import_jsbi.default.equal(import_jsbi.default.BigInt(one), import_jsbi.default.BigInt(two));
      }
      toString(optionsParam = void 0) {
        if (!IsTemporalInstant(this))
          throw new TypeError("invalid receiver");
        const options = GetOptionsObject(optionsParam);
        let timeZone2 = options.timeZone;
        if (timeZone2 !== void 0)
          timeZone2 = ToTemporalTimeZone(timeZone2);
        const { precision, unit, increment } = ToSecondsStringPrecision(options);
        const roundingMode = ToTemporalRoundingMode(options, "trunc");
        const ns = GetSlot(this, EPOCHNANOSECONDS);
        const roundedNs = RoundInstant(ns, increment, unit, roundingMode);
        const roundedInstant = new Instant(roundedNs);
        return TemporalInstantToString(roundedInstant, timeZone2, precision);
      }
      toJSON() {
        if (!IsTemporalInstant(this))
          throw new TypeError("invalid receiver");
        return TemporalInstantToString(this, void 0, "auto");
      }
      toLocaleString(locales = void 0, options = void 0) {
        if (!IsTemporalInstant(this))
          throw new TypeError("invalid receiver");
        return new DateTimeFormat(locales, options).format(this);
      }
      valueOf() {
        throw new TypeError("use compare() or equals() to compare Temporal.Instant");
      }
      toZonedDateTime(item) {
        if (!IsTemporalInstant(this))
          throw new TypeError("invalid receiver");
        if (!IsObject(item)) {
          throw new TypeError("invalid argument in toZonedDateTime");
        }
        const calendarLike = item.calendar;
        if (calendarLike === void 0) {
          throw new TypeError("missing calendar property in toZonedDateTime");
        }
        const calendar2 = ToTemporalCalendar(calendarLike);
        const temporalTimeZoneLike = item.timeZone;
        if (temporalTimeZoneLike === void 0) {
          throw new TypeError("missing timeZone property in toZonedDateTime");
        }
        const timeZone2 = ToTemporalTimeZone(temporalTimeZoneLike);
        return CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone2, calendar2);
      }
      toZonedDateTimeISO(itemParam) {
        let item = itemParam;
        if (!IsTemporalInstant(this))
          throw new TypeError("invalid receiver");
        if (IsObject(item)) {
          const timeZoneProperty = item.timeZone;
          if (timeZoneProperty !== void 0) {
            item = timeZoneProperty;
          }
        }
        const timeZone2 = ToTemporalTimeZone(item);
        const calendar2 = GetISO8601Calendar();
        return CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone2, calendar2);
      }
      static fromEpochSeconds(epochSecondsParam) {
        const epochSeconds = ToNumber(epochSecondsParam);
        const epochNanoseconds = import_jsbi.default.multiply(import_jsbi.default.BigInt(epochSeconds), BILLION);
        ValidateEpochNanoseconds(epochNanoseconds);
        return new Instant(epochNanoseconds);
      }
      static fromEpochMilliseconds(epochMillisecondsParam) {
        const epochMilliseconds = ToNumber(epochMillisecondsParam);
        const epochNanoseconds = import_jsbi.default.multiply(import_jsbi.default.BigInt(epochMilliseconds), MILLION);
        ValidateEpochNanoseconds(epochNanoseconds);
        return new Instant(epochNanoseconds);
      }
      static fromEpochMicroseconds(epochMicrosecondsParam) {
        const epochMicroseconds = ToBigInt(epochMicrosecondsParam);
        const epochNanoseconds = import_jsbi.default.multiply(epochMicroseconds, THOUSAND);
        ValidateEpochNanoseconds(epochNanoseconds);
        return new Instant(epochNanoseconds);
      }
      static fromEpochNanoseconds(epochNanosecondsParam) {
        const epochNanoseconds = ToBigInt(epochNanosecondsParam);
        ValidateEpochNanoseconds(epochNanoseconds);
        return new Instant(epochNanoseconds);
      }
      static from(item) {
        if (IsTemporalInstant(item)) {
          return new Instant(GetSlot(item, EPOCHNANOSECONDS));
        }
        return ToTemporalInstant(item);
      }
      static compare(oneParam, twoParam) {
        const one = ToTemporalInstant(oneParam);
        const two = ToTemporalInstant(twoParam);
        const oneNs = GetSlot(one, EPOCHNANOSECONDS);
        const twoNs = GetSlot(two, EPOCHNANOSECONDS);
        if (import_jsbi.default.lessThan(oneNs, twoNs))
          return -1;
        if (import_jsbi.default.greaterThan(oneNs, twoNs))
          return 1;
        return 0;
      }
    };
    MakeIntrinsicClass(Instant, "Temporal.Instant");
    DISALLOWED_UNITS$2 = ["hour", "minute", "second", "millisecond", "microsecond", "nanosecond"];
    PlainDate = class {
      constructor(isoYearParam, isoMonthParam, isoDayParam, calendarParam = GetISO8601Calendar()) {
        const isoYear = ToIntegerThrowOnInfinity(isoYearParam);
        const isoMonth = ToIntegerThrowOnInfinity(isoMonthParam);
        const isoDay = ToIntegerThrowOnInfinity(isoDayParam);
        const calendar2 = ToTemporalCalendar(calendarParam);
        if (arguments.length < 3) {
          throw new RangeError("missing argument: isoYear, isoMonth and isoDay are required");
        }
        CreateTemporalDateSlots(this, isoYear, isoMonth, isoDay, calendar2);
      }
      get calendar() {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, CALENDAR);
      }
      get era() {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        return CalendarEra(GetSlot(this, CALENDAR), this);
      }
      get eraYear() {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        return CalendarEraYear(GetSlot(this, CALENDAR), this);
      }
      get year() {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        return CalendarYear(GetSlot(this, CALENDAR), this);
      }
      get month() {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        return CalendarMonth(GetSlot(this, CALENDAR), this);
      }
      get monthCode() {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        return CalendarMonthCode(GetSlot(this, CALENDAR), this);
      }
      get day() {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        return CalendarDay(GetSlot(this, CALENDAR), this);
      }
      get dayOfWeek() {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        return CalendarDayOfWeek(GetSlot(this, CALENDAR), this);
      }
      get dayOfYear() {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        return CalendarDayOfYear(GetSlot(this, CALENDAR), this);
      }
      get weekOfYear() {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        return CalendarWeekOfYear(GetSlot(this, CALENDAR), this);
      }
      get daysInWeek() {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        return CalendarDaysInWeek(GetSlot(this, CALENDAR), this);
      }
      get daysInMonth() {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        return CalendarDaysInMonth(GetSlot(this, CALENDAR), this);
      }
      get daysInYear() {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        return CalendarDaysInYear(GetSlot(this, CALENDAR), this);
      }
      get monthsInYear() {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        return CalendarMonthsInYear(GetSlot(this, CALENDAR), this);
      }
      get inLeapYear() {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        return CalendarInLeapYear(GetSlot(this, CALENDAR), this);
      }
      with(temporalDateLike, optionsParam = void 0) {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        if (!IsObject(temporalDateLike)) {
          throw new TypeError("invalid argument");
        }
        RejectObjectWithCalendarOrTimeZone(temporalDateLike);
        const calendar2 = GetSlot(this, CALENDAR);
        const fieldNames = CalendarFields(calendar2, ["day", "month", "monthCode", "year"]);
        const props = ToPartialRecord(temporalDateLike, fieldNames);
        if (!props) {
          throw new TypeError("invalid date-like");
        }
        let fields = ToTemporalDateFields(this, fieldNames);
        fields = CalendarMergeFields(calendar2, fields, props);
        fields = ToTemporalDateFields(fields, fieldNames);
        const options = GetOptionsObject(optionsParam);
        return DateFromFields(calendar2, fields, options);
      }
      withCalendar(calendarParam) {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        const calendar2 = ToTemporalCalendar(calendarParam);
        return new PlainDate(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), calendar2);
      }
      add(temporalDurationLike, optionsParam = void 0) {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        const duration2 = ToTemporalDuration(temporalDurationLike);
        const options = GetOptionsObject(optionsParam);
        return CalendarDateAdd(GetSlot(this, CALENDAR), this, duration2, options);
      }
      subtract(temporalDurationLike, optionsParam = void 0) {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        const duration2 = CreateNegatedTemporalDuration(ToTemporalDuration(temporalDurationLike));
        const options = GetOptionsObject(optionsParam);
        return CalendarDateAdd(GetSlot(this, CALENDAR), this, duration2, options);
      }
      until(otherParam, optionsParam = void 0) {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        const other = ToTemporalDate(otherParam);
        const calendar2 = GetSlot(this, CALENDAR);
        const otherCalendar = GetSlot(other, CALENDAR);
        const calendarId = ToString(calendar2);
        const otherCalendarId = ToString(otherCalendar);
        if (calendarId !== otherCalendarId) {
          throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);
        }
        const options = GetOptionsObject(optionsParam);
        const smallestUnit = ToSmallestTemporalUnit(options, "day", DISALLOWED_UNITS$2);
        const defaultLargestUnit = LargerOfTwoTemporalUnits("day", smallestUnit);
        const largestUnit = ToLargestTemporalUnit(options, "auto", DISALLOWED_UNITS$2, defaultLargestUnit);
        ValidateTemporalUnitRange(largestUnit, smallestUnit);
        const roundingMode = ToTemporalRoundingMode(options, "trunc");
        const roundingIncrement = ToTemporalRoundingIncrement(options, void 0, false);
        const untilOptions = __spreadProps(__spreadValues({}, options), { largestUnit });
        const result = CalendarDateUntil(calendar2, this, other, untilOptions);
        if (smallestUnit === "day" && roundingIncrement === 1)
          return result;
        let { years, months, weeks, days } = result;
        ({ years, months, weeks, days } = RoundDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, roundingMode, this));
        const Duration2 = GetIntrinsic("%Temporal.Duration%");
        return new Duration2(years, months, weeks, days, 0, 0, 0, 0, 0, 0);
      }
      since(otherParam, optionsParam = void 0) {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        const other = ToTemporalDate(otherParam);
        const calendar2 = GetSlot(this, CALENDAR);
        const otherCalendar = GetSlot(other, CALENDAR);
        const calendarId = ToString(calendar2);
        const otherCalendarId = ToString(otherCalendar);
        if (calendarId !== otherCalendarId) {
          throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);
        }
        const options = GetOptionsObject(optionsParam);
        const smallestUnit = ToSmallestTemporalUnit(options, "day", DISALLOWED_UNITS$2);
        const defaultLargestUnit = LargerOfTwoTemporalUnits("day", smallestUnit);
        const largestUnit = ToLargestTemporalUnit(options, "auto", DISALLOWED_UNITS$2, defaultLargestUnit);
        ValidateTemporalUnitRange(largestUnit, smallestUnit);
        const roundingMode = ToTemporalRoundingMode(options, "trunc");
        const roundingIncrement = ToTemporalRoundingIncrement(options, void 0, false);
        const untilOptions = __spreadProps(__spreadValues({}, options), { largestUnit });
        let { years, months, weeks, days } = CalendarDateUntil(calendar2, this, other, untilOptions);
        const Duration2 = GetIntrinsic("%Temporal.Duration%");
        if (smallestUnit === "day" && roundingIncrement === 1) {
          return new Duration2(-years, -months, -weeks, -days, 0, 0, 0, 0, 0, 0);
        }
        ({ years, months, weeks, days } = RoundDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, NegateTemporalRoundingMode(roundingMode), this));
        return new Duration2(-years, -months, -weeks, -days, 0, 0, 0, 0, 0, 0);
      }
      equals(otherParam) {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        const other = ToTemporalDate(otherParam);
        for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {
          const val1 = GetSlot(this, slot);
          const val2 = GetSlot(other, slot);
          if (val1 !== val2)
            return false;
        }
        return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));
      }
      toString(optionsParam = void 0) {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        const options = GetOptionsObject(optionsParam);
        const showCalendar = ToShowCalendarOption(options);
        return TemporalDateToString(this, showCalendar);
      }
      toJSON() {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        return TemporalDateToString(this);
      }
      toLocaleString(locales = void 0, options = void 0) {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        return new DateTimeFormat(locales, options).format(this);
      }
      valueOf() {
        throw new TypeError("use compare() or equals() to compare Temporal.PlainDate");
      }
      toPlainDateTime(temporalTimeParam = void 0) {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        const year = GetSlot(this, ISO_YEAR);
        const month = GetSlot(this, ISO_MONTH);
        const day = GetSlot(this, ISO_DAY);
        const calendar2 = GetSlot(this, CALENDAR);
        if (temporalTimeParam === void 0)
          return CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar2);
        const temporalTime = ToTemporalTime(temporalTimeParam);
        const hour = GetSlot(temporalTime, ISO_HOUR);
        const minute = GetSlot(temporalTime, ISO_MINUTE);
        const second = GetSlot(temporalTime, ISO_SECOND);
        const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);
        const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);
        const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);
        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar2);
      }
      toZonedDateTime(item) {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        let timeZone2, temporalTime;
        if (IsObject(item)) {
          const timeZoneLike = item.timeZone;
          if (timeZoneLike === void 0) {
            timeZone2 = ToTemporalTimeZone(item);
          } else {
            timeZone2 = ToTemporalTimeZone(timeZoneLike);
            temporalTime = item.plainTime;
          }
        } else {
          timeZone2 = ToTemporalTimeZone(item);
        }
        const year = GetSlot(this, ISO_YEAR);
        const month = GetSlot(this, ISO_MONTH);
        const day = GetSlot(this, ISO_DAY);
        const calendar2 = GetSlot(this, CALENDAR);
        let hour = 0, minute = 0, second = 0, millisecond = 0, microsecond = 0, nanosecond = 0;
        if (temporalTime !== void 0) {
          temporalTime = ToTemporalTime(temporalTime);
          hour = GetSlot(temporalTime, ISO_HOUR);
          minute = GetSlot(temporalTime, ISO_MINUTE);
          second = GetSlot(temporalTime, ISO_SECOND);
          millisecond = GetSlot(temporalTime, ISO_MILLISECOND);
          microsecond = GetSlot(temporalTime, ISO_MICROSECOND);
          nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);
        }
        const dt = CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar2);
        const instant2 = BuiltinTimeZoneGetInstantFor(timeZone2, dt, "compatible");
        return CreateTemporalZonedDateTime(GetSlot(instant2, EPOCHNANOSECONDS), timeZone2, calendar2);
      }
      toPlainYearMonth() {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        const calendar2 = GetSlot(this, CALENDAR);
        const fieldNames = CalendarFields(calendar2, ["monthCode", "year"]);
        const fields = ToTemporalYearMonthFields(this, fieldNames);
        return YearMonthFromFields(calendar2, fields);
      }
      toPlainMonthDay() {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        const calendar2 = GetSlot(this, CALENDAR);
        const fieldNames = CalendarFields(calendar2, ["day", "monthCode"]);
        const fields = ToTemporalMonthDayFields(this, fieldNames);
        return MonthDayFromFields(calendar2, fields);
      }
      getISOFields() {
        if (!IsTemporalDate(this))
          throw new TypeError("invalid receiver");
        return {
          calendar: GetSlot(this, CALENDAR),
          isoDay: GetSlot(this, ISO_DAY),
          isoMonth: GetSlot(this, ISO_MONTH),
          isoYear: GetSlot(this, ISO_YEAR)
        };
      }
      static from(item, optionsParam = void 0) {
        const options = GetOptionsObject(optionsParam);
        if (IsTemporalDate(item)) {
          ToTemporalOverflow(options);
          return CreateTemporalDate(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR));
        }
        return ToTemporalDate(item, options);
      }
      static compare(oneParam, twoParam) {
        const one = ToTemporalDate(oneParam);
        const two = ToTemporalDate(twoParam);
        return CompareISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY));
      }
    };
    MakeIntrinsicClass(PlainDate, "Temporal.PlainDate");
    PlainDateTime = class {
      constructor(isoYearParam, isoMonthParam, isoDayParam, hourParam = 0, minuteParam = 0, secondParam = 0, millisecondParam = 0, microsecondParam = 0, nanosecondParam = 0, calendarParam = GetISO8601Calendar()) {
        const isoYear = ToIntegerThrowOnInfinity(isoYearParam);
        const isoMonth = ToIntegerThrowOnInfinity(isoMonthParam);
        const isoDay = ToIntegerThrowOnInfinity(isoDayParam);
        const hour = ToIntegerThrowOnInfinity(hourParam);
        const minute = ToIntegerThrowOnInfinity(minuteParam);
        const second = ToIntegerThrowOnInfinity(secondParam);
        const millisecond = ToIntegerThrowOnInfinity(millisecondParam);
        const microsecond = ToIntegerThrowOnInfinity(microsecondParam);
        const nanosecond = ToIntegerThrowOnInfinity(nanosecondParam);
        const calendar2 = ToTemporalCalendar(calendarParam);
        if (arguments.length < 3) {
          throw new RangeError("missing argument: isoYear, isoMonth and isoDay are required");
        }
        CreateTemporalDateTimeSlots(this, isoYear, isoMonth, isoDay, hour, minute, second, millisecond, microsecond, nanosecond, calendar2);
      }
      get calendar() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, CALENDAR);
      }
      get year() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarYear(GetSlot(this, CALENDAR), this);
      }
      get month() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarMonth(GetSlot(this, CALENDAR), this);
      }
      get monthCode() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarMonthCode(GetSlot(this, CALENDAR), this);
      }
      get day() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarDay(GetSlot(this, CALENDAR), this);
      }
      get hour() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, ISO_HOUR);
      }
      get minute() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, ISO_MINUTE);
      }
      get second() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, ISO_SECOND);
      }
      get millisecond() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, ISO_MILLISECOND);
      }
      get microsecond() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, ISO_MICROSECOND);
      }
      get nanosecond() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, ISO_NANOSECOND);
      }
      get era() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarEra(GetSlot(this, CALENDAR), this);
      }
      get eraYear() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarEraYear(GetSlot(this, CALENDAR), this);
      }
      get dayOfWeek() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarDayOfWeek(GetSlot(this, CALENDAR), this);
      }
      get dayOfYear() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarDayOfYear(GetSlot(this, CALENDAR), this);
      }
      get weekOfYear() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarWeekOfYear(GetSlot(this, CALENDAR), this);
      }
      get daysInWeek() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarDaysInWeek(GetSlot(this, CALENDAR), this);
      }
      get daysInYear() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarDaysInYear(GetSlot(this, CALENDAR), this);
      }
      get daysInMonth() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarDaysInMonth(GetSlot(this, CALENDAR), this);
      }
      get monthsInYear() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarMonthsInYear(GetSlot(this, CALENDAR), this);
      }
      get inLeapYear() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarInLeapYear(GetSlot(this, CALENDAR), this);
      }
      with(temporalDateTimeLike, optionsParam = void 0) {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        if (!IsObject(temporalDateTimeLike)) {
          throw new TypeError("invalid argument");
        }
        RejectObjectWithCalendarOrTimeZone(temporalDateTimeLike);
        const options = GetOptionsObject(optionsParam);
        const calendar2 = GetSlot(this, CALENDAR);
        const fieldNames = CalendarFields(calendar2, [
          "day",
          "hour",
          "microsecond",
          "millisecond",
          "minute",
          "month",
          "monthCode",
          "nanosecond",
          "second",
          "year"
        ]);
        const props = ToPartialRecord(temporalDateTimeLike, fieldNames);
        if (!props) {
          throw new TypeError("invalid date-time-like");
        }
        let fields = ToTemporalDateTimeFields(this, fieldNames);
        fields = CalendarMergeFields(calendar2, fields, props);
        fields = ToTemporalDateTimeFields(fields, fieldNames);
        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar2, fields, options);
        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar2);
      }
      withPlainTime(temporalTimeParam = void 0) {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        const year = GetSlot(this, ISO_YEAR);
        const month = GetSlot(this, ISO_MONTH);
        const day = GetSlot(this, ISO_DAY);
        const calendar2 = GetSlot(this, CALENDAR);
        if (temporalTimeParam === void 0)
          return CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar2);
        const temporalTime = ToTemporalTime(temporalTimeParam);
        const hour = GetSlot(temporalTime, ISO_HOUR);
        const minute = GetSlot(temporalTime, ISO_MINUTE);
        const second = GetSlot(temporalTime, ISO_SECOND);
        const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);
        const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);
        const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);
        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar2);
      }
      withPlainDate(temporalDateParam) {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        const temporalDate = ToTemporalDate(temporalDateParam);
        const year = GetSlot(temporalDate, ISO_YEAR);
        const month = GetSlot(temporalDate, ISO_MONTH);
        const day = GetSlot(temporalDate, ISO_DAY);
        let calendar2 = GetSlot(temporalDate, CALENDAR);
        const hour = GetSlot(this, ISO_HOUR);
        const minute = GetSlot(this, ISO_MINUTE);
        const second = GetSlot(this, ISO_SECOND);
        const millisecond = GetSlot(this, ISO_MILLISECOND);
        const microsecond = GetSlot(this, ISO_MICROSECOND);
        const nanosecond = GetSlot(this, ISO_NANOSECOND);
        calendar2 = ConsolidateCalendars(GetSlot(this, CALENDAR), calendar2);
        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar2);
      }
      withCalendar(calendarParam) {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        const calendar2 = ToTemporalCalendar(calendarParam);
        return new PlainDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar2);
      }
      add(temporalDurationLike, optionsParam = void 0) {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        const duration2 = ToLimitedTemporalDuration(temporalDurationLike);
        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration2;
        const options = GetOptionsObject(optionsParam);
        const calendar2 = GetSlot(this, CALENDAR);
        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = AddDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar2, years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options);
        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar2);
      }
      subtract(temporalDurationLike, optionsParam = void 0) {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        const duration2 = ToLimitedTemporalDuration(temporalDurationLike);
        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration2;
        const options = GetOptionsObject(optionsParam);
        const calendar2 = GetSlot(this, CALENDAR);
        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = AddDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar2, -years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, options);
        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar2);
      }
      until(otherParam, optionsParam = void 0) {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        const other = ToTemporalDateTime(otherParam);
        const calendar2 = GetSlot(this, CALENDAR);
        const otherCalendar = GetSlot(other, CALENDAR);
        const calendarId = ToString(calendar2);
        const otherCalendarId = ToString(otherCalendar);
        if (calendarId !== otherCalendarId) {
          throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);
        }
        const options = GetOptionsObject(optionsParam);
        const smallestUnit = ToSmallestTemporalUnit(options, "nanosecond");
        const defaultLargestUnit = LargerOfTwoTemporalUnits("day", smallestUnit);
        const largestUnit = ToLargestTemporalUnit(options, "auto", [], defaultLargestUnit);
        ValidateTemporalUnitRange(largestUnit, smallestUnit);
        const roundingMode = ToTemporalRoundingMode(options, "trunc");
        const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);
        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceISODateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), GetSlot(other, ISO_YEAR), GetSlot(other, ISO_MONTH), GetSlot(other, ISO_DAY), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), calendar2, largestUnit, options);
        const relativeTo = TemporalDateTimeToDate(this);
        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));
        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));
        const Duration2 = GetIntrinsic("%Temporal.Duration%");
        return new Duration2(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);
      }
      since(otherParam, optionsParam = void 0) {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        const other = ToTemporalDateTime(otherParam);
        const calendar2 = GetSlot(this, CALENDAR);
        const otherCalendar = GetSlot(other, CALENDAR);
        const calendarId = ToString(calendar2);
        const otherCalendarId = ToString(otherCalendar);
        if (calendarId !== otherCalendarId) {
          throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);
        }
        const options = GetOptionsObject(optionsParam);
        const smallestUnit = ToSmallestTemporalUnit(options, "nanosecond");
        const defaultLargestUnit = LargerOfTwoTemporalUnits("day", smallestUnit);
        const largestUnit = ToLargestTemporalUnit(options, "auto", [], defaultLargestUnit);
        ValidateTemporalUnitRange(largestUnit, smallestUnit);
        const roundingMode = ToTemporalRoundingMode(options, "trunc");
        const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);
        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceISODateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), GetSlot(other, ISO_YEAR), GetSlot(other, ISO_MONTH), GetSlot(other, ISO_DAY), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), calendar2, largestUnit, options);
        const relativeTo = TemporalDateTimeToDate(this);
        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, NegateTemporalRoundingMode(roundingMode), relativeTo));
        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));
        const Duration2 = GetIntrinsic("%Temporal.Duration%");
        return new Duration2(-years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds);
      }
      round(optionsParam) {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        if (optionsParam === void 0)
          throw new TypeError("options parameter is required");
        const options = typeof optionsParam === "string" ? CreateOnePropObject("smallestUnit", optionsParam) : GetOptionsObject(optionsParam);
        const smallestUnit = ToSmallestTemporalUnit(options, void 0, ["year", "month", "week"]);
        if (smallestUnit === void 0)
          throw new RangeError("smallestUnit is required");
        const roundingMode = ToTemporalRoundingMode(options, "halfExpand");
        const maximumIncrements = {
          day: 1,
          hour: 24,
          minute: 60,
          second: 60,
          millisecond: 1e3,
          microsecond: 1e3,
          nanosecond: 1e3
        };
        const roundingIncrement = ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);
        let year = GetSlot(this, ISO_YEAR);
        let month = GetSlot(this, ISO_MONTH);
        let day = GetSlot(this, ISO_DAY);
        let hour = GetSlot(this, ISO_HOUR);
        let minute = GetSlot(this, ISO_MINUTE);
        let second = GetSlot(this, ISO_SECOND);
        let millisecond = GetSlot(this, ISO_MILLISECOND);
        let microsecond = GetSlot(this, ISO_MICROSECOND);
        let nanosecond = GetSlot(this, ISO_NANOSECOND);
        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode));
        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, GetSlot(this, CALENDAR));
      }
      equals(otherParam) {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        const other = ToTemporalDateTime(otherParam);
        for (const slot of [
          ISO_YEAR,
          ISO_MONTH,
          ISO_DAY,
          ISO_HOUR,
          ISO_MINUTE,
          ISO_SECOND,
          ISO_MILLISECOND,
          ISO_MICROSECOND,
          ISO_NANOSECOND
        ]) {
          const val1 = GetSlot(this, slot);
          const val2 = GetSlot(other, slot);
          if (val1 !== val2)
            return false;
        }
        return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));
      }
      toString(optionsParam = void 0) {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        const options = GetOptionsObject(optionsParam);
        const { precision, unit, increment } = ToSecondsStringPrecision(options);
        const showCalendar = ToShowCalendarOption(options);
        const roundingMode = ToTemporalRoundingMode(options, "trunc");
        return TemporalDateTimeToString(this, precision, showCalendar, { unit, increment, roundingMode });
      }
      toJSON() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return TemporalDateTimeToString(this, "auto");
      }
      toLocaleString(locales = void 0, options = void 0) {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return new DateTimeFormat(locales, options).format(this);
      }
      valueOf() {
        throw new TypeError("use compare() or equals() to compare Temporal.PlainDateTime");
      }
      toZonedDateTime(temporalTimeZoneLike, optionsParam = void 0) {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        const timeZone2 = ToTemporalTimeZone(temporalTimeZoneLike);
        const options = GetOptionsObject(optionsParam);
        const disambiguation = ToTemporalDisambiguation(options);
        const instant2 = BuiltinTimeZoneGetInstantFor(timeZone2, this, disambiguation);
        return CreateTemporalZonedDateTime(GetSlot(instant2, EPOCHNANOSECONDS), timeZone2, GetSlot(this, CALENDAR));
      }
      toPlainDate() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return TemporalDateTimeToDate(this);
      }
      toPlainYearMonth() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        const calendar2 = GetSlot(this, CALENDAR);
        const fieldNames = CalendarFields(calendar2, ["monthCode", "year"]);
        const fields = ToTemporalYearMonthFields(this, fieldNames);
        return YearMonthFromFields(calendar2, fields);
      }
      toPlainMonthDay() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        const calendar2 = GetSlot(this, CALENDAR);
        const fieldNames = CalendarFields(calendar2, ["day", "monthCode"]);
        const fields = ToTemporalMonthDayFields(this, fieldNames);
        return MonthDayFromFields(calendar2, fields);
      }
      toPlainTime() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return TemporalDateTimeToTime(this);
      }
      getISOFields() {
        if (!IsTemporalDateTime(this))
          throw new TypeError("invalid receiver");
        return {
          calendar: GetSlot(this, CALENDAR),
          isoDay: GetSlot(this, ISO_DAY),
          isoHour: GetSlot(this, ISO_HOUR),
          isoMicrosecond: GetSlot(this, ISO_MICROSECOND),
          isoMillisecond: GetSlot(this, ISO_MILLISECOND),
          isoMinute: GetSlot(this, ISO_MINUTE),
          isoMonth: GetSlot(this, ISO_MONTH),
          isoNanosecond: GetSlot(this, ISO_NANOSECOND),
          isoSecond: GetSlot(this, ISO_SECOND),
          isoYear: GetSlot(this, ISO_YEAR)
        };
      }
      static from(item, optionsParam = void 0) {
        const options = GetOptionsObject(optionsParam);
        if (IsTemporalDateTime(item)) {
          ToTemporalOverflow(options);
          return CreateTemporalDateTime(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND), GetSlot(item, CALENDAR));
        }
        return ToTemporalDateTime(item, options);
      }
      static compare(oneParam, twoParam) {
        const one = ToTemporalDateTime(oneParam);
        const two = ToTemporalDateTime(twoParam);
        for (const slot of [
          ISO_YEAR,
          ISO_MONTH,
          ISO_DAY,
          ISO_HOUR,
          ISO_MINUTE,
          ISO_SECOND,
          ISO_MILLISECOND,
          ISO_MICROSECOND,
          ISO_NANOSECOND
        ]) {
          const val1 = GetSlot(one, slot);
          const val2 = GetSlot(two, slot);
          if (val1 !== val2)
            return ComparisonResult(val1 - val2);
        }
        return 0;
      }
    };
    MakeIntrinsicClass(PlainDateTime, "Temporal.PlainDateTime");
    Duration = class {
      constructor(yearsParam = 0, monthsParam = 0, weeksParam = 0, daysParam = 0, hoursParam = 0, minutesParam = 0, secondsParam = 0, millisecondsParam = 0, microsecondsParam = 0, nanosecondsParam = 0) {
        const years = ToIntegerWithoutRounding(yearsParam);
        const months = ToIntegerWithoutRounding(monthsParam);
        const weeks = ToIntegerWithoutRounding(weeksParam);
        const days = ToIntegerWithoutRounding(daysParam);
        const hours = ToIntegerWithoutRounding(hoursParam);
        const minutes = ToIntegerWithoutRounding(minutesParam);
        const seconds = ToIntegerWithoutRounding(secondsParam);
        const milliseconds = ToIntegerWithoutRounding(millisecondsParam);
        const microseconds = ToIntegerWithoutRounding(microsecondsParam);
        const nanoseconds = ToIntegerWithoutRounding(nanosecondsParam);
        const sign = DurationSign(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);
        for (const prop of [years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds]) {
          if (!Number.isFinite(prop))
            throw new RangeError("infinite values not allowed as duration fields");
          const propSign = Math.sign(prop);
          if (propSign !== 0 && propSign !== sign)
            throw new RangeError("mixed-sign values not allowed as duration fields");
        }
        CreateSlots(this);
        SetSlot(this, YEARS, years);
        SetSlot(this, MONTHS, months);
        SetSlot(this, WEEKS, weeks);
        SetSlot(this, DAYS, days);
        SetSlot(this, HOURS, hours);
        SetSlot(this, MINUTES, minutes);
        SetSlot(this, SECONDS, seconds);
        SetSlot(this, MILLISECONDS, milliseconds);
        SetSlot(this, MICROSECONDS, microseconds);
        SetSlot(this, NANOSECONDS, nanoseconds);
        {
          Object.defineProperty(this, "_repr_", {
            value: `${this[Symbol.toStringTag]} <${TemporalDurationToString(this)}>`,
            writable: false,
            enumerable: false,
            configurable: false
          });
        }
      }
      get years() {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, YEARS);
      }
      get months() {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, MONTHS);
      }
      get weeks() {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, WEEKS);
      }
      get days() {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, DAYS);
      }
      get hours() {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, HOURS);
      }
      get minutes() {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, MINUTES);
      }
      get seconds() {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, SECONDS);
      }
      get milliseconds() {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, MILLISECONDS);
      }
      get microseconds() {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, MICROSECONDS);
      }
      get nanoseconds() {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, NANOSECONDS);
      }
      get sign() {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        return DurationSign(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS));
      }
      get blank() {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        return DurationSign(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS)) === 0;
      }
      with(durationLike) {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        const props = ToPartialRecord(durationLike, [
          "days",
          "hours",
          "microseconds",
          "milliseconds",
          "minutes",
          "months",
          "nanoseconds",
          "seconds",
          "weeks",
          "years"
        ]);
        if (!props) {
          throw new TypeError("invalid duration-like");
        }
        const { years = GetSlot(this, YEARS), months = GetSlot(this, MONTHS), weeks = GetSlot(this, WEEKS), days = GetSlot(this, DAYS), hours = GetSlot(this, HOURS), minutes = GetSlot(this, MINUTES), seconds = GetSlot(this, SECONDS), milliseconds = GetSlot(this, MILLISECONDS), microseconds = GetSlot(this, MICROSECONDS), nanoseconds = GetSlot(this, NANOSECONDS) } = props;
        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);
      }
      negated() {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        return CreateNegatedTemporalDuration(this);
      }
      abs() {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        return new Duration(Math.abs(GetSlot(this, YEARS)), Math.abs(GetSlot(this, MONTHS)), Math.abs(GetSlot(this, WEEKS)), Math.abs(GetSlot(this, DAYS)), Math.abs(GetSlot(this, HOURS)), Math.abs(GetSlot(this, MINUTES)), Math.abs(GetSlot(this, SECONDS)), Math.abs(GetSlot(this, MILLISECONDS)), Math.abs(GetSlot(this, MICROSECONDS)), Math.abs(GetSlot(this, NANOSECONDS)));
      }
      add(other, optionsParam = void 0) {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToLimitedTemporalDuration(other);
        const options = GetOptionsObject(optionsParam);
        const relativeTo = ToRelativeTemporalObject(options);
        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = AddDuration(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS), years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, relativeTo));
        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);
      }
      subtract(other, optionsParam = void 0) {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToLimitedTemporalDuration(other);
        const options = GetOptionsObject(optionsParam);
        const relativeTo = ToRelativeTemporalObject(options);
        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = AddDuration(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS), -years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, relativeTo));
        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);
      }
      round(optionsParam) {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        if (optionsParam === void 0)
          throw new TypeError("options parameter is required");
        let years = GetSlot(this, YEARS);
        let months = GetSlot(this, MONTHS);
        let weeks = GetSlot(this, WEEKS);
        let days = GetSlot(this, DAYS);
        let hours = GetSlot(this, HOURS);
        let minutes = GetSlot(this, MINUTES);
        let seconds = GetSlot(this, SECONDS);
        let milliseconds = GetSlot(this, MILLISECONDS);
        let microseconds = GetSlot(this, MICROSECONDS);
        let nanoseconds = GetSlot(this, NANOSECONDS);
        let defaultLargestUnit = DefaultTemporalLargestUnit(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);
        const options = typeof optionsParam === "string" ? CreateOnePropObject("smallestUnit", optionsParam) : GetOptionsObject(optionsParam);
        let smallestUnit = ToSmallestTemporalUnit(options, void 0);
        let smallestUnitPresent = true;
        if (!smallestUnit) {
          smallestUnitPresent = false;
          smallestUnit = "nanosecond";
        }
        defaultLargestUnit = LargerOfTwoTemporalUnits(defaultLargestUnit, smallestUnit);
        let largestUnit = ToLargestTemporalUnit(options, void 0);
        let largestUnitPresent = true;
        if (!largestUnit) {
          largestUnitPresent = false;
          largestUnit = defaultLargestUnit;
        }
        if (largestUnit === "auto")
          largestUnit = defaultLargestUnit;
        if (!smallestUnitPresent && !largestUnitPresent) {
          throw new RangeError("at least one of smallestUnit or largestUnit is required");
        }
        ValidateTemporalUnitRange(largestUnit, smallestUnit);
        const roundingMode = ToTemporalRoundingMode(options, "halfExpand");
        const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);
        let relativeTo = ToRelativeTemporalObject(options);
        ({ years, months, weeks, days } = UnbalanceDurationRelative(years, months, weeks, days, largestUnit, relativeTo));
        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));
        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));
        ({ years, months, weeks, days } = BalanceDurationRelative(years, months, weeks, days, largestUnit, relativeTo));
        if (IsTemporalZonedDateTime(relativeTo)) {
          relativeTo = MoveRelativeZonedDateTime(relativeTo, years, months, weeks, 0);
        }
        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit, relativeTo));
        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);
      }
      total(optionsParam) {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        let years = GetSlot(this, YEARS);
        let months = GetSlot(this, MONTHS);
        let weeks = GetSlot(this, WEEKS);
        let days = GetSlot(this, DAYS);
        let hours = GetSlot(this, HOURS);
        let minutes = GetSlot(this, MINUTES);
        let seconds = GetSlot(this, SECONDS);
        let milliseconds = GetSlot(this, MILLISECONDS);
        let microseconds = GetSlot(this, MICROSECONDS);
        let nanoseconds = GetSlot(this, NANOSECONDS);
        if (optionsParam === void 0)
          throw new TypeError("options argument is required");
        const options = typeof optionsParam === "string" ? CreateOnePropObject("unit", optionsParam) : GetOptionsObject(optionsParam);
        const unit = ToTemporalDurationTotalUnit(options);
        if (unit === void 0)
          throw new RangeError("unit option is required");
        const relativeTo = ToRelativeTemporalObject(options);
        ({ years, months, weeks, days } = UnbalanceDurationRelative(years, months, weeks, days, unit, relativeTo));
        let intermediate;
        if (IsTemporalZonedDateTime(relativeTo)) {
          intermediate = MoveRelativeZonedDateTime(relativeTo, years, months, weeks, 0);
        }
        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, unit, intermediate));
        const { total } = RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 1, unit, "trunc", relativeTo);
        return total;
      }
      toString(optionsParam = void 0) {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        const options = GetOptionsObject(optionsParam);
        const { precision, unit, increment } = ToSecondsStringPrecision(options);
        if (precision === "minute")
          throw new RangeError('smallestUnit must not be "minute"');
        const roundingMode = ToTemporalRoundingMode(options, "trunc");
        return TemporalDurationToString(this, precision, { unit, increment, roundingMode });
      }
      toJSON() {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        return TemporalDurationToString(this);
      }
      toLocaleString(locales = void 0, options = void 0) {
        if (!IsTemporalDuration(this))
          throw new TypeError("invalid receiver");
        if (typeof Intl !== "undefined" && typeof Intl.DurationFormat !== "undefined") {
          return new Intl.DurationFormat(locales, options).format(this);
        }
        console.warn("Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat.");
        return TemporalDurationToString(this);
      }
      valueOf() {
        throw new TypeError("use compare() to compare Temporal.Duration");
      }
      static from(item) {
        if (IsTemporalDuration(item)) {
          return new Duration(GetSlot(item, YEARS), GetSlot(item, MONTHS), GetSlot(item, WEEKS), GetSlot(item, DAYS), GetSlot(item, HOURS), GetSlot(item, MINUTES), GetSlot(item, SECONDS), GetSlot(item, MILLISECONDS), GetSlot(item, MICROSECONDS), GetSlot(item, NANOSECONDS));
        }
        return ToTemporalDuration(item);
      }
      static compare(oneParam, twoParam, optionsParam = void 0) {
        const one = ToTemporalDuration(oneParam);
        const two = ToTemporalDuration(twoParam);
        const options = GetOptionsObject(optionsParam);
        const relativeTo = ToRelativeTemporalObject(options);
        const y1 = GetSlot(one, YEARS);
        const mon1 = GetSlot(one, MONTHS);
        const w1 = GetSlot(one, WEEKS);
        let d1 = GetSlot(one, DAYS);
        const h1 = GetSlot(one, HOURS);
        const min1 = GetSlot(one, MINUTES);
        const s1 = GetSlot(one, SECONDS);
        const ms1 = GetSlot(one, MILLISECONDS);
        const \u00B5s1 = GetSlot(one, MICROSECONDS);
        let ns1 = GetSlot(one, NANOSECONDS);
        const y2 = GetSlot(two, YEARS);
        const mon2 = GetSlot(two, MONTHS);
        const w2 = GetSlot(two, WEEKS);
        let d2 = GetSlot(two, DAYS);
        const h2 = GetSlot(two, HOURS);
        const min2 = GetSlot(two, MINUTES);
        const s22 = GetSlot(two, SECONDS);
        const ms2 = GetSlot(two, MILLISECONDS);
        const \u00B5s2 = GetSlot(two, MICROSECONDS);
        let ns2 = GetSlot(two, NANOSECONDS);
        const shift1 = CalculateOffsetShift(relativeTo, y1, mon1, w1, d1, h1, min1, s1, ms1, \u00B5s1, ns1);
        const shift2 = CalculateOffsetShift(relativeTo, y2, mon2, w2, d2, h2, min2, s22, ms2, \u00B5s2, ns2);
        if (y1 !== 0 || y2 !== 0 || mon1 !== 0 || mon2 !== 0 || w1 !== 0 || w2 !== 0) {
          ({ days: d1 } = UnbalanceDurationRelative(y1, mon1, w1, d1, "day", relativeTo));
          ({ days: d2 } = UnbalanceDurationRelative(y2, mon2, w2, d2, "day", relativeTo));
        }
        const totalNs1 = TotalDurationNanoseconds(d1, h1, min1, s1, ms1, \u00B5s1, ns1, shift1);
        const totalNs2 = TotalDurationNanoseconds(d2, h2, min2, s22, ms2, \u00B5s2, ns2, shift2);
        return ComparisonResult(import_jsbi.default.toNumber(import_jsbi.default.subtract(totalNs1, totalNs2)));
      }
    };
    MakeIntrinsicClass(Duration, "Temporal.Duration");
    ObjectCreate$1 = Object.create;
    PlainMonthDay = class {
      constructor(isoMonthParam, isoDayParam, calendarParam = GetISO8601Calendar(), referenceISOYearParam = 1972) {
        const isoMonth = ToIntegerThrowOnInfinity(isoMonthParam);
        const isoDay = ToIntegerThrowOnInfinity(isoDayParam);
        const calendar2 = ToTemporalCalendar(calendarParam);
        const referenceISOYear = ToIntegerThrowOnInfinity(referenceISOYearParam);
        if (arguments.length < 2) {
          throw new RangeError("missing argument: isoMonth and isoDay are required");
        }
        CreateTemporalMonthDaySlots(this, isoMonth, isoDay, calendar2, referenceISOYear);
      }
      get monthCode() {
        if (!IsTemporalMonthDay(this))
          throw new TypeError("invalid receiver");
        return CalendarMonthCode(GetSlot(this, CALENDAR), this);
      }
      get day() {
        if (!IsTemporalMonthDay(this))
          throw new TypeError("invalid receiver");
        return CalendarDay(GetSlot(this, CALENDAR), this);
      }
      get calendar() {
        if (!IsTemporalMonthDay(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, CALENDAR);
      }
      with(temporalMonthDayLike, optionsParam = void 0) {
        if (!IsTemporalMonthDay(this))
          throw new TypeError("invalid receiver");
        if (!IsObject(temporalMonthDayLike)) {
          throw new TypeError("invalid argument");
        }
        RejectObjectWithCalendarOrTimeZone(temporalMonthDayLike);
        const calendar2 = GetSlot(this, CALENDAR);
        const fieldNames = CalendarFields(calendar2, ["day", "month", "monthCode", "year"]);
        const props = ToPartialRecord(temporalMonthDayLike, fieldNames);
        if (!props) {
          throw new TypeError("invalid month-day-like");
        }
        let fields = ToTemporalMonthDayFields(this, fieldNames);
        fields = CalendarMergeFields(calendar2, fields, props);
        fields = ToTemporalMonthDayFields(fields, fieldNames);
        const options = GetOptionsObject(optionsParam);
        return MonthDayFromFields(calendar2, fields, options);
      }
      equals(otherParam) {
        if (!IsTemporalMonthDay(this))
          throw new TypeError("invalid receiver");
        const other = ToTemporalMonthDay(otherParam);
        for (const slot of [ISO_MONTH, ISO_DAY, ISO_YEAR]) {
          const val1 = GetSlot(this, slot);
          const val2 = GetSlot(other, slot);
          if (val1 !== val2)
            return false;
        }
        return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));
      }
      toString(optionsParam = void 0) {
        if (!IsTemporalMonthDay(this))
          throw new TypeError("invalid receiver");
        const options = GetOptionsObject(optionsParam);
        const showCalendar = ToShowCalendarOption(options);
        return TemporalMonthDayToString(this, showCalendar);
      }
      toJSON() {
        if (!IsTemporalMonthDay(this))
          throw new TypeError("invalid receiver");
        return TemporalMonthDayToString(this);
      }
      toLocaleString(locales = void 0, options = void 0) {
        if (!IsTemporalMonthDay(this))
          throw new TypeError("invalid receiver");
        return new DateTimeFormat(locales, options).format(this);
      }
      valueOf() {
        throw new TypeError("use equals() to compare Temporal.PlainMonthDay");
      }
      toPlainDate(item) {
        if (!IsTemporalMonthDay(this))
          throw new TypeError("invalid receiver");
        if (!IsObject(item))
          throw new TypeError("argument should be an object");
        const calendar2 = GetSlot(this, CALENDAR);
        const receiverFieldNames = CalendarFields(calendar2, ["day", "monthCode"]);
        const fields = ToTemporalMonthDayFields(this, receiverFieldNames);
        const inputFieldNames = CalendarFields(calendar2, ["year"]);
        const inputEntries = [["year", void 0]];
        inputFieldNames.forEach((fieldName) => {
          if (!inputEntries.some(([name]) => name === fieldName)) {
            inputEntries.push([fieldName, void 0]);
          }
        });
        const inputFields = PrepareTemporalFields(item, inputEntries);
        let mergedFields = CalendarMergeFields(calendar2, fields, inputFields);
        const mergedFieldNames = [.../* @__PURE__ */ new Set([...receiverFieldNames, ...inputFieldNames])];
        const mergedEntries = [];
        mergedFieldNames.forEach((fieldName) => {
          if (!mergedEntries.some(([name]) => name === fieldName)) {
            mergedEntries.push([fieldName, void 0]);
          }
        });
        mergedFields = PrepareTemporalFields(mergedFields, mergedEntries);
        const options = ObjectCreate$1(null);
        options.overflow = "reject";
        return DateFromFields(calendar2, mergedFields, options);
      }
      getISOFields() {
        if (!IsTemporalMonthDay(this))
          throw new TypeError("invalid receiver");
        return {
          calendar: GetSlot(this, CALENDAR),
          isoDay: GetSlot(this, ISO_DAY),
          isoMonth: GetSlot(this, ISO_MONTH),
          isoYear: GetSlot(this, ISO_YEAR)
        };
      }
      static from(item, optionsParam = void 0) {
        const options = GetOptionsObject(optionsParam);
        if (IsTemporalMonthDay(item)) {
          ToTemporalOverflow(options);
          return CreateTemporalMonthDay(GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR), GetSlot(item, ISO_YEAR));
        }
        return ToTemporalMonthDay(item, options);
      }
    };
    MakeIntrinsicClass(PlainMonthDay, "Temporal.PlainMonthDay");
    instant = () => {
      const Instant2 = GetIntrinsic("%Temporal.Instant%");
      return new Instant2(SystemUTCEpochNanoSeconds());
    };
    plainDateTime = (calendarLike, temporalTimeZoneLike = timeZone()) => {
      const tZ = ToTemporalTimeZone(temporalTimeZoneLike);
      const calendar2 = ToTemporalCalendar(calendarLike);
      const inst = instant();
      return BuiltinTimeZoneGetPlainDateTimeFor(tZ, inst, calendar2);
    };
    plainDateTimeISO = (temporalTimeZoneLike = timeZone()) => {
      const tZ = ToTemporalTimeZone(temporalTimeZoneLike);
      const calendar2 = GetISO8601Calendar();
      const inst = instant();
      return BuiltinTimeZoneGetPlainDateTimeFor(tZ, inst, calendar2);
    };
    zonedDateTime = (calendarLike, temporalTimeZoneLike = timeZone()) => {
      const tZ = ToTemporalTimeZone(temporalTimeZoneLike);
      const calendar2 = ToTemporalCalendar(calendarLike);
      return CreateTemporalZonedDateTime(SystemUTCEpochNanoSeconds(), tZ, calendar2);
    };
    zonedDateTimeISO = (temporalTimeZoneLike = timeZone()) => {
      return zonedDateTime(GetISO8601Calendar(), temporalTimeZoneLike);
    };
    plainDate = (calendarLike, temporalTimeZoneLike = timeZone()) => {
      return TemporalDateTimeToDate(plainDateTime(calendarLike, temporalTimeZoneLike));
    };
    plainDateISO = (temporalTimeZoneLike = timeZone()) => {
      return TemporalDateTimeToDate(plainDateTimeISO(temporalTimeZoneLike));
    };
    plainTimeISO = (temporalTimeZoneLike = timeZone()) => {
      return TemporalDateTimeToTime(plainDateTimeISO(temporalTimeZoneLike));
    };
    timeZone = () => {
      return SystemTimeZone();
    };
    Now = {
      instant,
      plainDateTime,
      plainDateTimeISO,
      plainDate,
      plainDateISO,
      plainTimeISO,
      timeZone,
      zonedDateTime,
      zonedDateTimeISO,
      [Symbol.toStringTag]: "Temporal.Now"
    };
    Object.defineProperty(Now, Symbol.toStringTag, {
      value: "Temporal.Now",
      writable: false,
      enumerable: false,
      configurable: true
    });
    ObjectAssign = Object.assign;
    DISALLOWED_UNITS$1 = ["year", "month", "week", "day"];
    MAX_INCREMENTS = {
      hour: 24,
      minute: 60,
      second: 60,
      millisecond: 1e3,
      microsecond: 1e3,
      nanosecond: 1e3
    };
    PlainTime = class {
      constructor(isoHourParam = 0, isoMinuteParam = 0, isoSecondParam = 0, isoMillisecondParam = 0, isoMicrosecondParam = 0, isoNanosecondParam = 0) {
        const isoHour = ToIntegerThrowOnInfinity(isoHourParam);
        const isoMinute = ToIntegerThrowOnInfinity(isoMinuteParam);
        const isoSecond = ToIntegerThrowOnInfinity(isoSecondParam);
        const isoMillisecond = ToIntegerThrowOnInfinity(isoMillisecondParam);
        const isoMicrosecond = ToIntegerThrowOnInfinity(isoMicrosecondParam);
        const isoNanosecond = ToIntegerThrowOnInfinity(isoNanosecondParam);
        RejectTime(isoHour, isoMinute, isoSecond, isoMillisecond, isoMicrosecond, isoNanosecond);
        CreateSlots(this);
        SetSlot(this, ISO_HOUR, isoHour);
        SetSlot(this, ISO_MINUTE, isoMinute);
        SetSlot(this, ISO_SECOND, isoSecond);
        SetSlot(this, ISO_MILLISECOND, isoMillisecond);
        SetSlot(this, ISO_MICROSECOND, isoMicrosecond);
        SetSlot(this, ISO_NANOSECOND, isoNanosecond);
        SetSlot(this, CALENDAR, GetISO8601Calendar());
        {
          Object.defineProperty(this, "_repr_", {
            value: `${this[Symbol.toStringTag]} <${TemporalTimeToString(this, "auto")}>`,
            writable: false,
            enumerable: false,
            configurable: false
          });
        }
      }
      get calendar() {
        if (!IsTemporalTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, CALENDAR);
      }
      get hour() {
        if (!IsTemporalTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, ISO_HOUR);
      }
      get minute() {
        if (!IsTemporalTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, ISO_MINUTE);
      }
      get second() {
        if (!IsTemporalTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, ISO_SECOND);
      }
      get millisecond() {
        if (!IsTemporalTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, ISO_MILLISECOND);
      }
      get microsecond() {
        if (!IsTemporalTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, ISO_MICROSECOND);
      }
      get nanosecond() {
        if (!IsTemporalTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, ISO_NANOSECOND);
      }
      with(temporalTimeLike, optionsParam = void 0) {
        if (!IsTemporalTime(this))
          throw new TypeError("invalid receiver");
        if (!IsObject(temporalTimeLike)) {
          throw new TypeError("invalid argument");
        }
        RejectObjectWithCalendarOrTimeZone(temporalTimeLike);
        const options = GetOptionsObject(optionsParam);
        const overflow = ToTemporalOverflow(options);
        const props = ToPartialRecord(temporalTimeLike, [
          "hour",
          "microsecond",
          "millisecond",
          "minute",
          "nanosecond",
          "second"
        ]);
        if (!props) {
          throw new TypeError("invalid time-like");
        }
        const fields = ToTemporalTimeRecord(this);
        let { hour, minute, second, millisecond, microsecond, nanosecond } = ObjectAssign(fields, props);
        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));
        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);
      }
      add(temporalDurationLike) {
        if (!IsTemporalTime(this))
          throw new TypeError("invalid receiver");
        const duration2 = ToLimitedTemporalDuration(temporalDurationLike);
        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration2;
        let hour = GetSlot(this, ISO_HOUR);
        let minute = GetSlot(this, ISO_MINUTE);
        let second = GetSlot(this, ISO_SECOND);
        let millisecond = GetSlot(this, ISO_MILLISECOND);
        let microsecond = GetSlot(this, ISO_MICROSECOND);
        let nanosecond = GetSlot(this, ISO_NANOSECOND);
        ({ hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(hour, minute, second, millisecond, microsecond, nanosecond, hours, minutes, seconds, milliseconds, microseconds, nanoseconds));
        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, "reject"));
        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);
      }
      subtract(temporalDurationLike) {
        if (!IsTemporalTime(this))
          throw new TypeError("invalid receiver");
        const duration2 = ToLimitedTemporalDuration(temporalDurationLike);
        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration2;
        let hour = GetSlot(this, ISO_HOUR);
        let minute = GetSlot(this, ISO_MINUTE);
        let second = GetSlot(this, ISO_SECOND);
        let millisecond = GetSlot(this, ISO_MILLISECOND);
        let microsecond = GetSlot(this, ISO_MICROSECOND);
        let nanosecond = GetSlot(this, ISO_NANOSECOND);
        ({ hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(hour, minute, second, millisecond, microsecond, nanosecond, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds));
        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, "reject"));
        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);
      }
      until(otherParam, optionsParam = void 0) {
        if (!IsTemporalTime(this))
          throw new TypeError("invalid receiver");
        const other = ToTemporalTime(otherParam);
        const options = GetOptionsObject(optionsParam);
        const largestUnit = ToLargestTemporalUnit(options, "auto", DISALLOWED_UNITS$1, "hour");
        const smallestUnit = ToSmallestTemporalUnit(options, "nanosecond", DISALLOWED_UNITS$1);
        ValidateTemporalUnitRange(largestUnit, smallestUnit);
        const roundingMode = ToTemporalRoundingMode(options, "trunc");
        const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);
        let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND));
        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode));
        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));
        const Duration2 = GetIntrinsic("%Temporal.Duration%");
        return new Duration2(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);
      }
      since(otherParam, optionsParam = void 0) {
        if (!IsTemporalTime(this))
          throw new TypeError("invalid receiver");
        const other = ToTemporalTime(otherParam);
        const options = GetOptionsObject(optionsParam);
        const largestUnit = ToLargestTemporalUnit(options, "auto", DISALLOWED_UNITS$1, "hour");
        const smallestUnit = ToSmallestTemporalUnit(options, "nanosecond", DISALLOWED_UNITS$1);
        ValidateTemporalUnitRange(largestUnit, smallestUnit);
        const roundingMode = ToTemporalRoundingMode(options, "trunc");
        const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);
        let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND));
        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(0, 0, 0, 0, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, roundingIncrement, smallestUnit, NegateTemporalRoundingMode(roundingMode)));
        hours = -hours;
        minutes = -minutes;
        seconds = -seconds;
        milliseconds = -milliseconds;
        microseconds = -microseconds;
        nanoseconds = -nanoseconds;
        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));
        const Duration2 = GetIntrinsic("%Temporal.Duration%");
        return new Duration2(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);
      }
      round(optionsParam) {
        if (!IsTemporalTime(this))
          throw new TypeError("invalid receiver");
        if (optionsParam === void 0)
          throw new TypeError("options parameter is required");
        const options = typeof optionsParam === "string" ? CreateOnePropObject("smallestUnit", optionsParam) : GetOptionsObject(optionsParam);
        const smallestUnit = ToSmallestTemporalUnit(options, void 0, DISALLOWED_UNITS$1);
        if (smallestUnit === void 0)
          throw new RangeError("smallestUnit is required");
        const roundingMode = ToTemporalRoundingMode(options, "halfExpand");
        const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);
        let hour = GetSlot(this, ISO_HOUR);
        let minute = GetSlot(this, ISO_MINUTE);
        let second = GetSlot(this, ISO_SECOND);
        let millisecond = GetSlot(this, ISO_MILLISECOND);
        let microsecond = GetSlot(this, ISO_MICROSECOND);
        let nanosecond = GetSlot(this, ISO_NANOSECOND);
        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode));
        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);
      }
      equals(otherParam) {
        if (!IsTemporalTime(this))
          throw new TypeError("invalid receiver");
        const other = ToTemporalTime(otherParam);
        for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND]) {
          const val1 = GetSlot(this, slot);
          const val2 = GetSlot(other, slot);
          if (val1 !== val2)
            return false;
        }
        return true;
      }
      toString(optionsParam = void 0) {
        if (!IsTemporalTime(this))
          throw new TypeError("invalid receiver");
        const options = GetOptionsObject(optionsParam);
        const { precision, unit, increment } = ToSecondsStringPrecision(options);
        const roundingMode = ToTemporalRoundingMode(options, "trunc");
        return TemporalTimeToString(this, precision, { unit, increment, roundingMode });
      }
      toJSON() {
        if (!IsTemporalTime(this))
          throw new TypeError("invalid receiver");
        return TemporalTimeToString(this, "auto");
      }
      toLocaleString(locales = void 0, options = void 0) {
        if (!IsTemporalTime(this))
          throw new TypeError("invalid receiver");
        return new DateTimeFormat(locales, options).format(this);
      }
      valueOf() {
        throw new TypeError("use compare() or equals() to compare Temporal.PlainTime");
      }
      toPlainDateTime(temporalDateParam) {
        if (!IsTemporalTime(this))
          throw new TypeError("invalid receiver");
        const temporalDate = ToTemporalDate(temporalDateParam);
        const year = GetSlot(temporalDate, ISO_YEAR);
        const month = GetSlot(temporalDate, ISO_MONTH);
        const day = GetSlot(temporalDate, ISO_DAY);
        const calendar2 = GetSlot(temporalDate, CALENDAR);
        const hour = GetSlot(this, ISO_HOUR);
        const minute = GetSlot(this, ISO_MINUTE);
        const second = GetSlot(this, ISO_SECOND);
        const millisecond = GetSlot(this, ISO_MILLISECOND);
        const microsecond = GetSlot(this, ISO_MICROSECOND);
        const nanosecond = GetSlot(this, ISO_NANOSECOND);
        return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar2);
      }
      toZonedDateTime(item) {
        if (!IsTemporalTime(this))
          throw new TypeError("invalid receiver");
        if (!IsObject(item)) {
          throw new TypeError("invalid argument");
        }
        const dateLike = item.plainDate;
        if (dateLike === void 0) {
          throw new TypeError("missing date property");
        }
        const temporalDate = ToTemporalDate(dateLike);
        const timeZoneLike = item.timeZone;
        if (timeZoneLike === void 0) {
          throw new TypeError("missing timeZone property");
        }
        const timeZone2 = ToTemporalTimeZone(timeZoneLike);
        const year = GetSlot(temporalDate, ISO_YEAR);
        const month = GetSlot(temporalDate, ISO_MONTH);
        const day = GetSlot(temporalDate, ISO_DAY);
        const calendar2 = GetSlot(temporalDate, CALENDAR);
        const hour = GetSlot(this, ISO_HOUR);
        const minute = GetSlot(this, ISO_MINUTE);
        const second = GetSlot(this, ISO_SECOND);
        const millisecond = GetSlot(this, ISO_MILLISECOND);
        const microsecond = GetSlot(this, ISO_MICROSECOND);
        const nanosecond = GetSlot(this, ISO_NANOSECOND);
        const PlainDateTime2 = GetIntrinsic("%Temporal.PlainDateTime%");
        const dt = new PlainDateTime2(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar2);
        const instant2 = BuiltinTimeZoneGetInstantFor(timeZone2, dt, "compatible");
        return CreateTemporalZonedDateTime(GetSlot(instant2, EPOCHNANOSECONDS), timeZone2, calendar2);
      }
      getISOFields() {
        if (!IsTemporalTime(this))
          throw new TypeError("invalid receiver");
        return {
          calendar: GetSlot(this, CALENDAR),
          isoHour: GetSlot(this, ISO_HOUR),
          isoMicrosecond: GetSlot(this, ISO_MICROSECOND),
          isoMillisecond: GetSlot(this, ISO_MILLISECOND),
          isoMinute: GetSlot(this, ISO_MINUTE),
          isoNanosecond: GetSlot(this, ISO_NANOSECOND),
          isoSecond: GetSlot(this, ISO_SECOND)
        };
      }
      static from(item, optionsParam = void 0) {
        const options = GetOptionsObject(optionsParam);
        const overflow = ToTemporalOverflow(options);
        if (IsTemporalTime(item)) {
          return new PlainTime(GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND));
        }
        return ToTemporalTime(item, overflow);
      }
      static compare(oneParam, twoParam) {
        const one = ToTemporalTime(oneParam);
        const two = ToTemporalTime(twoParam);
        for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND]) {
          const val1 = GetSlot(one, slot);
          const val2 = GetSlot(two, slot);
          if (val1 !== val2)
            return ComparisonResult(val1 - val2);
        }
        return 0;
      }
    };
    MakeIntrinsicClass(PlainTime, "Temporal.PlainTime");
    TimeZone = class {
      constructor(timeZoneIdentifierParam) {
        if (arguments.length < 1) {
          throw new RangeError("missing argument: identifier is required");
        }
        const timeZoneIdentifier = GetCanonicalTimeZoneIdentifier(timeZoneIdentifierParam);
        CreateSlots(this);
        SetSlot(this, TIMEZONE_ID, timeZoneIdentifier);
        {
          Object.defineProperty(this, "_repr_", {
            value: `${this[Symbol.toStringTag]} <${timeZoneIdentifier}>`,
            writable: false,
            enumerable: false,
            configurable: false
          });
        }
      }
      get id() {
        if (!IsTemporalTimeZone(this))
          throw new TypeError("invalid receiver");
        return ToString(this);
      }
      getOffsetNanosecondsFor(instantParam) {
        if (!IsTemporalTimeZone(this))
          throw new TypeError("invalid receiver");
        const instant2 = ToTemporalInstant(instantParam);
        const id = GetSlot(this, TIMEZONE_ID);
        if (TestTimeZoneOffsetString(id)) {
          return ParseTimeZoneOffsetString(id);
        }
        return GetIANATimeZoneOffsetNanoseconds(GetSlot(instant2, EPOCHNANOSECONDS), id);
      }
      getOffsetStringFor(instantParam) {
        if (!IsTemporalTimeZone(this))
          throw new TypeError("invalid receiver");
        const instant2 = ToTemporalInstant(instantParam);
        return BuiltinTimeZoneGetOffsetStringFor(this, instant2);
      }
      getPlainDateTimeFor(instantParam, calendarParam = GetISO8601Calendar()) {
        const instant2 = ToTemporalInstant(instantParam);
        const calendar2 = ToTemporalCalendar(calendarParam);
        return BuiltinTimeZoneGetPlainDateTimeFor(this, instant2, calendar2);
      }
      getInstantFor(dateTimeParam, optionsParam = void 0) {
        if (!IsTemporalTimeZone(this))
          throw new TypeError("invalid receiver");
        const dateTime2 = ToTemporalDateTime(dateTimeParam);
        const options = GetOptionsObject(optionsParam);
        const disambiguation = ToTemporalDisambiguation(options);
        return BuiltinTimeZoneGetInstantFor(this, dateTime2, disambiguation);
      }
      getPossibleInstantsFor(dateTimeParam) {
        if (!IsTemporalTimeZone(this))
          throw new TypeError("invalid receiver");
        const dateTime2 = ToTemporalDateTime(dateTimeParam);
        const Instant2 = GetIntrinsic("%Temporal.Instant%");
        const id = GetSlot(this, TIMEZONE_ID);
        if (TestTimeZoneOffsetString(id)) {
          const epochNs = GetEpochFromISOParts(GetSlot(dateTime2, ISO_YEAR), GetSlot(dateTime2, ISO_MONTH), GetSlot(dateTime2, ISO_DAY), GetSlot(dateTime2, ISO_HOUR), GetSlot(dateTime2, ISO_MINUTE), GetSlot(dateTime2, ISO_SECOND), GetSlot(dateTime2, ISO_MILLISECOND), GetSlot(dateTime2, ISO_MICROSECOND), GetSlot(dateTime2, ISO_NANOSECOND));
          if (epochNs === null)
            throw new RangeError("DateTime outside of supported range");
          const offsetNs = ParseTimeZoneOffsetString(id);
          return [new Instant2(import_jsbi.default.subtract(epochNs, import_jsbi.default.BigInt(offsetNs)))];
        }
        const possibleEpochNs = GetIANATimeZoneEpochValue(id, GetSlot(dateTime2, ISO_YEAR), GetSlot(dateTime2, ISO_MONTH), GetSlot(dateTime2, ISO_DAY), GetSlot(dateTime2, ISO_HOUR), GetSlot(dateTime2, ISO_MINUTE), GetSlot(dateTime2, ISO_SECOND), GetSlot(dateTime2, ISO_MILLISECOND), GetSlot(dateTime2, ISO_MICROSECOND), GetSlot(dateTime2, ISO_NANOSECOND));
        return possibleEpochNs.map((ns) => new Instant2(ns));
      }
      getNextTransition(startingPointParam) {
        if (!IsTemporalTimeZone(this))
          throw new TypeError("invalid receiver");
        const startingPoint = ToTemporalInstant(startingPointParam);
        const id = GetSlot(this, TIMEZONE_ID);
        if (TestTimeZoneOffsetString(id) || id === "UTC") {
          return null;
        }
        let epochNanoseconds = GetSlot(startingPoint, EPOCHNANOSECONDS);
        const Instant2 = GetIntrinsic("%Temporal.Instant%");
        epochNanoseconds = GetIANATimeZoneNextTransition(epochNanoseconds, id);
        return epochNanoseconds === null ? null : new Instant2(epochNanoseconds);
      }
      getPreviousTransition(startingPointParam) {
        if (!IsTemporalTimeZone(this))
          throw new TypeError("invalid receiver");
        const startingPoint = ToTemporalInstant(startingPointParam);
        const id = GetSlot(this, TIMEZONE_ID);
        if (TestTimeZoneOffsetString(id) || id === "UTC") {
          return null;
        }
        let epochNanoseconds = GetSlot(startingPoint, EPOCHNANOSECONDS);
        const Instant2 = GetIntrinsic("%Temporal.Instant%");
        epochNanoseconds = GetIANATimeZonePreviousTransition(epochNanoseconds, id);
        return epochNanoseconds === null ? null : new Instant2(epochNanoseconds);
      }
      toString() {
        if (!IsTemporalTimeZone(this))
          throw new TypeError("invalid receiver");
        return ToString(GetSlot(this, TIMEZONE_ID));
      }
      toJSON() {
        if (!IsTemporalTimeZone(this))
          throw new TypeError("invalid receiver");
        return ToString(this);
      }
      static from(item) {
        return ToTemporalTimeZone(item);
      }
    };
    MakeIntrinsicClass(TimeZone, "Temporal.TimeZone");
    ObjectCreate = Object.create;
    DISALLOWED_UNITS = [
      "week",
      "day",
      "hour",
      "minute",
      "second",
      "millisecond",
      "microsecond",
      "nanosecond"
    ];
    PlainYearMonth = class {
      constructor(isoYearParam, isoMonthParam, calendarParam = GetISO8601Calendar(), referenceISODayParam = 1) {
        const isoYear = ToIntegerThrowOnInfinity(isoYearParam);
        const isoMonth = ToIntegerThrowOnInfinity(isoMonthParam);
        const calendar2 = ToTemporalCalendar(calendarParam);
        const referenceISODay = ToIntegerThrowOnInfinity(referenceISODayParam);
        if (arguments.length < 2) {
          throw new RangeError("missing argument: isoYear and isoMonth are required");
        }
        CreateTemporalYearMonthSlots(this, isoYear, isoMonth, calendar2, referenceISODay);
      }
      get year() {
        if (!IsTemporalYearMonth(this))
          throw new TypeError("invalid receiver");
        return CalendarYear(GetSlot(this, CALENDAR), this);
      }
      get month() {
        if (!IsTemporalYearMonth(this))
          throw new TypeError("invalid receiver");
        return CalendarMonth(GetSlot(this, CALENDAR), this);
      }
      get monthCode() {
        if (!IsTemporalYearMonth(this))
          throw new TypeError("invalid receiver");
        return CalendarMonthCode(GetSlot(this, CALENDAR), this);
      }
      get calendar() {
        if (!IsTemporalYearMonth(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, CALENDAR);
      }
      get era() {
        if (!IsTemporalYearMonth(this))
          throw new TypeError("invalid receiver");
        return CalendarEra(GetSlot(this, CALENDAR), this);
      }
      get eraYear() {
        if (!IsTemporalYearMonth(this))
          throw new TypeError("invalid receiver");
        return CalendarEraYear(GetSlot(this, CALENDAR), this);
      }
      get daysInMonth() {
        if (!IsTemporalYearMonth(this))
          throw new TypeError("invalid receiver");
        return CalendarDaysInMonth(GetSlot(this, CALENDAR), this);
      }
      get daysInYear() {
        if (!IsTemporalYearMonth(this))
          throw new TypeError("invalid receiver");
        return CalendarDaysInYear(GetSlot(this, CALENDAR), this);
      }
      get monthsInYear() {
        if (!IsTemporalYearMonth(this))
          throw new TypeError("invalid receiver");
        return CalendarMonthsInYear(GetSlot(this, CALENDAR), this);
      }
      get inLeapYear() {
        if (!IsTemporalYearMonth(this))
          throw new TypeError("invalid receiver");
        return CalendarInLeapYear(GetSlot(this, CALENDAR), this);
      }
      with(temporalYearMonthLike, optionsParam = void 0) {
        if (!IsTemporalYearMonth(this))
          throw new TypeError("invalid receiver");
        if (!IsObject(temporalYearMonthLike)) {
          throw new TypeError("invalid argument");
        }
        RejectObjectWithCalendarOrTimeZone(temporalYearMonthLike);
        const calendar2 = GetSlot(this, CALENDAR);
        const fieldNames = CalendarFields(calendar2, ["month", "monthCode", "year"]);
        const props = ToPartialRecord(temporalYearMonthLike, fieldNames);
        if (!props) {
          throw new TypeError("invalid year-month-like");
        }
        let fields = ToTemporalYearMonthFields(this, fieldNames);
        fields = CalendarMergeFields(calendar2, fields, props);
        fields = ToTemporalYearMonthFields(fields, fieldNames);
        const options = GetOptionsObject(optionsParam);
        return YearMonthFromFields(calendar2, fields, options);
      }
      add(temporalDurationLike, optionsParam = void 0) {
        if (!IsTemporalYearMonth(this))
          throw new TypeError("invalid receiver");
        const duration2 = ToLimitedTemporalDuration(temporalDurationLike);
        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration2;
        ({ days } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, "day"));
        const options = GetOptionsObject(optionsParam);
        const calendar2 = GetSlot(this, CALENDAR);
        const fieldNames = CalendarFields(calendar2, ["monthCode", "year"]);
        const fields = ToTemporalYearMonthFields(this, fieldNames);
        const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);
        const day = sign < 0 ? ToPositiveInteger(CalendarDaysInMonth(calendar2, this)) : 1;
        const startDate = DateFromFields(calendar2, __spreadProps(__spreadValues({}, fields), { day }));
        const optionsCopy = __spreadValues({}, options);
        const addedDate = CalendarDateAdd(calendar2, startDate, __spreadProps(__spreadValues({}, duration2), { days }), options);
        const addedDateFields = ToTemporalYearMonthFields(addedDate, fieldNames);
        return YearMonthFromFields(calendar2, addedDateFields, optionsCopy);
      }
      subtract(temporalDurationLike, optionsParam = void 0) {
        if (!IsTemporalYearMonth(this))
          throw new TypeError("invalid receiver");
        let duration2 = ToLimitedTemporalDuration(temporalDurationLike);
        duration2 = {
          years: -duration2.years,
          months: -duration2.months,
          weeks: -duration2.weeks,
          days: -duration2.days,
          hours: -duration2.hours,
          minutes: -duration2.minutes,
          seconds: -duration2.seconds,
          milliseconds: -duration2.milliseconds,
          microseconds: -duration2.microseconds,
          nanoseconds: -duration2.nanoseconds
        };
        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration2;
        ({ days } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, "day"));
        const options = GetOptionsObject(optionsParam);
        const calendar2 = GetSlot(this, CALENDAR);
        const fieldNames = CalendarFields(calendar2, ["monthCode", "year"]);
        const fields = ToTemporalYearMonthFields(this, fieldNames);
        const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);
        const day = sign < 0 ? ToPositiveInteger(CalendarDaysInMonth(calendar2, this)) : 1;
        const startDate = DateFromFields(calendar2, __spreadProps(__spreadValues({}, fields), { day }));
        const optionsCopy = __spreadValues({}, options);
        const addedDate = CalendarDateAdd(calendar2, startDate, __spreadProps(__spreadValues({}, duration2), { days }), options);
        const addedDateFields = ToTemporalYearMonthFields(addedDate, fieldNames);
        return YearMonthFromFields(calendar2, addedDateFields, optionsCopy);
      }
      until(otherParam, optionsParam = void 0) {
        if (!IsTemporalYearMonth(this))
          throw new TypeError("invalid receiver");
        const other = ToTemporalYearMonth(otherParam);
        const calendar2 = GetSlot(this, CALENDAR);
        const otherCalendar = GetSlot(other, CALENDAR);
        const calendarID2 = ToString(calendar2);
        const otherCalendarID = ToString(otherCalendar);
        if (calendarID2 !== otherCalendarID) {
          throw new RangeError(`cannot compute difference between months of ${calendarID2} and ${otherCalendarID} calendars`);
        }
        const options = GetOptionsObject(optionsParam);
        const smallestUnit = ToSmallestTemporalUnit(options, "month", DISALLOWED_UNITS);
        const largestUnit = ToLargestTemporalUnit(options, "auto", DISALLOWED_UNITS, "year");
        ValidateTemporalUnitRange(largestUnit, smallestUnit);
        const roundingMode = ToTemporalRoundingMode(options, "trunc");
        const roundingIncrement = ToTemporalRoundingIncrement(options, void 0, false);
        const fieldNames = CalendarFields(calendar2, ["monthCode", "year"]);
        const otherFields = ToTemporalYearMonthFields(other, fieldNames);
        const thisFields = ToTemporalYearMonthFields(this, fieldNames);
        const otherDate = DateFromFields(calendar2, __spreadProps(__spreadValues({}, otherFields), { day: 1 }));
        const thisDate = DateFromFields(calendar2, __spreadProps(__spreadValues({}, thisFields), { day: 1 }));
        const untilOptions = __spreadProps(__spreadValues({}, options), { largestUnit });
        const result = CalendarDateUntil(calendar2, thisDate, otherDate, untilOptions);
        if (smallestUnit === "month" && roundingIncrement === 1)
          return result;
        let { years, months } = result;
        ({ years, months } = RoundDuration(years, months, 0, 0, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, roundingMode, thisDate));
        const Duration2 = GetIntrinsic("%Temporal.Duration%");
        return new Duration2(years, months, 0, 0, 0, 0, 0, 0, 0, 0);
      }
      since(otherParam, optionsParam = void 0) {
        if (!IsTemporalYearMonth(this))
          throw new TypeError("invalid receiver");
        const other = ToTemporalYearMonth(otherParam);
        const calendar2 = GetSlot(this, CALENDAR);
        const otherCalendar = GetSlot(other, CALENDAR);
        const calendarID2 = ToString(calendar2);
        const otherCalendarID = ToString(otherCalendar);
        if (calendarID2 !== otherCalendarID) {
          throw new RangeError(`cannot compute difference between months of ${calendarID2} and ${otherCalendarID} calendars`);
        }
        const options = GetOptionsObject(optionsParam);
        const smallestUnit = ToSmallestTemporalUnit(options, "month", DISALLOWED_UNITS);
        const largestUnit = ToLargestTemporalUnit(options, "auto", DISALLOWED_UNITS, "year");
        ValidateTemporalUnitRange(largestUnit, smallestUnit);
        const roundingMode = ToTemporalRoundingMode(options, "trunc");
        const roundingIncrement = ToTemporalRoundingIncrement(options, void 0, false);
        const fieldNames = CalendarFields(calendar2, ["monthCode", "year"]);
        const otherFields = ToTemporalYearMonthFields(other, fieldNames);
        const thisFields = ToTemporalYearMonthFields(this, fieldNames);
        const otherDate = DateFromFields(calendar2, __spreadProps(__spreadValues({}, otherFields), { day: 1 }));
        const thisDate = DateFromFields(calendar2, __spreadProps(__spreadValues({}, thisFields), { day: 1 }));
        const untilOptions = __spreadProps(__spreadValues({}, options), { largestUnit });
        let { years, months } = CalendarDateUntil(calendar2, thisDate, otherDate, untilOptions);
        const Duration2 = GetIntrinsic("%Temporal.Duration%");
        if (smallestUnit === "month" && roundingIncrement === 1) {
          return new Duration2(-years, -months, 0, 0, 0, 0, 0, 0, 0, 0);
        }
        ({ years, months } = RoundDuration(years, months, 0, 0, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, NegateTemporalRoundingMode(roundingMode), thisDate));
        return new Duration2(-years, -months, 0, 0, 0, 0, 0, 0, 0, 0);
      }
      equals(otherParam) {
        if (!IsTemporalYearMonth(this))
          throw new TypeError("invalid receiver");
        const other = ToTemporalYearMonth(otherParam);
        for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {
          const val1 = GetSlot(this, slot);
          const val2 = GetSlot(other, slot);
          if (val1 !== val2)
            return false;
        }
        return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));
      }
      toString(optionsParam = void 0) {
        if (!IsTemporalYearMonth(this))
          throw new TypeError("invalid receiver");
        const options = GetOptionsObject(optionsParam);
        const showCalendar = ToShowCalendarOption(options);
        return TemporalYearMonthToString(this, showCalendar);
      }
      toJSON() {
        if (!IsTemporalYearMonth(this))
          throw new TypeError("invalid receiver");
        return TemporalYearMonthToString(this);
      }
      toLocaleString(locales = void 0, options = void 0) {
        if (!IsTemporalYearMonth(this))
          throw new TypeError("invalid receiver");
        return new DateTimeFormat(locales, options).format(this);
      }
      valueOf() {
        throw new TypeError("use compare() or equals() to compare Temporal.PlainYearMonth");
      }
      toPlainDate(item) {
        if (!IsTemporalYearMonth(this))
          throw new TypeError("invalid receiver");
        if (!IsObject(item))
          throw new TypeError("argument should be an object");
        const calendar2 = GetSlot(this, CALENDAR);
        const receiverFieldNames = CalendarFields(calendar2, ["monthCode", "year"]);
        const fields = ToTemporalYearMonthFields(this, receiverFieldNames);
        const inputFieldNames = CalendarFields(calendar2, ["day"]);
        const inputEntries = [["day"]];
        inputFieldNames.forEach((fieldName) => {
          if (!inputEntries.some(([name]) => name === fieldName)) {
            inputEntries.push([
              fieldName,
              void 0
            ]);
          }
        });
        const inputFields = PrepareTemporalFields(item, inputEntries);
        let mergedFields = CalendarMergeFields(calendar2, fields, inputFields);
        const mergedFieldNames = [.../* @__PURE__ */ new Set([...receiverFieldNames, ...inputFieldNames])];
        const mergedEntries = [];
        mergedFieldNames.forEach((fieldName) => {
          if (!mergedEntries.some(([name]) => name === fieldName)) {
            mergedEntries.push([fieldName, void 0]);
          }
        });
        mergedFields = PrepareTemporalFields(mergedFields, mergedEntries);
        const options = ObjectCreate(null);
        options.overflow = "reject";
        return DateFromFields(calendar2, mergedFields, options);
      }
      getISOFields() {
        if (!IsTemporalYearMonth(this))
          throw new TypeError("invalid receiver");
        return {
          calendar: GetSlot(this, CALENDAR),
          isoDay: GetSlot(this, ISO_DAY),
          isoMonth: GetSlot(this, ISO_MONTH),
          isoYear: GetSlot(this, ISO_YEAR)
        };
      }
      static from(item, optionsParam = void 0) {
        const options = GetOptionsObject(optionsParam);
        if (IsTemporalYearMonth(item)) {
          ToTemporalOverflow(options);
          return CreateTemporalYearMonth(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, CALENDAR), GetSlot(item, ISO_DAY));
        }
        return ToTemporalYearMonth(item, options);
      }
      static compare(oneParam, twoParam) {
        const one = ToTemporalYearMonth(oneParam);
        const two = ToTemporalYearMonth(twoParam);
        return CompareISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY));
      }
    };
    MakeIntrinsicClass(PlainYearMonth, "Temporal.PlainYearMonth");
    ArrayPrototypePush = Array.prototype.push;
    ZonedDateTime = class {
      constructor(epochNanosecondsParam, timeZoneParam, calendarParam = GetISO8601Calendar()) {
        if (arguments.length < 1) {
          throw new TypeError("missing argument: epochNanoseconds is required");
        }
        const epochNanoseconds = ToBigInt(epochNanosecondsParam);
        const timeZone2 = ToTemporalTimeZone(timeZoneParam);
        const calendar2 = ToTemporalCalendar(calendarParam);
        CreateTemporalZonedDateTimeSlots(this, epochNanoseconds, timeZone2, calendar2);
      }
      get calendar() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, CALENDAR);
      }
      get timeZone() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(this, TIME_ZONE);
      }
      get year() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarYear(GetSlot(this, CALENDAR), dateTime(this));
      }
      get month() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarMonth(GetSlot(this, CALENDAR), dateTime(this));
      }
      get monthCode() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarMonthCode(GetSlot(this, CALENDAR), dateTime(this));
      }
      get day() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarDay(GetSlot(this, CALENDAR), dateTime(this));
      }
      get hour() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(dateTime(this), ISO_HOUR);
      }
      get minute() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(dateTime(this), ISO_MINUTE);
      }
      get second() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(dateTime(this), ISO_SECOND);
      }
      get millisecond() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(dateTime(this), ISO_MILLISECOND);
      }
      get microsecond() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(dateTime(this), ISO_MICROSECOND);
      }
      get nanosecond() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return GetSlot(dateTime(this), ISO_NANOSECOND);
      }
      get era() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarEra(GetSlot(this, CALENDAR), dateTime(this));
      }
      get eraYear() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarEraYear(GetSlot(this, CALENDAR), dateTime(this));
      }
      get epochSeconds() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        const value = GetSlot(this, EPOCHNANOSECONDS);
        return import_jsbi.default.toNumber(import_jsbi.default.divide(value, BILLION));
      }
      get epochMilliseconds() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        const value = GetSlot(this, EPOCHNANOSECONDS);
        return import_jsbi.default.toNumber(import_jsbi.default.divide(value, MILLION));
      }
      get epochMicroseconds() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        const value = GetSlot(this, EPOCHNANOSECONDS);
        return ToBigIntExternal(import_jsbi.default.divide(value, THOUSAND));
      }
      get epochNanoseconds() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return ToBigIntExternal(GetSlot(this, EPOCHNANOSECONDS));
      }
      get dayOfWeek() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarDayOfWeek(GetSlot(this, CALENDAR), dateTime(this));
      }
      get dayOfYear() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarDayOfYear(GetSlot(this, CALENDAR), dateTime(this));
      }
      get weekOfYear() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarWeekOfYear(GetSlot(this, CALENDAR), dateTime(this));
      }
      get hoursInDay() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        const dt = dateTime(this);
        const DateTime = GetIntrinsic("%Temporal.PlainDateTime%");
        const year = GetSlot(dt, ISO_YEAR);
        const month = GetSlot(dt, ISO_MONTH);
        const day = GetSlot(dt, ISO_DAY);
        const today = new DateTime(year, month, day, 0, 0, 0, 0, 0, 0);
        const tomorrowFields = AddISODate(year, month, day, 0, 0, 0, 1, "reject");
        const tomorrow = new DateTime(tomorrowFields.year, tomorrowFields.month, tomorrowFields.day, 0, 0, 0, 0, 0, 0);
        const timeZone2 = GetSlot(this, TIME_ZONE);
        const todayNs = GetSlot(BuiltinTimeZoneGetInstantFor(timeZone2, today, "compatible"), EPOCHNANOSECONDS);
        const tomorrowNs = GetSlot(BuiltinTimeZoneGetInstantFor(timeZone2, tomorrow, "compatible"), EPOCHNANOSECONDS);
        return import_jsbi.default.toNumber(import_jsbi.default.subtract(tomorrowNs, todayNs)) / 36e11;
      }
      get daysInWeek() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarDaysInWeek(GetSlot(this, CALENDAR), dateTime(this));
      }
      get daysInMonth() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarDaysInMonth(GetSlot(this, CALENDAR), dateTime(this));
      }
      get daysInYear() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarDaysInYear(GetSlot(this, CALENDAR), dateTime(this));
      }
      get monthsInYear() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarMonthsInYear(GetSlot(this, CALENDAR), dateTime(this));
      }
      get inLeapYear() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return CalendarInLeapYear(GetSlot(this, CALENDAR), dateTime(this));
      }
      get offset() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return BuiltinTimeZoneGetOffsetStringFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));
      }
      get offsetNanoseconds() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return GetOffsetNanosecondsFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));
      }
      with(temporalZonedDateTimeLike, optionsParam = void 0) {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        if (!IsObject(temporalZonedDateTimeLike)) {
          throw new TypeError("invalid zoned-date-time-like");
        }
        RejectObjectWithCalendarOrTimeZone(temporalZonedDateTimeLike);
        const options = GetOptionsObject(optionsParam);
        const disambiguation = ToTemporalDisambiguation(options);
        const offset2 = ToTemporalOffset(options, "prefer");
        const timeZone2 = GetSlot(this, TIME_ZONE);
        const calendar2 = GetSlot(this, CALENDAR);
        const fieldNames = CalendarFields(calendar2, [
          "day",
          "hour",
          "microsecond",
          "millisecond",
          "minute",
          "month",
          "monthCode",
          "nanosecond",
          "second",
          "year"
        ]);
        ArrayPrototypePush.call(fieldNames, "offset");
        const props = ToPartialRecord(temporalZonedDateTimeLike, fieldNames);
        if (!props) {
          throw new TypeError("invalid zoned-date-time-like");
        }
        const entries = [
          ["day", void 0],
          ["hour", 0],
          ["microsecond", 0],
          ["millisecond", 0],
          ["minute", 0],
          ["month", void 0],
          ["monthCode", void 0],
          ["nanosecond", 0],
          ["second", 0],
          ["year", void 0],
          ["offset"],
          ["timeZone"]
        ];
        fieldNames.forEach((fieldName) => {
          if (!entries.some(([name]) => name === fieldName)) {
            entries.push([fieldName, void 0]);
          }
        });
        let fields = PrepareTemporalFields(this, entries);
        fields = CalendarMergeFields(calendar2, fields, props);
        fields = PrepareTemporalFields(fields, entries);
        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar2, fields, options);
        const offsetNs = ParseTimeZoneOffsetString(fields.offset);
        const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, "option", offsetNs, timeZone2, disambiguation, offset2, false);
        return CreateTemporalZonedDateTime(epochNanoseconds, GetSlot(this, TIME_ZONE), calendar2);
      }
      withPlainDate(temporalDateParam) {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        const temporalDate = ToTemporalDate(temporalDateParam);
        const year = GetSlot(temporalDate, ISO_YEAR);
        const month = GetSlot(temporalDate, ISO_MONTH);
        const day = GetSlot(temporalDate, ISO_DAY);
        let calendar2 = GetSlot(temporalDate, CALENDAR);
        const thisDt = dateTime(this);
        const hour = GetSlot(thisDt, ISO_HOUR);
        const minute = GetSlot(thisDt, ISO_MINUTE);
        const second = GetSlot(thisDt, ISO_SECOND);
        const millisecond = GetSlot(thisDt, ISO_MILLISECOND);
        const microsecond = GetSlot(thisDt, ISO_MICROSECOND);
        const nanosecond = GetSlot(thisDt, ISO_NANOSECOND);
        calendar2 = ConsolidateCalendars(GetSlot(this, CALENDAR), calendar2);
        const timeZone2 = GetSlot(this, TIME_ZONE);
        const PlainDateTime2 = GetIntrinsic("%Temporal.PlainDateTime%");
        const dt = new PlainDateTime2(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar2);
        const instant2 = BuiltinTimeZoneGetInstantFor(timeZone2, dt, "compatible");
        return CreateTemporalZonedDateTime(GetSlot(instant2, EPOCHNANOSECONDS), timeZone2, calendar2);
      }
      withPlainTime(temporalTimeParam = void 0) {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        const PlainTime2 = GetIntrinsic("%Temporal.PlainTime%");
        const temporalTime = temporalTimeParam == void 0 ? new PlainTime2() : ToTemporalTime(temporalTimeParam);
        const thisDt = dateTime(this);
        const year = GetSlot(thisDt, ISO_YEAR);
        const month = GetSlot(thisDt, ISO_MONTH);
        const day = GetSlot(thisDt, ISO_DAY);
        const calendar2 = GetSlot(this, CALENDAR);
        const hour = GetSlot(temporalTime, ISO_HOUR);
        const minute = GetSlot(temporalTime, ISO_MINUTE);
        const second = GetSlot(temporalTime, ISO_SECOND);
        const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);
        const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);
        const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);
        const timeZone2 = GetSlot(this, TIME_ZONE);
        const PlainDateTime2 = GetIntrinsic("%Temporal.PlainDateTime%");
        const dt = new PlainDateTime2(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar2);
        const instant2 = BuiltinTimeZoneGetInstantFor(timeZone2, dt, "compatible");
        return CreateTemporalZonedDateTime(GetSlot(instant2, EPOCHNANOSECONDS), timeZone2, calendar2);
      }
      withTimeZone(timeZoneParam) {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        const timeZone2 = ToTemporalTimeZone(timeZoneParam);
        return CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone2, GetSlot(this, CALENDAR));
      }
      withCalendar(calendarParam) {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        const calendar2 = ToTemporalCalendar(calendarParam);
        return CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), GetSlot(this, TIME_ZONE), calendar2);
      }
      add(temporalDurationLike, optionsParam = void 0) {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        const duration2 = ToLimitedTemporalDuration(temporalDurationLike);
        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration2;
        const options = GetOptionsObject(optionsParam);
        const timeZone2 = GetSlot(this, TIME_ZONE);
        const calendar2 = GetSlot(this, CALENDAR);
        const epochNanoseconds = AddZonedDateTime(GetSlot(this, INSTANT), timeZone2, calendar2, years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options);
        return CreateTemporalZonedDateTime(epochNanoseconds, timeZone2, calendar2);
      }
      subtract(temporalDurationLike, optionsParam = void 0) {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        const duration2 = ToLimitedTemporalDuration(temporalDurationLike);
        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration2;
        const options = GetOptionsObject(optionsParam);
        const timeZone2 = GetSlot(this, TIME_ZONE);
        const calendar2 = GetSlot(this, CALENDAR);
        const epochNanoseconds = AddZonedDateTime(GetSlot(this, INSTANT), timeZone2, calendar2, -years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, options);
        return CreateTemporalZonedDateTime(epochNanoseconds, timeZone2, calendar2);
      }
      until(otherParam, optionsParam = void 0) {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        const other = ToTemporalZonedDateTime(otherParam);
        const calendar2 = GetSlot(this, CALENDAR);
        const otherCalendar = GetSlot(other, CALENDAR);
        const calendarId = ToString(calendar2);
        const otherCalendarId = ToString(otherCalendar);
        if (calendarId !== otherCalendarId) {
          throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);
        }
        const options = GetOptionsObject(optionsParam);
        const smallestUnit = ToSmallestTemporalUnit(options, "nanosecond");
        const defaultLargestUnit = LargerOfTwoTemporalUnits("hour", smallestUnit);
        const largestUnit = ToLargestTemporalUnit(options, "auto", [], defaultLargestUnit);
        ValidateTemporalUnitRange(largestUnit, smallestUnit);
        const roundingMode = ToTemporalRoundingMode(options, "trunc");
        const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);
        const ns1 = GetSlot(this, EPOCHNANOSECONDS);
        const ns2 = GetSlot(other, EPOCHNANOSECONDS);
        let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;
        if (largestUnit !== "year" && largestUnit !== "month" && largestUnit !== "week" && largestUnit !== "day") {
          years = 0;
          months = 0;
          weeks = 0;
          days = 0;
          ({ seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(ns1, ns2, roundingIncrement, smallestUnit, roundingMode));
          ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));
        } else {
          const timeZone2 = GetSlot(this, TIME_ZONE);
          if (!TimeZoneEquals(timeZone2, GetSlot(other, TIME_ZONE))) {
            throw new RangeError("When calculating difference between time zones, largestUnit must be 'hours' or smaller because day lengths can vary between time zones due to DST or time zone offset changes.");
          }
          const untilOptions = __spreadProps(__spreadValues({}, options), { largestUnit });
          ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceZonedDateTime(ns1, ns2, timeZone2, calendar2, largestUnit, untilOptions));
          ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));
          ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));
        }
        const Duration2 = GetIntrinsic("%Temporal.Duration%");
        return new Duration2(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);
      }
      since(otherParam, optionsParam = void 0) {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        const other = ToTemporalZonedDateTime(otherParam);
        const calendar2 = GetSlot(this, CALENDAR);
        const otherCalendar = GetSlot(other, CALENDAR);
        const calendarId = ToString(calendar2);
        const otherCalendarId = ToString(otherCalendar);
        if (calendarId !== otherCalendarId) {
          throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);
        }
        const options = GetOptionsObject(optionsParam);
        const smallestUnit = ToSmallestTemporalUnit(options, "nanosecond");
        const defaultLargestUnit = LargerOfTwoTemporalUnits("hour", smallestUnit);
        const largestUnit = ToLargestTemporalUnit(options, "auto", [], defaultLargestUnit);
        ValidateTemporalUnitRange(largestUnit, smallestUnit);
        let roundingMode = ToTemporalRoundingMode(options, "trunc");
        roundingMode = NegateTemporalRoundingMode(roundingMode);
        const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);
        const ns1 = GetSlot(this, EPOCHNANOSECONDS);
        const ns2 = GetSlot(other, EPOCHNANOSECONDS);
        let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;
        if (largestUnit !== "year" && largestUnit !== "month" && largestUnit !== "week" && largestUnit !== "day") {
          years = 0;
          months = 0;
          weeks = 0;
          days = 0;
          ({ seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(ns1, ns2, roundingIncrement, smallestUnit, roundingMode));
          ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));
        } else {
          const timeZone2 = GetSlot(this, TIME_ZONE);
          if (!TimeZoneEquals(timeZone2, GetSlot(other, TIME_ZONE))) {
            throw new RangeError("When calculating difference between time zones, largestUnit must be 'hours' or smaller because day lengths can vary between time zones due to DST or time zone offset changes.");
          }
          const untilOptions = __spreadProps(__spreadValues({}, options), { largestUnit });
          ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceZonedDateTime(ns1, ns2, timeZone2, calendar2, largestUnit, untilOptions));
          ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));
          ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));
        }
        const Duration2 = GetIntrinsic("%Temporal.Duration%");
        return new Duration2(-years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds);
      }
      round(optionsParam) {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        if (optionsParam === void 0)
          throw new TypeError("options parameter is required");
        const options = typeof optionsParam === "string" ? CreateOnePropObject("smallestUnit", optionsParam) : GetOptionsObject(optionsParam);
        const smallestUnit = ToSmallestTemporalUnit(options, void 0, ["year", "month", "week"]);
        if (smallestUnit === void 0)
          throw new RangeError("smallestUnit is required");
        const roundingMode = ToTemporalRoundingMode(options, "halfExpand");
        const maximumIncrements = {
          day: 1,
          hour: 24,
          minute: 60,
          second: 60,
          millisecond: 1e3,
          microsecond: 1e3,
          nanosecond: 1e3
        };
        const roundingIncrement = ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);
        const dt = dateTime(this);
        let year = GetSlot(dt, ISO_YEAR);
        let month = GetSlot(dt, ISO_MONTH);
        let day = GetSlot(dt, ISO_DAY);
        let hour = GetSlot(dt, ISO_HOUR);
        let minute = GetSlot(dt, ISO_MINUTE);
        let second = GetSlot(dt, ISO_SECOND);
        let millisecond = GetSlot(dt, ISO_MILLISECOND);
        let microsecond = GetSlot(dt, ISO_MICROSECOND);
        let nanosecond = GetSlot(dt, ISO_NANOSECOND);
        const DateTime = GetIntrinsic("%Temporal.PlainDateTime%");
        const timeZone2 = GetSlot(this, TIME_ZONE);
        const calendar2 = GetSlot(this, CALENDAR);
        const dtStart = new DateTime(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), 0, 0, 0, 0, 0, 0);
        const instantStart = BuiltinTimeZoneGetInstantFor(timeZone2, dtStart, "compatible");
        const endNs = AddZonedDateTime(instantStart, timeZone2, calendar2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0);
        const dayLengthNs = import_jsbi.default.subtract(endNs, import_jsbi.default.BigInt(GetSlot(instantStart, EPOCHNANOSECONDS)));
        if (import_jsbi.default.equal(dayLengthNs, ZERO)) {
          throw new RangeError("cannot round a ZonedDateTime in a calendar with zero-length days");
        }
        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode, import_jsbi.default.toNumber(dayLengthNs)));
        const offsetNs = GetOffsetNanosecondsFor(timeZone2, GetSlot(this, INSTANT));
        const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, "option", offsetNs, timeZone2, "compatible", "prefer", false);
        return CreateTemporalZonedDateTime(epochNanoseconds, timeZone2, GetSlot(this, CALENDAR));
      }
      equals(otherParam) {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        const other = ToTemporalZonedDateTime(otherParam);
        const one = GetSlot(this, EPOCHNANOSECONDS);
        const two = GetSlot(other, EPOCHNANOSECONDS);
        if (!import_jsbi.default.equal(import_jsbi.default.BigInt(one), import_jsbi.default.BigInt(two)))
          return false;
        if (!TimeZoneEquals(GetSlot(this, TIME_ZONE), GetSlot(other, TIME_ZONE)))
          return false;
        return CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));
      }
      toString(optionsParam = void 0) {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        const options = GetOptionsObject(optionsParam);
        const { precision, unit, increment } = ToSecondsStringPrecision(options);
        const roundingMode = ToTemporalRoundingMode(options, "trunc");
        const showCalendar = ToShowCalendarOption(options);
        const showTimeZone = ToShowTimeZoneNameOption(options);
        const showOffset = ToShowOffsetOption(options);
        return TemporalZonedDateTimeToString(this, precision, showCalendar, showTimeZone, showOffset, {
          unit,
          increment,
          roundingMode
        });
      }
      toLocaleString(locales = void 0, options = void 0) {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return new DateTimeFormat(locales, options).format(this);
      }
      toJSON() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return TemporalZonedDateTimeToString(this, "auto");
      }
      valueOf() {
        throw new TypeError("use compare() or equals() to compare Temporal.ZonedDateTime");
      }
      startOfDay() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        const dt = dateTime(this);
        const DateTime = GetIntrinsic("%Temporal.PlainDateTime%");
        const calendar2 = GetSlot(this, CALENDAR);
        const dtStart = new DateTime(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), 0, 0, 0, 0, 0, 0, calendar2);
        const timeZone2 = GetSlot(this, TIME_ZONE);
        const instant2 = BuiltinTimeZoneGetInstantFor(timeZone2, dtStart, "compatible");
        return CreateTemporalZonedDateTime(GetSlot(instant2, EPOCHNANOSECONDS), timeZone2, calendar2);
      }
      toInstant() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        const TemporalInstant = GetIntrinsic("%Temporal.Instant%");
        return new TemporalInstant(GetSlot(this, EPOCHNANOSECONDS));
      }
      toPlainDate() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return TemporalDateTimeToDate(dateTime(this));
      }
      toPlainTime() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return TemporalDateTimeToTime(dateTime(this));
      }
      toPlainDateTime() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        return dateTime(this);
      }
      toPlainYearMonth() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        const calendar2 = GetSlot(this, CALENDAR);
        const fieldNames = CalendarFields(calendar2, ["monthCode", "year"]);
        const fields = ToTemporalYearMonthFields(this, fieldNames);
        return YearMonthFromFields(calendar2, fields);
      }
      toPlainMonthDay() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        const calendar2 = GetSlot(this, CALENDAR);
        const fieldNames = CalendarFields(calendar2, ["day", "monthCode"]);
        const fields = ToTemporalMonthDayFields(this, fieldNames);
        return MonthDayFromFields(calendar2, fields);
      }
      getISOFields() {
        if (!IsTemporalZonedDateTime(this))
          throw new TypeError("invalid receiver");
        const dt = dateTime(this);
        const tz = GetSlot(this, TIME_ZONE);
        return {
          calendar: GetSlot(this, CALENDAR),
          isoDay: GetSlot(dt, ISO_DAY),
          isoHour: GetSlot(dt, ISO_HOUR),
          isoMicrosecond: GetSlot(dt, ISO_MICROSECOND),
          isoMillisecond: GetSlot(dt, ISO_MILLISECOND),
          isoMinute: GetSlot(dt, ISO_MINUTE),
          isoMonth: GetSlot(dt, ISO_MONTH),
          isoNanosecond: GetSlot(dt, ISO_NANOSECOND),
          isoSecond: GetSlot(dt, ISO_SECOND),
          isoYear: GetSlot(dt, ISO_YEAR),
          offset: BuiltinTimeZoneGetOffsetStringFor(tz, GetSlot(this, INSTANT)),
          timeZone: tz
        };
      }
      static from(item, optionsParam = void 0) {
        const options = GetOptionsObject(optionsParam);
        if (IsTemporalZonedDateTime(item)) {
          ToTemporalOverflow(options);
          ToTemporalDisambiguation(options);
          ToTemporalOffset(options, "reject");
          return CreateTemporalZonedDateTime(GetSlot(item, EPOCHNANOSECONDS), GetSlot(item, TIME_ZONE), GetSlot(item, CALENDAR));
        }
        return ToTemporalZonedDateTime(item, options);
      }
      static compare(oneParam, twoParam) {
        const one = ToTemporalZonedDateTime(oneParam);
        const two = ToTemporalZonedDateTime(twoParam);
        const ns1 = GetSlot(one, EPOCHNANOSECONDS);
        const ns2 = GetSlot(two, EPOCHNANOSECONDS);
        if (import_jsbi.default.lessThan(import_jsbi.default.BigInt(ns1), import_jsbi.default.BigInt(ns2)))
          return -1;
        if (import_jsbi.default.greaterThan(import_jsbi.default.BigInt(ns1), import_jsbi.default.BigInt(ns2)))
          return 1;
        return 0;
      }
    };
    MakeIntrinsicClass(ZonedDateTime, "Temporal.ZonedDateTime");
    temporal = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      Instant,
      Calendar,
      PlainDate,
      PlainDateTime,
      Duration,
      PlainMonthDay,
      Now,
      PlainTime,
      TimeZone,
      PlainYearMonth,
      ZonedDateTime
    });
    types2 = [
      Instant,
      Calendar,
      PlainDate,
      PlainDateTime,
      Duration,
      PlainMonthDay,
      PlainTime,
      TimeZone,
      PlainYearMonth,
      ZonedDateTime
    ];
    for (const type of types2) {
      const descriptor2 = Object.getOwnPropertyDescriptor(type, "prototype");
      if (descriptor2.configurable || descriptor2.enumerable || descriptor2.writable) {
        descriptor2.configurable = false;
        descriptor2.enumerable = false;
        descriptor2.writable = false;
        Object.defineProperty(type, "prototype", descriptor2);
      }
    }
  }
});

// .svelte-kit/output/server/chunks/blog-body-bada017e.js
function readingTime(blogContent, wpm = 225) {
  const text = blogContent.replace(/<\/?[^>]+(>|$)/, "").trim();
  return Math.ceil(text.split(/\s+/).length / wpm);
}
var css$15, Labels, css11, Blog_body;
var init_blog_body_bada017e = __esm({
  ".svelte-kit/output/server/chunks/blog-body-bada017e.js"() {
    init_index_b01bd1b0();
    css$15 = {
      code: ".labels.svelte-freffs.svelte-freffs{display:flex;flex-direction:row;flex-wrap:wrap;gap:0.2em;font-size:1em}.labels.svelte-freffs small.svelte-freffs{background-color:var(--acm-light);border-radius:5px;padding:0.3em}",
      map: null
    };
    Labels = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      let { data = [] } = $$props;
      if ($$props.data === void 0 && $$bindings.data && data !== void 0)
        $$bindings.data(data);
      $$result.css.add(css$15);
      return `${data.length > 0 ? `<div class="${"labels svelte-freffs"}">${each(data, (label) => {
        return `<small class="${"label svelte-freffs"}">#${escape(label)}</small>`;
      })}</div>` : ``}`;
    });
    css11 = {
      code: "@import '$lib/blog/syntax-highlight.css';.blog-body.svelte-4tvzbr{text-align:left}.blog-body.svelte-4tvzbr p{margin-bottom:16px}.blog-body.svelte-4tvzbr code,.blog-body.svelte-4tvzbr pre{font-family:monospace;font-size:1.2em;background-color:var(--acm-canvas);border-radius:0.5em;overflow:auto;margin:0.5em 0}.blog-body.svelte-4tvzbr pre{padding:16px}.blog-body.svelte-4tvzbr code{border-radius:0.3em;padding:0.1em 0.5em;margin:0 0.3em}",
      map: null
    };
    Blog_body = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      let { data = "" } = $$props;
      if ($$props.data === void 0 && $$bindings.data && data !== void 0)
        $$bindings.data(data);
      $$result.css.add(css11);
      return `<div class="${"blog-body svelte-4tvzbr"}"><!-- HTML_TAG_START -->${data}<!-- HTML_TAG_END -->
</div>`;
    });
  }
});

// .svelte-kit/output/server/entries/pages/blog/index.svelte.js
var index_svelte_exports3 = {};
__export(index_svelte_exports3, {
  default: () => Blog,
  load: () => load
});
async function load({ fetch: fetch3 }) {
  const response = await fetch3(`/blog.json`);
  return { props: { posts: await response.json() } };
}
var css12, Blog;
var init_index_svelte3 = __esm({
  ".svelte-kit/output/server/entries/pages/blog/index.svelte.js"() {
    init_index_b01bd1b0();
    init_spacing_a132bf4f();
    init_index_esm();
    init_blog_body_bada017e();
    css12 = {
      code: ".subtitle.svelte-e8q134 a.svelte-e8q134.svelte-e8q134{display:inline-block;padding-left:0em;margin-top:3vw;vertical-align:baseline}.subtitle.svelte-e8q134 a.svelte-e8q134 img.svelte-e8q134{width:18px;height:18px}section.svelte-e8q134.svelte-e8q134.svelte-e8q134{display:flex;flex-direction:row;align-items:center;justify-content:center;margin:0 24px}section.svelte-e8q134 .svelte-e8q134.svelte-e8q134{transition:0.25s ease-in-out}section.svelte-e8q134 div h1.svelte-e8q134.svelte-e8q134{font-weight:550;height:95px;line-height:100px}section.svelte-e8q134 div h2.svelte-e8q134.svelte-e8q134{font-weight:600;margin-left:5px}section.svelte-e8q134 img.svelte-e8q134.svelte-e8q134{max-width:200px;width:100%;height:auto;margin-bottom:8px;margin-right:2vw}section.svelte-e8q134 ul.svelte-e8q134.svelte-e8q134{list-style:none;padding:3em 4em 2.5em;margin:0;background-color:var(--acm-light);border-radius:3em;filter:drop-shadow(0 8px 40px rgba(16, 19, 21, 0.1));-webkit-filter:drop-shadow(0 8px 40px rgba(16, 19, 21, 0.1));width:min(1000px, 70vw)}section.svelte-e8q134 ul li.svelte-e8q134.svelte-e8q134{cursor:pointer;background-color:rgba(56, 182, 255, 0.25);border-radius:1em;margin:2em 0}section.svelte-e8q134 ul li a.svelte-e8q134.svelte-e8q134{text-decoration:none;padding:2em;display:flex;flex-direction:column}section.svelte-e8q134 ul li a .markdown-body.svelte-e8q134.svelte-e8q134{max-height:100px;overflow:hidden;margin:16px 0;mask-image:linear-gradient(to bottom, black 50%, transparent 100%);-webkit-mask-image:linear-gradient(to bottom, black 50%, transparent 100%)}section.svelte-e8q134 ul li.svelte-e8q134.svelte-e8q134:hover{background-color:rgba(56, 182, 255, 0.5)}section.svelte-e8q134 .author.svelte-e8q134.svelte-e8q134{display:flex;gap:1em;margin-bottom:1em;align-items:center}section.svelte-e8q134 .author img.svelte-e8q134.svelte-e8q134{border-radius:50%;width:2.5em;height:100%;margin:0}section.svelte-e8q134 .author div.svelte-e8q134.svelte-e8q134{display:flex;flex-direction:column}section.svelte-e8q134 .author a.svelte-e8q134.svelte-e8q134{padding:0;font-weight:600}section.svelte-e8q134 .author a.svelte-e8q134.svelte-e8q134:hover{text-decoration:underline}section.svelte-e8q134 .read-time.svelte-e8q134.svelte-e8q134{display:flex;flex-wrap:wrap;align-items:center;font-size:1em;gap:1em}@media(max-width: 600px){.main-header.svelte-e8q134.svelte-e8q134.svelte-e8q134{flex-direction:column}.main-header.svelte-e8q134 div h2.svelte-e8q134.svelte-e8q134{text-align:center}.subtitle.svelte-e8q134.svelte-e8q134.svelte-e8q134{text-align:center;padding-top:1em}}@media(max-width: 600px){.main-header.svelte-e8q134.svelte-e8q134.svelte-e8q134{flex-direction:column}.main-header.svelte-e8q134 div h2.svelte-e8q134.svelte-e8q134{text-align:center}.subtitle.svelte-e8q134.svelte-e8q134.svelte-e8q134{text-align:center;padding-top:1em}}@media(max-width: 900px){section.svelte-e8q134 ul.svelte-e8q134.svelte-e8q134{padding:1em 2.5em}section.svelte-e8q134 ul li.svelte-e8q134.svelte-e8q134{border-radius:1.5em}}",
      map: null
    };
    Blog = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      let { posts: posts2 = [] } = $$props;
      if ($$props.posts === void 0 && $$bindings.posts && posts2 !== void 0)
        $$bindings.posts(posts2);
      $$result.css.add(css12);
      return `${$$result.head += `${$$result.title = `<title>README / ACM at CSUF</title>`, ""}`, ""}

<div style="display: contents; --min:${"175px"}; --med:${"200px"}; --max:${"200px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

<section class="${"main-header svelte-e8q134"}"><img src="${"/assets/readme-logomark.svg"}" alt="${"README by acmCSUF"}" class="${"svelte-e8q134"}">

  <div class="${"svelte-e8q134"}"><h1 class="${"size-xxl svelte-e8q134"}">README</h1>
    <h2 class="${"size-md svelte-e8q134"}">by ACM at <b class="${"acm-blue svelte-e8q134"}">CSUF</b></h2></div></section>

<section class="${"svelte-e8q134"}"><h2 class="${"subtitle headers size-md svelte-e8q134"}">The official ACM at CSUF blog.<a href="${"/blog.xml"}" class="${"svelte-e8q134"}"><img src="${"assets/badges/feed-icon.svg"}" alt="${"RSS feed logo"}" class="${"svelte-e8q134"}"></a></h2></section>

<div style="display: contents; --min:${"175px"}; --med:${"200px"}; --max:${"200px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

<section class="${"svelte-e8q134"}"><ul class="${"svelte-e8q134"}">${each(posts2, (post) => {
        return `<li class="${"blog-post svelte-e8q134"}"><a${add_attribute("href", `/blog/${post.id}`, 0)} sveltekit:prefetch class="${"svelte-e8q134"}"><div class="${"author svelte-e8q134"}"><a${add_attribute("href", post.author.url, 0)} class="${"svelte-e8q134"}"><img${add_attribute("src", post.author.picture, 0)} alt="${""}" class="${"svelte-e8q134"}"></a>
            <div class="${"svelte-e8q134"}"><a${add_attribute("href", post.author.url, 0)} class="${"svelte-e8q134"}">${escape(post.author.displayname)}</a>
            </div></div>
          <h2 class="${"headers svelte-e8q134"}">${escape(post.title)}</h2>
          <div class="${"markdown-body svelte-e8q134"}">${validate_component(Blog_body, "BlogBody").$$render($$result, { data: post.html }, {}, {})}</div>
          <p class="${"read-time svelte-e8q134"}">${escape(temporal.Instant.from(post.createdAt).toLocaleString("en-US", {
          calendar: "gregory",
          year: "numeric",
          month: "long",
          day: "numeric"
        }))} \u2022
            ${escape(readingTime(post.html))} min read
            ${validate_component(Labels, "Labels").$$render($$result, { data: post.labels }, {}, {})}
          </p></a>
      </li>`;
      })}</ul></section>

<div style="display: contents; --min:${"40px"}; --med:${"95px"}; --max:${"120px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/4.js
var __exports5 = {};
__export(__exports5, {
  css: () => css13,
  entry: () => entry5,
  js: () => js5,
  module: () => index_svelte_exports3
});
var entry5, js5, css13;
var init__5 = __esm({
  ".svelte-kit/output/server/nodes/4.js"() {
    init_index_svelte3();
    entry5 = "pages/blog/index.svelte-2d5ff004.js";
    js5 = ["pages/blog/index.svelte-2d5ff004.js", "chunks/index-462fa7ca.js", "chunks/spacing-fc7d06b9.js", "chunks/blog-body-8e352a6b.js"];
    css13 = ["assets/pages/blog/index.svelte-f242648f.css", "assets/spacing-b2079594.css", "assets/blog-body-7e4def7c.css"];
  }
});

// .svelte-kit/output/server/chunks/common-hero-993af1f9.js
var css14, Common_hero;
var init_common_hero_993af1f9 = __esm({
  ".svelte-kit/output/server/chunks/common-hero-993af1f9.js"() {
    init_index_b01bd1b0();
    css14 = {
      code: "section.svelte-61rx1s.svelte-61rx1s{display:flex;justify-content:center;text-align:center;margin:0 24px}section.svelte-61rx1s div.svelte-61rx1s{width:min(1150px, 70% + 100px)}section.svelte-61rx1s div.svelte-61rx1s h2{font-weight:600}section.svelte-61rx1s div.svelte-61rx1s p{margin-top:16px}",
      map: null
    };
    Common_hero = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      $$result.css.add(css14);
      return `<section class="${"svelte-61rx1s"}"><div class="${"svelte-61rx1s"}">${slots2.headline ? slots2.headline({ tag: "h2", class: "headline" }) : ``}
    ${slots2.text ? slots2.text({ tag: "p", class: "text" }) : ``}</div>
</section>`;
    });
  }
});

// .svelte-kit/output/server/entries/pages/events/index.svelte.js
var index_svelte_exports4 = {};
__export(index_svelte_exports4, {
  default: () => Events,
  load: () => load2
});
function formatLocation(location, hosted = ["Discord", "Zoom"]) {
  location = (location == null ? void 0 : location.trim()) ?? "";
  if (location === "")
    return "TBD";
  return hosted.includes(location) ? `Hosted on ${location}` : location;
}
async function load2({ fetch: fetch3 }) {
  const response = await fetch3(`/events.json`);
  return { props: { events: await response.json() } };
}
var Copy_link, Copy_text, Google_calendar, Ms_outlook, css$33, Event_item, css$24, Event_list, css$16, Acm_empty, css15, Events;
var init_index_svelte4 = __esm({
  ".svelte-kit/output/server/entries/pages/events/index.svelte.js"() {
    init_index_b01bd1b0();
    init_common_hero_993af1f9();
    init_spacing_a132bf4f();
    init_index_ba3ba78e();
    Copy_link = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      return `<svg xmlns="${"http://www.w3.org/2000/svg"}" class="${"ionicon"}" viewBox="${"0 0 512 512"}"><path d="${"M208 352h-64a96 96 0 010-192h64M304 160h64a96 96 0 010 192h-64M163.29 256h187.42"}" fill="${"none"}" stroke="${"currentColor"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" stroke-width="${"36"}"></path></svg>`;
    });
    Copy_text = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      return `<svg xmlns="${"http://www.w3.org/2000/svg"}" class="${"ionicon"}" viewBox="${"0 0 512 512"}"><rect x="${"128"}" y="${"128"}" width="${"336"}" height="${"336"}" rx="${"57"}" ry="${"57"}" fill="${"none"}" stroke="${"currentColor"}" stroke-linejoin="${"round"}" stroke-width="${"32"}"></rect><path d="${"M383.5 128l.5-24a56.16 56.16 0 00-56-56H112a64.19 64.19 0 00-64 64v216a56.16 56.16 0 0056 56h24"}" fill="${"none"}" stroke="${"currentColor"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" stroke-width="${"32"}"></path></svg>`;
    });
    Google_calendar = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      return `<svg role="${"img"}" viewBox="${"0 0 24 24"}" xmlns="${"http://www.w3.org/2000/svg"}"><path stroke="${"currentColor"}" d="${"M18.316 5.684H24v12.632h-5.684V5.684zM5.684 24h12.632v-5.684H5.684V24zM18.316 5.684V0H1.895A1.894 1.894 0 0 0 0 1.895v16.421h5.684V5.684h12.632zm-7.207 6.25v-.065c.272-.144.5-.349.687-.617s.279-.595.279-.982c0-.379-.099-.72-.3-1.025a2.05 2.05 0 0 0-.832-.714 2.703 2.703 0 0 0-1.197-.257c-.6 0-1.094.156-1.481.467-.386.311-.65.671-.793 1.078l1.085.452c.086-.249.224-.461.413-.633.189-.172.445-.257.767-.257.33 0 .602.088.816.264a.86.86 0 0 1 .322.703c0 .33-.12.589-.36.778-.24.19-.535.284-.886.284h-.567v1.085h.633c.407 0 .748.109 1.02.327.272.218.407.499.407.843 0 .336-.129.614-.387.832s-.565.327-.924.327c-.351 0-.651-.103-.897-.311-.248-.208-.422-.502-.521-.881l-1.096.452c.178.616.505 1.082.977 1.401.472.319.984.478 1.538.477a2.84 2.84 0 0 0 1.293-.291c.382-.193.684-.458.902-.794.218-.336.327-.72.327-1.149 0-.429-.115-.797-.344-1.105a2.067 2.067 0 0 0-.881-.689zm2.093-1.931l.602.913L15 10.045v5.744h1.187V8.446h-.827l-2.158 1.557zM22.105 0h-3.289v5.184H24V1.895A1.894 1.894 0 0 0 22.105 0zm-3.289 23.5l4.684-4.684h-4.684V23.5zM0 22.105C0 23.152.848 24 1.895 24h3.289v-5.184H0v3.289z"}"></path></svg>`;
    });
    Ms_outlook = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      return `<svg role="${"img"}" viewBox="${"0 0 24 24"}" xmlns="${"http://www.w3.org/2000/svg"}"><path stroke="${"currentColor"}" d="${"M7.88 12.04q0 .45-.11.87-.1.41-.33.74-.22.33-.58.52-.37.2-.87.2t-.85-.2q-.35-.21-.57-.55-.22-.33-.33-.75-.1-.42-.1-.86t.1-.87q.1-.43.34-.76.22-.34.59-.54.36-.2.87-.2t.86.2q.35.21.57.55.22.34.31.77.1.43.1.88zM24 12v9.38q0 .46-.33.8-.33.32-.8.32H7.13q-.46 0-.8-.33-.32-.33-.32-.8V18H1q-.41 0-.7-.3-.3-.29-.3-.7V7q0-.41.3-.7Q.58 6 1 6h6.5V2.55q0-.44.3-.75.3-.3.75-.3h12.9q.44 0 .75.3.3.3.3.75V10.85l1.24.72h.01q.1.07.18.18.07.12.07.25zm-6-8.25v3h3v-3zm0 4.5v3h3v-3zm0 4.5v1.83l3.05-1.83zm-5.25-9v3h3.75v-3zm0 4.5v3h3.75v-3zm0 4.5v2.03l2.41 1.5 1.34-.8v-2.73zM9 3.75V6h2l.13.01.12.04v-2.3zM5.98 15.98q.9 0 1.6-.3.7-.32 1.19-.86.48-.55.73-1.28.25-.74.25-1.61 0-.83-.25-1.55-.24-.71-.71-1.24t-1.15-.83q-.68-.3-1.55-.3-.92 0-1.64.3-.71.3-1.2.85-.5.54-.75 1.3-.25.74-.25 1.63 0 .85.26 1.56.26.72.74 1.23.48.52 1.17.81.69.3 1.56.3zM7.5 21h12.39L12 16.08V17q0 .41-.3.7-.29.3-.7.3H7.5zm15-.13v-7.24l-5.9 3.54Z"}"></path></svg>`;
    });
    css$33 = {
      code: '.event-box.svelte-1tqijlc.svelte-1tqijlc.svelte-1tqijlc{position:relative}.event-box.svelte-1tqijlc>.anchor.svelte-1tqijlc.svelte-1tqijlc{visibility:hidden;position:absolute;top:-200px}.event-card.svelte-1tqijlc.svelte-1tqijlc.svelte-1tqijlc{margin:32px 64px;padding:0;box-shadow:0 6px 18px rgba(var(--highlights, --acm-general-rgb), 0.25);transition:all 0.15s ease-in-out;border-radius:30px;border:2px solid var(--acm-dark)}.event-card.svelte-1tqijlc.svelte-1tqijlc.svelte-1tqijlc:hover{box-shadow:0 6px 18px rgba(var(--highlights, --acm-general-rgb), 0.65)}.event-card[open].svelte-1tqijlc.svelte-1tqijlc.svelte-1tqijlc{box-shadow:0 6px 24px rgba(var(--highlights, --acm-general-rgb), 0.75);border:2px solid rgb(var(--highlights, --acm-general-rgb))}.event-card.svelte-1tqijlc:hover h2.svelte-1tqijlc.svelte-1tqijlc,.event-card[open].svelte-1tqijlc h2.svelte-1tqijlc.svelte-1tqijlc{color:rgb(var(--highlights, --acm-general-rgb))}.event-box.svelte-1tqijlc>.anchor.svelte-1tqijlc:target+.event-card.svelte-1tqijlc{box-shadow:0 6px 24px rgba(var(--highlights, --acm-general-rgb), 0.75);border:2px solid rgb(var(--highlights, --acm-general-rgb))}.event-card.svelte-1tqijlc hr.svelte-1tqijlc.svelte-1tqijlc{border-width:1px;border-color:var(--acm-dark);background-color:var(--acm-dark);opacity:0.5;margin:24px 0}.event-card.svelte-1tqijlc>hr.svelte-1tqijlc.svelte-1tqijlc,.event-description.svelte-1tqijlc.svelte-1tqijlc.svelte-1tqijlc{margin:0 30px}.event-body.svelte-1tqijlc.svelte-1tqijlc.svelte-1tqijlc{padding:24px 30px;cursor:pointer;list-style:none;display:flex;flex-direction:row;justify-content:space-between;align-items:center}summary.event-body.svelte-1tqijlc.svelte-1tqijlc.svelte-1tqijlc::-webkit-details-marker{display:none}.event-body.svelte-1tqijlc .event-name.svelte-1tqijlc.svelte-1tqijlc{transition:all 0.15s ease-in-out}.event-body.svelte-1tqijlc:hover .event-name.svelte-1tqijlc.svelte-1tqijlc{color:rgb(var(--highlights, --acm-general-rgb))}.event-body.svelte-1tqijlc:hover .event-join.svelte-1tqijlc.svelte-1tqijlc:hover{color:rgb(var(--highlights, --acm-general-rgb))}.event-body.svelte-1tqijlc h2.svelte-1tqijlc.svelte-1tqijlc{position:relative;user-select:none;color:var(--acm-dark);transition:all 0.15s ease-in-out}.event-date.svelte-1tqijlc.svelte-1tqijlc.svelte-1tqijlc{flex:0;user-select:none;text-align:right;white-space:nowrap}.event-name.svelte-1tqijlc.svelte-1tqijlc.svelte-1tqijlc{flex:1;text-align:left;display:flex;flex-direction:column;align-items:flex-start}.event-name.svelte-1tqijlc.svelte-1tqijlc.svelte-1tqijlc,.event-date.svelte-1tqijlc.svelte-1tqijlc.svelte-1tqijlc{margin-right:16px}.event-name.svelte-1tqijlc h2.svelte-1tqijlc.svelte-1tqijlc{line-height:1.2em}.event-location.svelte-1tqijlc.svelte-1tqijlc.svelte-1tqijlc:not(:empty){margin-top:10px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:300px}.event-join.svelte-1tqijlc.svelte-1tqijlc.svelte-1tqijlc{margin:0;padding:12px 24px;text-decoration:none;text-align:center;border-radius:12px;background-color:var(--acm-dark);color:var(--acm-light);transition:background-color 0.25s ease-in-out}.event-description.svelte-1tqijlc.svelte-1tqijlc.svelte-1tqijlc{margin-top:24px;margin-bottom:24px;overflow-wrap:break-word}.event-description.svelte-1tqijlc.svelte-1tqijlc.svelte-1tqijlc:empty::after{content:"No description.";opacity:0.75;font-style:italic}.event-actionbar.svelte-1tqijlc.svelte-1tqijlc.svelte-1tqijlc{display:flex;flex-direction:row-reverse;padding:0 2em 2em 2em;gap:1em}.event-actionbar.svelte-1tqijlc .action-item.svelte-1tqijlc.svelte-1tqijlc{--size:40px;color:var(--highlights);width:var(--size);height:var(--size);padding:calc(var(--size) * 0.15);box-shadow:0 6px 18px rgba(var(--highlights, --acm-general-rgb), 0.25);transition:all 0.25s ease-in-out;border-radius:30px;border:2px solid var(--acm-dark);background-color:var(--acm-light)}.event-actionbar.svelte-1tqijlc .action-item.svelte-1tqijlc.svelte-1tqijlc:hover{box-shadow:0 6px 18px rgba(var(--highlights, --acm-general-rgb), 0.66)}@media(max-width: 799px){.event-body.svelte-1tqijlc.svelte-1tqijlc.svelte-1tqijlc{flex-direction:column}.event-name.svelte-1tqijlc.svelte-1tqijlc.svelte-1tqijlc{text-align:center;margin-right:0;align-items:center}.event-date.svelte-1tqijlc.svelte-1tqijlc.svelte-1tqijlc{margin-top:10px;margin-bottom:12px;margin-right:0}}',
      map: null
    };
    Event_item = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      let { info } = $$props;
      let isRecurring = info.recurring;
      let anchor;
      let details;
      if ($$props.info === void 0 && $$bindings.info && info !== void 0)
        $$bindings.info(info);
      $$result.css.add(css$33);
      return `<div class="${"event-box svelte-1tqijlc"}"${add_styles({
        "--highlights": `var(--acm-${info.acmPath.slug}-rgb)`
      })}>
  <div class="${"anchor svelte-1tqijlc"}"${add_attribute("id", info.slug, 0)}${add_attribute("this", anchor, 0)}></div>
  <details class="${"event-card svelte-1tqijlc"}"${add_attribute("this", details, 0)}><summary class="${"event-body svelte-1tqijlc"}"><div class="${"event-name svelte-1tqijlc"}"><h2 class="${"headers svelte-1tqijlc"}">${escape(info.title)}</h2>

        <p class="${"event-location svelte-1tqijlc"}">${escape(formatLocation(info.location))}</p></div>

      <p class="${"event-date svelte-1tqijlc"}">
        <time>${escape(info.month)}
          ${escape(info.day)} at ${escape(info.time)}
          ${isRecurring ? `(recurring)` : ``}</time></p>

      <a class="${"event-join size-sm svelte-1tqijlc"}"${add_attribute("href", info.meetingLink, 0)} role="${"button"}" target="${"_blank"}" rel="${"noopener noreferrer"}">Join</a></summary>

    <hr class="${"svelte-1tqijlc"}">

    <p class="${"event-description svelte-1tqijlc"}"><!-- HTML_TAG_START -->${info.description}<!-- HTML_TAG_END --></p>

    <div class="${"event-actionbar svelte-1tqijlc"}"><button class="${"action-item svelte-1tqijlc"}" title="${"Copy event link"}">${validate_component(Copy_link, "CopyLinkIcon").$$render($$result, {}, {}, {})}</button>

      <button class="${"action-item svelte-1tqijlc"}" title="${"Copy event summary"}">${validate_component(Copy_text, "CopyTextIcon").$$render($$result, {}, {}, {})}</button>

      <button class="${"action-item svelte-1tqijlc"}" title="${"Copy Google Calendar link"}">${validate_component(Google_calendar, "GoogleCalendarIcon").$$render($$result, {}, {}, {})}</button>

      <button class="${"action-item svelte-1tqijlc"}" title="${"Copy Microsoft Outlook calendar link"}">${validate_component(Ms_outlook, "MsOutlookIcon").$$render($$result, {}, {}, {})}</button></div></details>
</div>`;
    });
    css$24 = {
      code: "section.svelte-1a1n69x{display:flex;justify-content:center;margin-left:0px}.event-list-container.svelte-1a1n69x{width:clamp(435px, 95%, 980px)}",
      map: null
    };
    Event_list = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      let { events: events2 = [] } = $$props;
      if ($$props.events === void 0 && $$bindings.events && events2 !== void 0)
        $$bindings.events(events2);
      $$result.css.add(css$24);
      return `<section class="${"svelte-1a1n69x"}"><div class="${"event-list-container svelte-1a1n69x"}">${each(events2, (eventInfo) => {
        return `${validate_component(Event_item, "EventItem").$$render($$result, { info: eventInfo }, {}, {})}`;
      })}</div>
</section>`;
    });
    css$16 = {
      code: "section.svelte-egpbw2{width:100%;display:flex;justify-content:center}section.svelte-egpbw2 p{font-size:var(--size-lg);margin:20px}",
      map: null
    };
    Acm_empty = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      $$result.css.add(css$16);
      return `<section class="${"svelte-egpbw2"}">${slots2.content ? slots2.content({ tag: "p" }) : ``}
</section>`;
    });
    css15 = {
      code: ".main-header.svelte-143iokf.svelte-143iokf{display:flex;justify-content:center;text-align:center;align-items:center;flex-direction:row}.main-header.svelte-143iokf img.svelte-143iokf{display:block;margin-left:10px;width:30px;height:30px}p.svelte-143iokf.svelte-143iokf{text-align:center}@media(max-width: 300px){.main-header.svelte-143iokf img.svelte-143iokf{display:none}}",
      map: null
    };
    Events = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      let { events: events2 = [] } = $$props;
      if ($$props.events === void 0 && $$bindings.events && events2 !== void 0)
        $$bindings.events(events2);
      $$result.css.add(css15);
      return `${$$result.head += `${$$result.title = `<title>Events / ACM at CSUF</title>`, ""}`, ""}

<div style="display: contents; --min:${"175px"}; --med:${"200px"}; --max:${"200px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

${validate_component(Common_hero, "CommonHero").$$render($$result, {}, {}, {
        text: () => {
          return `<p slot="${"text"}" class="${"size-md svelte-143iokf"}">Our student chapter hosts a multitude of events throughout each school semester, consisting of
    workshops, info sessions, community building events, and much more!
    <br><br>
    <span class="${"brand-med"}">Events are open to anyone interested, regardless of major or background experience.</span></p>`;
        },
        headline: () => {
          return `<h2 slot="${"headline"}" class="${"size-lg"}">Curated events for growth and success</h2>`;
        }
      })}

<div style="display: contents; --min:${"100px"}; --med:${"175px"}; --max:${"200px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

<div class="${"main-header svelte-143iokf"}"><h2 class="${"size-lg headers"}">Upcoming Events</h2>
  <img src="${"assets/bluecalender.svg"}" alt="${"Blue Calender"}" class="${"svelte-143iokf"}"></div>

<div style="display: contents; --med:${"16px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

${events2.length > 0 ? `${validate_component(Event_list, "EventCarousel").$$render($$result, { events: events2 }, {}, {})}` : `${validate_component(Acm_empty, "AcmEmpty").$$render($$result, {}, {}, {
        content: () => {
          return `<p slot="${"content"}" class="${"svelte-143iokf"}">There are no events scheduled!</p>`;
        }
      })}`}

<div style="display: contents; --min:${"8px"}; --med:${"63px"}; --max:${"88px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/5.js
var __exports6 = {};
__export(__exports6, {
  css: () => css16,
  entry: () => entry6,
  js: () => js6,
  module: () => index_svelte_exports4
});
var entry6, js6, css16;
var init__6 = __esm({
  ".svelte-kit/output/server/nodes/5.js"() {
    init_index_svelte4();
    entry6 = "pages/events/index.svelte-8311e5d3.js";
    js6 = ["pages/events/index.svelte-8311e5d3.js", "chunks/index-462fa7ca.js", "chunks/common-hero-bf78f3c8.js", "chunks/spacing-fc7d06b9.js", "chunks/toasts-8c4e63ab.js", "chunks/index-cc4b3e8c.js", "chunks/index-af743adc.js", "chunks/acm-paths-c5897a25.js"];
    css16 = ["assets/pages/events/index.svelte-50f415b6.css", "assets/common-hero-ea793bd7.css", "assets/spacing-b2079594.css"];
  }
});

// .svelte-kit/output/server/entries/pages/nodebuds/index.svelte.js
var index_svelte_exports5 = {};
__export(index_svelte_exports5, {
  default: () => Nodebuds
});
var css17, Nodebuds;
var init_index_svelte5 = __esm({
  ".svelte-kit/output/server/entries/pages/nodebuds/index.svelte.js"() {
    init_index_b01bd1b0();
    init_spacing_a132bf4f();
    init_officer_profile_list_ec5ae8e4();
    init_officers_1f1dc4ef();
    init_index_ba3ba78e();
    init_index_b8bace31();
    css17 = {
      code: ".container.svelte-7ixbs.svelte-7ixbs{display:flex;justify-content:center;margin:0 32px}section.svelte-7ixbs.svelte-7ixbs{display:flex;justify-content:space-between;align-items:center;width:1100px}section.svelte-7ixbs img.svelte-7ixbs{margin-right:-32px;width:350px;filter:drop-shadow(0 10px 40px rgba(212, 17, 83, 0.5));-webkit-filter:drop-shadow(0 10px 40px rgba(212, 17, 83, 0.5))}section.svelte-7ixbs div.svelte-7ixbs{max-width:600px}section.svelte-7ixbs h2.svelte-7ixbs{padding-bottom:16px}.w-text.svelte-7ixbs.svelte-7ixbs{text-decoration:none;color:var(--acm-dark);transition:color 0.25s ease-in-out}.w-text.svelte-7ixbs.svelte-7ixbs:hover{color:var(--acm-blue)}@media(max-width: 900px){section.svelte-7ixbs.svelte-7ixbs{flex-direction:column-reverse;text-align:center}section.svelte-7ixbs img.svelte-7ixbs{margin:0;width:175px;padding-bottom:32px}}",
      map: null
    };
    Nodebuds = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      let $termIndex, $$unsubscribe_termIndex;
      $$unsubscribe_termIndex = subscribe(termIndex, (value) => $termIndex = value);
      function filterNodeBuddies(officer) {
        const position = officer.positions[VISIBLE_TERMS[$termIndex]];
        if (position === void 0) {
          return false;
        }
        const isNodeBuddy = position.title.toUpperCase().includes("NODEBUDS");
        return isNodeBuddy;
      }
      $$result.css.add(css17);
      $$unsubscribe_termIndex();
      return `${$$result.head += `${$$result.title = `<title>Node Buds | ACM at CSUF</title>`, ""}`, ""}

<div style="display: contents; --min:${"175px"}; --med:${"200px"}; --max:${"200px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

<div class="${"container svelte-7ixbs"}"><section class="${"svelte-7ixbs"}"><div class="${"svelte-7ixbs"}"><h2 class="${"headers size-lg svelte-7ixbs"}">Personalized for your success</h2>
      <p class="${"size-xs"}"><span class="${"headers"}">node buds </span>
        is our exclusive program in partnership with
        <a href="${"/acm-w"}" class="${"headers w-text svelte-7ixbs"}" target="${"_blank"}" rel="${"noopener noreferrer"}">ACM-W</a>
        that exposes students to various opportunities that encourage connection, skill building, as
        well as both personal and technical development.
        <br><br>
        Everone under this program will get paired with student-mentors, called
        <span class="${"brand-med"}">Buddies</span>, who will be there to help students prepare for their
        successful journeys through the tech industry.
      </p></div>
    <img src="${"assets/badges/nodebuds.svg"}" alt="${"nodeBuds badge"}" class="${"svelte-7ixbs"}"></section></div>

<div style="display: contents; --min:${"100px"}; --med:${"175px"}; --max:${"200px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

<div class="${"container svelte-7ixbs"}"><h2 class="${"headers size-lg"}">Buddies</h2></div>

<div style="display: contents; --min:${"16px"}; --med:${"16px"}; --max:${"16px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

${validate_component(Officer_profile_list, "OfficerProfileList").$$render($$result, { filter: filterNodeBuddies }, {}, {})}

<div style="display: contents; --min:${"40px"}; --med:${"95px"}; --max:${"120px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/7.js
var __exports7 = {};
__export(__exports7, {
  css: () => css18,
  entry: () => entry7,
  js: () => js7,
  module: () => index_svelte_exports5
});
var entry7, js7, css18;
var init__7 = __esm({
  ".svelte-kit/output/server/nodes/7.js"() {
    init_index_svelte5();
    entry7 = "pages/nodebuds/index.svelte-98193a66.js";
    js7 = ["pages/nodebuds/index.svelte-98193a66.js", "chunks/index-462fa7ca.js", "chunks/spacing-fc7d06b9.js", "chunks/officer-profile-list-3690987d.js", "chunks/index-cc4b3e8c.js", "chunks/index-af743adc.js"];
    css18 = ["assets/pages/nodebuds/index.svelte-120ba24a.css", "assets/spacing-b2079594.css", "assets/officer-profile-list-9f843ddf.css"];
  }
});

// .svelte-kit/output/server/entries/pages/paths/index.svelte.js
var index_svelte_exports6 = {};
__export(index_svelte_exports6, {
  default: () => Paths
});
var TextAlignment, css19, Path_section, Paths;
var init_index_svelte6 = __esm({
  ".svelte-kit/output/server/entries/pages/paths/index.svelte.js"() {
    init_index_b01bd1b0();
    init_acm_paths_c5897a25();
    init_common_hero_993af1f9();
    init_spacing_a132bf4f();
    TextAlignment = /* @__PURE__ */ ((TextAlignment2) => {
      TextAlignment2["Left"] = "left";
      TextAlignment2["Right"] = "right";
      return TextAlignment2;
    })(TextAlignment || {});
    css19 = {
      code: '@charset "UTF-8";.container.svelte-1vdv3s2.svelte-1vdv3s2{display:flex;justify-content:center}section.svelte-1vdv3s2.svelte-1vdv3s2{display:flex;justify-content:space-between;align-items:center;width:1064px;margin:0 32px;scroll-margin-top:4rem}section.svelte-1vdv3s2 img.svelte-1vdv3s2{margin-left:-32px;width:350px}section.svelte-1vdv3s2 div.svelte-1vdv3s2{text-align:right;max-width:650px}section.svelte-1vdv3s2 div h2.svelte-1vdv3s2{padding-bottom:16px}section.svelte-1vdv3s2 div h2 span span.svelte-1vdv3s2{color:var(--font-color)}.\u{1F448}.svelte-1vdv3s2.svelte-1vdv3s2{flex-direction:row-reverse}.\u{1F448}.svelte-1vdv3s2 div.svelte-1vdv3s2{text-align:left}.\u{1F448}.svelte-1vdv3s2 img.svelte-1vdv3s2{margin-right:-32px}@media(max-width: 900px){section.svelte-1vdv3s2.svelte-1vdv3s2,.\u{1F448}.svelte-1vdv3s2.svelte-1vdv3s2{flex-direction:column}section.svelte-1vdv3s2 div.svelte-1vdv3s2,.\u{1F448}.svelte-1vdv3s2 div.svelte-1vdv3s2{text-align:center}section.svelte-1vdv3s2 img.svelte-1vdv3s2,.\u{1F448}.svelte-1vdv3s2 img.svelte-1vdv3s2{margin:0;width:200px}}',
      map: null
    };
    Path_section = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      let { textAlign = TextAlignment.Right } = $$props;
      let { info } = $$props;
      if ($$props.textAlign === void 0 && $$bindings.textAlign && textAlign !== void 0)
        $$bindings.textAlign(textAlign);
      if ($$props.info === void 0 && $$bindings.info && info !== void 0)
        $$bindings.info(info);
      $$result.css.add(css19);
      return `<div class="${"container svelte-1vdv3s2"}">${info !== void 0 ? `<section${add_attribute("id", info.slug, 0)} class="${["svelte-1vdv3s2", textAlign === TextAlignment.Left ? "\u{1F448}" : ""].join(" ").trim()}"><img${add_attribute("src", info.picture, 0)}${add_attribute("alt", `acm${info.title} Logo`, 0)} class="${"svelte-1vdv3s2"}">
      <div class="${"svelte-1vdv3s2"}"><h2 class="${"svelte-1vdv3s2"}"><span class="${"headers size-lg svelte-1vdv3s2"}">acm<span class="${"svelte-1vdv3s2"}"${add_styles({ "--font-color": info.color })}><span class="${"brand-em svelte-1vdv3s2"}">${escape(info.title)}</span></span></span></h2>
        ${slots2.content ? slots2.content({ tag: "p" }) : ``}</div></section>` : ``}
</div>`;
    });
    Paths = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      return `${$$result.head += `${$$result.title = `<title>Paths | ACM at CSUF</title>`, ""}`, ""}

<div style="display: contents; --min:${"175px"}; --med:${"200px"}; --max:${"200px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

${validate_component(Common_hero, "CommonHero").$$render($$result, {}, {}, {
        text: () => {
          return `<p slot="${"text"}" class="${"size-md"}">Paths are committees that specialize in specific fields in the tech industry. We\u2019ve designed
    paths to be gateways for students to explore new fields, develop new interests, and enhance
    skills that\u2019ll benefit in the industry.
  </p>`;
        },
        headline: () => {
          return `<h2 slot="${"headline"}" class="${"size-xl"}">What are paths?</h2>`;
        }
      })}

<div style="display: contents; --min:${"100px"}; --med:${"175px"}; --max:${"200px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

${validate_component(Path_section, "PathSection").$$render($$result, {
        info: acmAlgo,
        textAlign: TextAlignment.Right
      }, {}, {
        content: () => {
          return `<p slot="${"content"}" class="${"size-md"}">This path is dedicated to building the programming proficiency of students.
    <span class="${"brand-purple brand-em"}">Algo</span> focuses on mastering data structures and algorithms,
    enhancing problem solving abilities, and exploration of competitive programming.
  </p>`;
        }
      })}

<div style="display: contents; --med:${"64px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

${validate_component(Path_section, "PathSection").$$render($$result, {
        info: acmCreate,
        textAlign: TextAlignment.Left
      }, {}, {
        content: () => {
          return `<p slot="${"content"}" class="${"size-md"}">This path is dedicated to emphasizing the importance of product design and product management in
    the tech industry. <span class="${"brand-pink brand-em"}">Create</span> focuses on educating students
    about design principles, design tools, and the intricacies of conceptualization, development, and
    management of a product.
  </p>`;
        }
      })}

<div style="display: contents; --med:${"64px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

${validate_component(Path_section, "PathSection").$$render($$result, {
        info: acmDev,
        textAlign: TextAlignment.Right
      }, {}, {
        content: () => {
          return `<p slot="${"content"}" class="${"size-md"}">This path is dedicated to giving students the opportunity to explore tech via hands-on projects
    and activities. <span class="${"brand-em brand-bluer"}">Dev</span> focuses on introducing students to
    software development, and the various tech stacks used in the industry.
  </p>`;
        }
      })}

<div style="display: contents; --min:${"40px"}; --med:${"95px"}; --max:${"120px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/8.js
var __exports8 = {};
__export(__exports8, {
  css: () => css20,
  entry: () => entry8,
  js: () => js8,
  module: () => index_svelte_exports6
});
var entry8, js8, css20;
var init__8 = __esm({
  ".svelte-kit/output/server/nodes/8.js"() {
    init_index_svelte6();
    entry8 = "pages/paths/index.svelte-31fd4af4.js";
    js8 = ["pages/paths/index.svelte-31fd4af4.js", "chunks/index-462fa7ca.js", "chunks/acm-paths-c5897a25.js", "chunks/common-hero-bf78f3c8.js", "chunks/spacing-fc7d06b9.js"];
    css20 = ["assets/pages/paths/index.svelte-fb181af9.css", "assets/common-hero-ea793bd7.css", "assets/spacing-b2079594.css"];
  }
});

// .svelte-kit/output/server/entries/pages/privacy/index.svelte.js
var index_svelte_exports7 = {};
__export(index_svelte_exports7, {
  default: () => Privacy
});
var css21, Privacy_policy, Privacy;
var init_index_svelte7 = __esm({
  ".svelte-kit/output/server/entries/pages/privacy/index.svelte.js"() {
    init_index_b01bd1b0();
    init_common_hero_993af1f9();
    init_spacing_a132bf4f();
    css21 = {
      code: "main.svelte-rxwpfn.svelte-rxwpfn{width:100%;display:flex;flex-direction:column;align-items:center;justify-content:center}main.svelte-rxwpfn section.svelte-rxwpfn{width:min(800px, 80vw);margin-bottom:50px}main.svelte-rxwpfn section h2.svelte-rxwpfn{padding-bottom:1em}main.svelte-rxwpfn section a.svelte-rxwpfn{text-decoration:none;transition:0.25s ease-in-out}main.svelte-rxwpfn section a.svelte-rxwpfn:hover{color:var(--acm-blue)}",
      map: null
    };
    Privacy_policy = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      $$result.css.add(css21);
      return `<main class="${"svelte-rxwpfn"}"><section id="${"welcome"}" class="${"svelte-rxwpfn"}"><h2 class="${"headers svelte-rxwpfn"}">Welcome to ACM!</h2>

    <p>acmCSUF provides a social online platform, Discord, that brings passionate Titans together to
      engage in multiple conversations regarding our community, the tech field, and many more. Our
      Privacy Policy safeguards the privacy of all members to our server. This notice describes our
      privacy policy by respecting information that is collected from said members to our server.
    </p></section>

  <section id="${"collected-info"}" class="${"svelte-rxwpfn"}"><h2 class="${"headers svelte-rxwpfn"}">Information we collect</h2>

    <p><span class="${"brand-med"}">Information you provide</span>: We collect information that you
      voluntarily provide, such as when you interact with our discord bot. Information that we
      collect may include, but not be limited to, your email address, discord ID, first and last
      name, status, and class subjects.
    </p></section>

  <section id="${"our-info-usage"}" class="${"svelte-rxwpfn"}"><h2 class="${"headers svelte-rxwpfn"}">Our use of your information</h2>

    <p><span class="${"brand-med"}">Data we collect automatically</span>: When you interact with any of
      our discord bots, we receive and store the given information within our database maintained by
      our officers. Our officers may use such information to pool it with others in order to track
      the number of members within our club, the number of members with similar classes, etc.
    </p></section>

  <section id="${"data-retention"}" class="${"svelte-rxwpfn"}"><h2 class="${"headers svelte-rxwpfn"}">Data retention</h2>

    <p>We plan to retain personal data for as long as necessary to fulfill the purposes for which it
      was collected. Data will persist in our database for however long our bot continues to
      operate. Such data shall never be retrieved for distribution purposes.
    </p></section>

  <section id="${"data-rights-and-choices"}" class="${"svelte-rxwpfn"}"><h2 class="${"headers svelte-rxwpfn"}">Your data rights and choices</h2>

    <p>As CSUF students ourselves, we understand that users should be respected and treated equally,
      and so we are giving you full control of what information you would like to provide for us. If
      you would like to completely opt out of interacting with the bots, you can choose to do so. If
      you would like certain information updated, then you may contact us for changes.
    </p></section>

  <section id="${"changes-to-this-policy"}" class="${"svelte-rxwpfn"}"><h2 class="${"headers svelte-rxwpfn"}">Changes to this privacy policy</h2>

    <p>We reserve the right to make updates and modifications on this Policy document at any time and
      from time to time with no prior notice. Please review this document frequently and, most
      importantly, before you provide us any information. The latest update will be indicated at the
      top of the document. Your continued use after the changes made shall indicate your agreement
      with the terms provided.
    </p></section>

  <section id="${"contacting-us"}" class="${"svelte-rxwpfn"}"><h2 class="${"headers svelte-rxwpfn"}">Contacting us</h2>

    <p>Please feel free to contact us if you have any questions about acmCSUF\u2019s Privacy Policy
      by reaching out to any of our Officers via Discord or email us at <a href="${"mailto:acmcsufullerton@gmail.com"}" class="${"brand-med svelte-rxwpfn"}" target="${"_blank"}" rel="${"noopener noreferrer"}">acmcsufullerton@gmail.com</a>.
    </p></section>
</main>`;
    });
    Privacy = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      return `<div style="display: contents; --min:${"175px"}; --med:${"200px"}; --max:${"200px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

${validate_component(Common_hero, "CommonHero").$$render($$result, {}, {}, {
        text: () => {
          return `<p slot="${"text"}" class="${"size-sm"}">Our privacy policy describes how our Discord bot collects, uses, and shares your personal data.
    <br>
    <br>
    Last updated January 16th, 2022
  </p>`;
        },
        headline: () => {
          return `<h2 slot="${"headline"}" class="${"size-lg"}">Privacy Policy</h2>`;
        }
      })}

<div style="display: contents; --med:${"64px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

${validate_component(Privacy_policy, "PrivacyPolicy").$$render($$result, {}, {}, {})}

<div style="display: contents; --min:${"40px"}; --med:${"95px"}; --max:${"120px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/9.js
var __exports9 = {};
__export(__exports9, {
  css: () => css22,
  entry: () => entry9,
  js: () => js9,
  module: () => index_svelte_exports7
});
var entry9, js9, css22;
var init__9 = __esm({
  ".svelte-kit/output/server/nodes/9.js"() {
    init_index_svelte7();
    entry9 = "pages/privacy/index.svelte-6ab62cad.js";
    js9 = ["pages/privacy/index.svelte-6ab62cad.js", "chunks/index-462fa7ca.js", "chunks/common-hero-bf78f3c8.js", "chunks/spacing-fc7d06b9.js"];
    css22 = ["assets/pages/privacy/index.svelte-460de81b.css", "assets/common-hero-ea793bd7.css", "assets/spacing-b2079594.css"];
  }
});

// .svelte-kit/output/server/entries/pages/blog/_id_.svelte.js
var id_svelte_exports = {};
__export(id_svelte_exports, {
  default: () => U5Bidu5D,
  load: () => load3
});
async function load3({ fetch: fetch3, params }) {
  const response = await fetch3(`/blog/${params.id}.json`);
  const newsletter = await response.json();
  if (typeof (newsletter === null || newsletter === void 0 ? void 0 : newsletter.id) !== "number") {
    return { status: 404 };
  }
  return { props: { post: newsletter } };
}
var css23, U5Bidu5D;
var init_id_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/blog/_id_.svelte.js"() {
    init_index_b01bd1b0();
    init_spacing_a132bf4f();
    init_blog_body_bada017e();
    init_index_esm();
    css23 = {
      code: "section.svelte-2hrly1.svelte-2hrly1{display:flex;flex-direction:column;text-align:center;justify-content:center;align-items:center;padding:0 24px}section.svelte-2hrly1 a.svelte-2hrly1{text-decoration:none;font-weight:500;transition:0.25s ease-in-out}section.svelte-2hrly1 a.svelte-2hrly1:hover{color:var(--acm-blue)}.container.svelte-2hrly1.svelte-2hrly1{text-align:left;padding:4em 4em 3em;margin:0;background-color:var(--acm-light);border-radius:3em;filter:drop-shadow(0 8px 40px rgba(16, 19, 21, 0.1));-webkit-filter:drop-shadow(0 8px 40px rgba(16, 19, 21, 0.1));width:min(1000px, 70vw)}img.svelte-2hrly1.svelte-2hrly1{height:100%;width:5em;border-radius:50%}",
      map: null
    };
    U5Bidu5D = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
      let { post } = $$props;
      if ($$props.post === void 0 && $$bindings.post && post !== void 0)
        $$bindings.post(post);
      $$result.css.add(css23);
      return `${$$result.head += `${$$result.title = `<title>${escape(post.title)}</title>`, ""}`, ""}

<div style="display: contents; --min:${"175px"}; --med:${"200px"}; --max:${"200px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

<section class="${"svelte-2hrly1"}"><h1 class="${"headers size-lg"}">${escape(post.title)}</h1>

  <div style="display: contents; --min:${"16px"}; --med:${"16px"}; --max:${"16px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>
  <img${add_attribute("src", post.author.picture, 0)} alt="${""}" class="${"svelte-2hrly1"}">
  <div style="display: contents; --min:${"16px"}; --med:${"16px"}; --max:${"16px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>
  <p>by
    <a${add_attribute("href", "https://github.com/" + post.author.displayname, 0)} target="${"_blank"}" rel="${"noopener noreferrer"}" class="${"svelte-2hrly1"}">@${escape(post.author.displayname)}</a></p>
  <p>${escape(temporal.Instant.from(post.createdAt).toLocaleString("en-US", {
        calendar: "gregory",
        year: "numeric",
        month: "long",
        day: "numeric"
      }))} \u2022
    ${escape(readingTime(post.html))} min read
  </p>

  <div style="display: contents; --min:${"40px"}; --med:${"40px"}; --max:${"40px"};">${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}</div>

  <div class="${"container svelte-2hrly1"}">${validate_component(Blog_body, "BlogBody").$$render($$result, { data: post.html }, {}, {})}
    ${validate_component(Labels, "Labels").$$render($$result, { data: post.labels }, {}, {})}
    <small class="${"ita"}">Read as TXT: <a${add_attribute("href", `${post.url}.txt`, 0)} class="${"svelte-2hrly1"}">${escape(post.url)}.txt</a></small></div>

  ${validate_component(Spacing, "Spacing").$$render($$result, {}, {}, {})}
</section>`;
    });
  }
});

// .svelte-kit/output/server/nodes/3.js
var __exports10 = {};
__export(__exports10, {
  css: () => css24,
  entry: () => entry10,
  js: () => js10,
  module: () => id_svelte_exports
});
var entry10, js10, css24;
var init__10 = __esm({
  ".svelte-kit/output/server/nodes/3.js"() {
    init_id_svelte();
    entry10 = "pages/blog/_id_.svelte-c83fd186.js";
    js10 = ["pages/blog/_id_.svelte-c83fd186.js", "chunks/index-462fa7ca.js", "chunks/spacing-fc7d06b9.js", "chunks/blog-body-8e352a6b.js"];
    css24 = ["assets/pages/blog/_id_.svelte-4b414a18.css", "assets/spacing-b2079594.css", "assets/blog-body-7e4def7c.css"];
  }
});

// node_modules/rrule/dist/es5/rrule.min.js
var require_rrule_min = __commonJS({
  "node_modules/rrule/dist/es5/rrule.min.js"(exports, module2) {
    !function(t2, e2) {
      typeof exports == "object" && typeof module2 == "object" ? module2.exports = e2() : typeof define == "function" && define.amd ? define([], e2) : typeof exports == "object" ? exports.rrule = e2() : t2.rrule = e2();
    }(typeof self != "undefined" ? self : exports, function() {
      return r2 = {}, i2.m = n = [function(t2, e2, n2) {
        "use strict";
        n2.r(e2);
        var r3 = ["MO", "TU", "WE", "TH", "FR", "SA", "SU"], f3 = (i3.fromStr = function(t3) {
          return new i3(r3.indexOf(t3));
        }, i3.prototype.nth = function(t3) {
          return this.n === t3 ? this : new i3(this.weekday, t3);
        }, i3.prototype.equals = function(t3) {
          return this.weekday === t3.weekday && this.n === t3.n;
        }, i3.prototype.toString = function() {
          var t3 = r3[this.weekday];
          return this.n && (t3 = (0 < this.n ? "+" : "") + String(this.n) + t3), t3;
        }, i3.prototype.getJsWeekday = function() {
          return this.weekday === 6 ? 0 : this.weekday + 1;
        }, i3);
        function i3(t3, e3) {
          if (e3 === 0)
            throw new Error("Can't create weekday with n == 0");
          this.weekday = t3, this.n = e3;
        }
        function a(t3, e3) {
          e3 === void 0 && (e3 = t3), arguments.length === 1 && (e3 = t3, t3 = 0);
          for (var n3 = [], r4 = t3; r4 < e3; r4++)
            n3.push(r4);
          return n3;
        }
        function Y(t3, e3) {
          var n3 = 0, r4 = [];
          if (b(t3))
            for (; n3 < e3; n3++)
              r4[n3] = [].concat(t3);
          else
            for (; n3 < e3; n3++)
              r4[n3] = t3;
          return r4;
        }
        var D = function(t3) {
          return t3 != null;
        }, p = function(t3) {
          return typeof t3 == "number";
        }, h2 = function(t3) {
          return 0 <= r3.indexOf(t3);
        }, b = Array.isArray;
        function o(t3, e3, n3) {
          n3 === void 0 && (n3 = " ");
          var r4 = String(t3);
          return e3 >>= 0, r4.length > e3 ? String(r4) : ((e3 -= r4.length) > n3.length && (n3 += Y(n3, e3 / n3.length)), n3.slice(0, e3) + String(r4));
        }
        function u(t3, e3) {
          return { div: Math.floor(t3 / e3), mod: U(t3, e3) };
        }
        function S2(t3) {
          return !D(t3) || t3.length === 0;
        }
        var s3, y, c = function(t3, e3, n3) {
          var r4 = t3.split(e3);
          return n3 ? r4.slice(0, n3).concat([r4.slice(n3).join(e3)]) : r4;
        }, U = function(t3, e3) {
          var n3 = t3 % e3;
          return n3 * e3 < 0 ? n3 + e3 : n3;
        }, x2 = function(t3) {
          return !S2(t3);
        }, L = function(t3, e3) {
          return x2(t3) && t3.indexOf(e3) !== -1;
        };
        (y = s3 = s3 || {}).MONTH_DAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], y.ONE_DAY = 864e5, y.MAXYEAR = 9999, y.ORDINAL_BASE = new Date(Date.UTC(1970, 0, 1)), y.PY_WEEKDAYS = [6, 0, 1, 2, 3, 4, 5], y.getYearDay = function(t3) {
          var e3 = new Date(t3.getUTCFullYear(), t3.getUTCMonth(), t3.getUTCDate());
          return Math.ceil((e3.valueOf() - new Date(t3.getUTCFullYear(), 0, 1).valueOf()) / y.ONE_DAY) + 1;
        }, y.isLeapYear = function(t3) {
          return t3 % 4 == 0 && t3 % 100 != 0 || t3 % 400 == 0;
        }, y.isDate = function(t3) {
          return t3 instanceof Date;
        }, y.isValidDate = function(t3) {
          return y.isDate(t3) && !isNaN(t3.getTime());
        }, y.tzOffset = function(t3) {
          return 60 * t3.getTimezoneOffset() * 1e3;
        }, y.daysBetween = function(t3, e3) {
          var n3 = t3.getTime() - y.tzOffset(t3) - (e3.getTime() - y.tzOffset(e3));
          return Math.round(n3 / y.ONE_DAY);
        }, y.toOrdinal = function(t3) {
          return y.daysBetween(t3, y.ORDINAL_BASE);
        }, y.fromOrdinal = function(t3) {
          return new Date(y.ORDINAL_BASE.getTime() + t3 * y.ONE_DAY);
        }, y.getMonthDays = function(t3) {
          var e3 = t3.getUTCMonth();
          return e3 === 1 && y.isLeapYear(t3.getUTCFullYear()) ? 29 : y.MONTH_DAYS[e3];
        }, y.getWeekday = function(t3) {
          return y.PY_WEEKDAYS[t3.getUTCDay()];
        }, y.monthRange = function(t3, e3) {
          var n3 = new Date(Date.UTC(t3, e3, 1));
          return [y.getWeekday(n3), y.getMonthDays(n3)];
        }, y.combine = function(t3, e3) {
          return e3 = e3 || t3, new Date(Date.UTC(t3.getUTCFullYear(), t3.getUTCMonth(), t3.getUTCDate(), e3.getHours(), e3.getMinutes(), e3.getSeconds(), e3.getMilliseconds()));
        }, y.clone = function(t3) {
          return new Date(t3.getTime());
        }, y.cloneDates = function(t3) {
          for (var e3 = [], n3 = 0; n3 < t3.length; n3++)
            e3.push(y.clone(t3[n3]));
          return e3;
        }, y.sort = function(t3) {
          t3.sort(function(t4, e3) {
            return t4.getTime() - e3.getTime();
          });
        }, y.timeToUntilString = function(t3, e3) {
          e3 === void 0 && (e3 = true);
          var n3 = new Date(t3);
          return [o(n3.getUTCFullYear().toString(), 4, "0"), o(n3.getUTCMonth() + 1, 2, "0"), o(n3.getUTCDate(), 2, "0"), "T", o(n3.getUTCHours(), 2, "0"), o(n3.getUTCMinutes(), 2, "0"), o(n3.getUTCSeconds(), 2, "0"), e3 ? "Z" : ""].join("");
        }, y.untilStringToDate = function(t3) {
          var e3 = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/.exec(t3);
          if (!e3)
            throw new Error("Invalid UNTIL value: " + t3);
          return new Date(Date.UTC(parseInt(e3[1], 10), parseInt(e3[2], 10) - 1, parseInt(e3[3], 10), parseInt(e3[5], 10) || 0, parseInt(e3[6], 10) || 0, parseInt(e3[7], 10) || 0));
        };
        var M = s3;
        function d(t3, e3) {
          this.minDate = null, this.maxDate = null, this._result = [], this.total = 0, this.method = t3, this.args = e3, t3 === "between" ? (this.maxDate = e3.inc ? e3.before : new Date(e3.before.getTime() - 1), this.minDate = e3.inc ? e3.after : new Date(e3.after.getTime() + 1)) : t3 === "before" ? this.maxDate = e3.inc ? e3.dt : new Date(e3.dt.getTime() - 1) : t3 === "after" && (this.minDate = e3.inc ? e3.dt : new Date(e3.dt.getTime() + 1));
        }
        var l = (d.prototype.accept = function(t3) {
          ++this.total;
          var e3 = this.minDate && t3 < this.minDate, n3 = this.maxDate && t3 > this.maxDate;
          if (this.method === "between") {
            if (e3)
              return true;
            if (n3)
              return false;
          } else if (this.method === "before") {
            if (n3)
              return false;
          } else if (this.method === "after")
            return !!e3 || (this.add(t3), false);
          return this.add(t3);
        }, d.prototype.add = function(t3) {
          return this._result.push(t3), true;
        }, d.prototype.getValue = function() {
          var t3 = this._result;
          switch (this.method) {
            case "all":
            case "between":
              return t3;
            case "before":
            case "after":
            default:
              return t3.length ? t3[t3.length - 1] : null;
          }
        }, d.prototype.clone = function() {
          return new d(this.method, this.args);
        }, d), m2 = function(t3, e3) {
          return (m2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
            t4.__proto__ = e4;
          } || function(t4, e4) {
            for (var n3 in e4)
              e4.hasOwnProperty(n3) && (t4[n3] = e4[n3]);
          })(t3, e3);
        };
        function w(t3, e3) {
          function n3() {
            this.constructor = t3;
          }
          m2(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (n3.prototype = e3.prototype, new n3());
        }
        var v, _ = function() {
          return (_ = Object.assign || function(t3) {
            for (var e3, n3 = 1, r4 = arguments.length; n3 < r4; n3++)
              for (var i4 in e3 = arguments[n3])
                Object.prototype.hasOwnProperty.call(e3, i4) && (t3[i4] = e3[i4]);
            return t3;
          }).apply(this, arguments);
        };
        function g() {
          for (var t3 = 0, e3 = 0, n3 = arguments.length; e3 < n3; e3++)
            t3 += arguments[e3].length;
          var r4 = Array(t3), i4 = 0;
          for (e3 = 0; e3 < n3; e3++)
            for (var a2 = arguments[e3], o2 = 0, s4 = a2.length; o2 < s4; o2++, i4++)
              r4[i4] = a2[o2];
          return r4;
        }
        function k(t3, e3, n3) {
          var r4 = v.call(this, t3, e3) || this;
          return r4.iterator = n3, r4;
        }
        function E(t3, e3) {
          return t3.indexOf(e3) !== -1;
        }
        function T(t3) {
          return t3.toString();
        }
        function O(t3, e3, n3) {
          return e3 + " " + n3 + ", " + t3;
        }
        var R = (w(k, v = l), k.prototype.add = function(t3) {
          return !!this.iterator(t3, this._result.length) && (this._result.push(t3), true);
        }, k), A2 = { dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], tokens: { SKIP: /^[ \r\n\t]+|^\.$/, number: /^[1-9][0-9]*/, numberAsText: /^(one|two|three)/i, every: /^every/i, "day(s)": /^days?/i, "weekday(s)": /^weekdays?/i, "week(s)": /^weeks?/i, "hour(s)": /^hours?/i, "minute(s)": /^minutes?/i, "month(s)": /^months?/i, "year(s)": /^years?/i, on: /^(on|in)/i, at: /^(at)/i, the: /^the/i, first: /^first/i, second: /^second/i, third: /^third/i, nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i, last: /^last/i, for: /^for/i, "time(s)": /^times?/i, until: /^(un)?til/i, monday: /^mo(n(day)?)?/i, tuesday: /^tu(e(s(day)?)?)?/i, wednesday: /^we(d(n(esday)?)?)?/i, thursday: /^th(u(r(sday)?)?)?/i, friday: /^fr(i(day)?)?/i, saturday: /^sa(t(urday)?)?/i, sunday: /^su(n(day)?)?/i, january: /^jan(uary)?/i, february: /^feb(ruary)?/i, march: /^mar(ch)?/i, april: /^apr(il)?/i, may: /^may/i, june: /^june?/i, july: /^july?/i, august: /^aug(ust)?/i, september: /^sep(t(ember)?)?/i, october: /^oct(ober)?/i, november: /^nov(ember)?/i, december: /^dec(ember)?/i, comma: /^(,\s*|(and|or)\s*)+/i } };
        function N(t3, e3, n3, r4) {
          if (e3 === void 0 && (e3 = T), n3 === void 0 && (n3 = A2), r4 === void 0 && (r4 = O), this.text = [], this.language = n3 || A2, this.gettext = e3, this.dateFormatter = r4, this.rrule = t3, this.options = t3.options, this.origOptions = t3.origOptions, this.origOptions.bymonthday) {
            var i4 = [].concat(this.options.bymonthday), a2 = [].concat(this.options.bynmonthday);
            i4.sort(function(t4, e4) {
              return t4 - e4;
            }), a2.sort(function(t4, e4) {
              return e4 - t4;
            }), this.bymonthday = i4.concat(a2), this.bymonthday.length || (this.bymonthday = null);
          }
          if (D(this.origOptions.byweekday)) {
            var o2 = b(this.origOptions.byweekday) ? this.origOptions.byweekday : [this.origOptions.byweekday], s4 = String(o2);
            this.byweekday = { allWeeks: o2.filter(function(t4) {
              return !t4.n;
            }), someWeeks: o2.filter(function(t4) {
              return Boolean(t4.n);
            }), isWeekdays: s4.indexOf("MO") !== -1 && s4.indexOf("TU") !== -1 && s4.indexOf("WE") !== -1 && s4.indexOf("TH") !== -1 && s4.indexOf("FR") !== -1 && s4.indexOf("SA") === -1 && s4.indexOf("SU") === -1, isEveryDay: s4.indexOf("MO") !== -1 && s4.indexOf("TU") !== -1 && s4.indexOf("WE") !== -1 && s4.indexOf("TH") !== -1 && s4.indexOf("FR") !== -1 && s4.indexOf("SA") !== -1 && s4.indexOf("SU") !== -1 };
            var u2 = function(t4, e4) {
              return t4.weekday - e4.weekday;
            };
            this.byweekday.allWeeks.sort(u2), this.byweekday.someWeeks.sort(u2), this.byweekday.allWeeks.length || (this.byweekday.allWeeks = null), this.byweekday.someWeeks.length || (this.byweekday.someWeeks = null);
          } else
            this.byweekday = null;
        }
        var C, I, W = (N.isFullyConvertible = function(t3) {
          if (!(t3.options.freq in N.IMPLEMENTED))
            return false;
          if (t3.origOptions.until && t3.origOptions.count)
            return false;
          for (var e3 in t3.origOptions) {
            if (E(["dtstart", "wkst", "freq"], e3))
              return true;
            if (!E(N.IMPLEMENTED[t3.options.freq], e3))
              return false;
          }
          return true;
        }, N.prototype.isFullyConvertible = function() {
          return N.isFullyConvertible(this.rrule);
        }, N.prototype.toString = function() {
          var t3 = this.gettext;
          if (!(this.options.freq in N.IMPLEMENTED))
            return t3("RRule error: Unable to fully convert this rrule to text");
          if (this.text = [t3("every")], this[jt.FREQUENCIES[this.options.freq]](), this.options.until) {
            this.add(t3("until"));
            var e3 = this.options.until;
            this.add(this.dateFormatter(e3.getUTCFullYear(), this.language.monthNames[e3.getUTCMonth()], e3.getUTCDate()));
          } else
            this.options.count && this.add(t3("for")).add(this.options.count.toString()).add(this.plural(this.options.count) ? t3("times") : t3("time"));
          return this.isFullyConvertible() || this.add(t3("(~ approximate)")), this.text.join("");
        }, N.prototype.HOURLY = function() {
          var t3 = this.gettext;
          this.options.interval !== 1 && this.add(this.options.interval.toString()), this.add(this.plural(this.options.interval) ? t3("hours") : t3("hour"));
        }, N.prototype.MINUTELY = function() {
          var t3 = this.gettext;
          this.options.interval !== 1 && this.add(this.options.interval.toString()), this.add(this.plural(this.options.interval) ? t3("minutes") : t3("minute"));
        }, N.prototype.DAILY = function() {
          var t3 = this.gettext;
          this.options.interval !== 1 && this.add(this.options.interval.toString()), this.byweekday && this.byweekday.isWeekdays ? this.add(this.plural(this.options.interval) ? t3("weekdays") : t3("weekday")) : this.add(this.plural(this.options.interval) ? t3("days") : t3("day")), this.origOptions.bymonth && (this.add(t3("in")), this._bymonth()), this.bymonthday ? this._bymonthday() : this.byweekday ? this._byweekday() : this.origOptions.byhour && this._byhour();
        }, N.prototype.WEEKLY = function() {
          var t3 = this.gettext;
          this.options.interval !== 1 && this.add(this.options.interval.toString()).add(this.plural(this.options.interval) ? t3("weeks") : t3("week")), this.byweekday && this.byweekday.isWeekdays ? this.options.interval === 1 ? this.add(this.plural(this.options.interval) ? t3("weekdays") : t3("weekday")) : this.add(t3("on")).add(t3("weekdays")) : this.byweekday && this.byweekday.isEveryDay ? this.add(this.plural(this.options.interval) ? t3("days") : t3("day")) : (this.options.interval === 1 && this.add(t3("week")), this.origOptions.bymonth && (this.add(t3("in")), this._bymonth()), this.bymonthday ? this._bymonthday() : this.byweekday && this._byweekday());
        }, N.prototype.MONTHLY = function() {
          var t3 = this.gettext;
          this.origOptions.bymonth ? (this.options.interval !== 1 && (this.add(this.options.interval.toString()).add(t3("months")), this.plural(this.options.interval) && this.add(t3("in"))), this._bymonth()) : (this.options.interval !== 1 && this.add(this.options.interval.toString()), this.add(this.plural(this.options.interval) ? t3("months") : t3("month"))), this.bymonthday ? this._bymonthday() : this.byweekday && this.byweekday.isWeekdays ? this.add(t3("on")).add(t3("weekdays")) : this.byweekday && this._byweekday();
        }, N.prototype.YEARLY = function() {
          var t3 = this.gettext;
          this.origOptions.bymonth ? (this.options.interval !== 1 && (this.add(this.options.interval.toString()), this.add(t3("years"))), this._bymonth()) : (this.options.interval !== 1 && this.add(this.options.interval.toString()), this.add(this.plural(this.options.interval) ? t3("years") : t3("year"))), this.bymonthday ? this._bymonthday() : this.byweekday && this._byweekday(), this.options.byyearday && this.add(t3("on the")).add(this.list(this.options.byyearday, this.nth, t3("and"))).add(t3("day")), this.options.byweekno && this.add(t3("in")).add(this.plural(this.options.byweekno.length) ? t3("weeks") : t3("week")).add(this.list(this.options.byweekno, void 0, t3("and")));
        }, N.prototype._bymonthday = function() {
          var t3 = this.gettext;
          this.byweekday && this.byweekday.allWeeks ? this.add(t3("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext, t3("or"))).add(t3("the")).add(this.list(this.bymonthday, this.nth, t3("or"))) : this.add(t3("on the")).add(this.list(this.bymonthday, this.nth, t3("and")));
        }, N.prototype._byweekday = function() {
          var t3 = this.gettext;
          this.byweekday.allWeeks && !this.byweekday.isWeekdays && this.add(t3("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext)), this.byweekday.someWeeks && (this.byweekday.allWeeks && this.add(t3("and")), this.add(t3("on the")).add(this.list(this.byweekday.someWeeks, this.weekdaytext, t3("and"))));
        }, N.prototype._byhour = function() {
          var t3 = this.gettext;
          this.add(t3("at")).add(this.list(this.origOptions.byhour, void 0, t3("and")));
        }, N.prototype._bymonth = function() {
          this.add(this.list(this.options.bymonth, this.monthtext, this.gettext("and")));
        }, N.prototype.nth = function(t3) {
          var e3, n3;
          t3 = parseInt(t3.toString(), 10);
          var r4 = this.gettext;
          if (t3 === -1)
            return r4("last");
          switch (n3 = Math.abs(t3)) {
            case 1:
            case 21:
            case 31:
              e3 = n3 + r4("st");
              break;
            case 2:
            case 22:
              e3 = n3 + r4("nd");
              break;
            case 3:
            case 23:
              e3 = n3 + r4("rd");
              break;
            default:
              e3 = n3 + r4("th");
          }
          return t3 < 0 ? e3 + " " + r4("last") : e3;
        }, N.prototype.monthtext = function(t3) {
          return this.language.monthNames[t3 - 1];
        }, N.prototype.weekdaytext = function(t3) {
          var e3 = p(t3) ? (t3 + 1) % 7 : t3.getJsWeekday();
          return (t3.n ? this.nth(t3.n) + " " : "") + this.language.dayNames[e3];
        }, N.prototype.plural = function(t3) {
          return t3 % 100 != 1;
        }, N.prototype.add = function(t3) {
          return this.text.push(" "), this.text.push(t3), this;
        }, N.prototype.list = function(t3, e3, n3, r4) {
          function i4(t4) {
            return e3 && e3.call(a2, t4);
          }
          r4 === void 0 && (r4 = ","), b(t3) || (t3 = [t3]), e3 = e3 || function(t4) {
            return t4.toString();
          };
          var a2 = this;
          return n3 ? function(t4, e4, n4) {
            for (var r5 = "", i5 = 0; i5 < t4.length; i5++)
              i5 !== 0 && (i5 === t4.length - 1 ? r5 += " " + n4 + " " : r5 += e4 + " "), r5 += t4[i5];
            return r5;
          }(t3.map(i4), r4, n3) : t3.map(i4).join(r4 + " ");
        }, N), j = (H.prototype.start = function(t3) {
          return this.text = t3, this.done = false, this.nextSymbol();
        }, H.prototype.isDone = function() {
          return this.done && this.symbol === null;
        }, H.prototype.nextSymbol = function() {
          var t3, e3;
          this.symbol = null, this.value = null;
          do {
            if (this.done)
              return false;
            for (var n3 in t3 = null, this.rules) {
              var r4 = this.rules[n3].exec(this.text);
              r4 && (t3 === null || r4[0].length > t3[0].length) && (t3 = r4, e3 = n3);
            }
            if (t3 != null && (this.text = this.text.substr(t3[0].length), this.text === "" && (this.done = true)), t3 == null)
              return this.done = true, this.symbol = null, void (this.value = null);
          } while (e3 === "SKIP");
          return this.symbol = e3, this.value = t3, true;
        }, H.prototype.accept = function(t3) {
          if (this.symbol !== t3)
            return false;
          if (this.value) {
            var e3 = this.value;
            return this.nextSymbol(), e3;
          }
          return this.nextSymbol(), true;
        }, H.prototype.acceptNumber = function() {
          return this.accept("number");
        }, H.prototype.expect = function(t3) {
          if (this.accept(t3))
            return true;
          throw new Error("expected " + t3 + " but found " + this.symbol);
        }, H);
        function H(t3) {
          this.done = true, this.rules = t3;
        }
        function q(t3, e3) {
          e3 === void 0 && (e3 = A2);
          var o2 = {}, s4 = new j(e3.tokens);
          return s4.start(t3) ? (function() {
            s4.expect("every");
            var t4 = s4.acceptNumber();
            t4 && (o2.interval = parseInt(t4[0], 10));
            if (s4.isDone())
              throw new Error("Unexpected end");
            switch (s4.symbol) {
              case "day(s)":
                o2.freq = jt.DAILY, s4.nextSymbol() && (function() {
                  if (!s4.accept("at"))
                    return;
                  do {
                    var t5 = s4.acceptNumber();
                    if (!t5)
                      throw new Error("Unexpected symbol " + s4.symbol + ", expected hour");
                    for (o2.byhour = [parseInt(t5[0], 10)]; s4.accept("comma"); ) {
                      if (!(t5 = s4.acceptNumber()))
                        throw new Error("Unexpected symbol " + s4.symbol + "; expected hour");
                      o2.byhour.push(parseInt(t5[0], 10));
                    }
                  } while (s4.accept("comma") || s4.accept("at"));
                }(), a2());
                break;
              case "weekday(s)":
                o2.freq = jt.WEEKLY, o2.byweekday = [jt.MO, jt.TU, jt.WE, jt.TH, jt.FR], s4.nextSymbol(), a2();
                break;
              case "week(s)":
                o2.freq = jt.WEEKLY, s4.nextSymbol() && (i4(), a2());
                break;
              case "hour(s)":
                o2.freq = jt.HOURLY, s4.nextSymbol() && (i4(), a2());
                break;
              case "minute(s)":
                o2.freq = jt.MINUTELY, s4.nextSymbol() && (i4(), a2());
                break;
              case "month(s)":
                o2.freq = jt.MONTHLY, s4.nextSymbol() && (i4(), a2());
                break;
              case "year(s)":
                o2.freq = jt.YEARLY, s4.nextSymbol() && (i4(), a2());
                break;
              case "monday":
              case "tuesday":
              case "wednesday":
              case "thursday":
              case "friday":
              case "saturday":
              case "sunday":
                o2.freq = jt.WEEKLY;
                var e4 = s4.symbol.substr(0, 2).toUpperCase();
                if (o2.byweekday = [jt[e4]], !s4.nextSymbol())
                  return;
                for (; s4.accept("comma"); ) {
                  if (s4.isDone())
                    throw new Error("Unexpected end");
                  var n3 = h3();
                  if (!n3)
                    throw new Error("Unexpected symbol " + s4.symbol + ", expected weekday");
                  o2.byweekday.push(jt[n3]), s4.nextSymbol();
                }
                !function() {
                  s4.accept("on"), s4.accept("the");
                  var t5 = y2();
                  if (!t5)
                    return;
                  o2.bymonthday = [t5], s4.nextSymbol();
                  for (; s4.accept("comma"); ) {
                    if (!(t5 = y2()))
                      throw new Error("Unexpected symbol " + s4.symbol + "; expected monthday");
                    o2.bymonthday.push(t5), s4.nextSymbol();
                  }
                }(), a2();
                break;
              case "january":
              case "february":
              case "march":
              case "april":
              case "may":
              case "june":
              case "july":
              case "august":
              case "september":
              case "october":
              case "november":
              case "december":
                if (o2.freq = jt.YEARLY, o2.bymonth = [u2()], !s4.nextSymbol())
                  return;
                for (; s4.accept("comma"); ) {
                  if (s4.isDone())
                    throw new Error("Unexpected end");
                  var r4 = u2();
                  if (!r4)
                    throw new Error("Unexpected symbol " + s4.symbol + ", expected month");
                  o2.bymonth.push(r4), s4.nextSymbol();
                }
                i4(), a2();
                break;
              default:
                throw new Error("Unknown symbol");
            }
          }(), o2) : null;
          function i4() {
            var t4 = s4.accept("on"), e4 = s4.accept("the");
            if (t4 || e4)
              do {
                var n3 = y2(), r4 = h3(), i5 = u2();
                if (n3)
                  r4 ? (s4.nextSymbol(), o2.byweekday || (o2.byweekday = []), o2.byweekday.push(jt[r4].nth(n3))) : (o2.bymonthday || (o2.bymonthday = []), o2.bymonthday.push(n3), s4.accept("day(s)"));
                else if (r4)
                  s4.nextSymbol(), o2.byweekday || (o2.byweekday = []), o2.byweekday.push(jt[r4]);
                else if (s4.symbol === "weekday(s)")
                  s4.nextSymbol(), o2.byweekday || (o2.byweekday = [jt.MO, jt.TU, jt.WE, jt.TH, jt.FR]);
                else if (s4.symbol === "week(s)") {
                  s4.nextSymbol();
                  var a3 = s4.acceptNumber();
                  if (!a3)
                    throw new Error("Unexpected symbol " + s4.symbol + ", expected week number");
                  for (o2.byweekno = [parseInt(a3[0], 10)]; s4.accept("comma"); ) {
                    if (!(a3 = s4.acceptNumber()))
                      throw new Error("Unexpected symbol " + s4.symbol + "; expected monthday");
                    o2.byweekno.push(parseInt(a3[0], 10));
                  }
                } else {
                  if (!i5)
                    return;
                  s4.nextSymbol(), o2.bymonth || (o2.bymonth = []), o2.bymonth.push(i5);
                }
              } while (s4.accept("comma") || s4.accept("the") || s4.accept("on"));
          }
          function u2() {
            switch (s4.symbol) {
              case "january":
                return 1;
              case "february":
                return 2;
              case "march":
                return 3;
              case "april":
                return 4;
              case "may":
                return 5;
              case "june":
                return 6;
              case "july":
                return 7;
              case "august":
                return 8;
              case "september":
                return 9;
              case "october":
                return 10;
              case "november":
                return 11;
              case "december":
                return 12;
              default:
                return false;
            }
          }
          function h3() {
            switch (s4.symbol) {
              case "monday":
              case "tuesday":
              case "wednesday":
              case "thursday":
              case "friday":
              case "saturday":
              case "sunday":
                return s4.symbol.substr(0, 2).toUpperCase();
              default:
                return false;
            }
          }
          function y2() {
            switch (s4.symbol) {
              case "last":
                return s4.nextSymbol(), -1;
              case "first":
                return s4.nextSymbol(), 1;
              case "second":
                return s4.nextSymbol(), s4.accept("last") ? -2 : 2;
              case "third":
                return s4.nextSymbol(), s4.accept("last") ? -3 : 3;
              case "nth":
                var t4 = parseInt(s4.value[1], 10);
                if (t4 < -366 || 366 < t4)
                  throw new Error("Nth out of range: " + t4);
                return s4.nextSymbol(), s4.accept("last") ? -t4 : t4;
              default:
                return false;
            }
          }
          function a2() {
            if (s4.symbol === "until") {
              var t4 = Date.parse(s4.text);
              if (!t4)
                throw new Error("Cannot parse until date:" + s4.text);
              o2.until = new Date(t4);
            } else
              s4.accept("for") && (o2.count = parseInt(s4.value[0], 10), s4.expect("number"));
          }
        }
        function P(t3) {
          return t3 < C.HOURLY;
        }
        (I = C = C || {})[I.YEARLY = 0] = "YEARLY", I[I.MONTHLY = 1] = "MONTHLY", I[I.WEEKLY = 2] = "WEEKLY", I[I.DAILY = 3] = "DAILY", I[I.HOURLY = 4] = "HOURLY", I[I.MINUTELY = 5] = "MINUTELY", I[I.SECONDLY = 6] = "SECONDLY";
        var z = ["count", "until", "interval", "byweekday", "bymonthday", "bymonth"];
        W.IMPLEMENTED = [], W.IMPLEMENTED[C.HOURLY] = z, W.IMPLEMENTED[C.MINUTELY] = z, W.IMPLEMENTED[C.DAILY] = ["byhour"].concat(z), W.IMPLEMENTED[C.WEEKLY] = z, W.IMPLEMENTED[C.MONTHLY] = z, W.IMPLEMENTED[C.YEARLY] = ["byweekno", "byyearday"].concat(z);
        var F2 = W.isFullyConvertible, K = (B.prototype.getHours = function() {
          return this.hour;
        }, B.prototype.getMinutes = function() {
          return this.minute;
        }, B.prototype.getSeconds = function() {
          return this.second;
        }, B.prototype.getMilliseconds = function() {
          return this.millisecond;
        }, B.prototype.getTime = function() {
          return 1e3 * (60 * this.hour * 60 + 60 * this.minute + this.second) + this.millisecond;
        }, B);
        function B(t3, e3, n3, r4) {
          this.hour = t3, this.minute = e3, this.second = n3, this.millisecond = r4 || 0;
        }
        var Z2, V = (w(X, Z2 = K), X.fromDate = function(t3) {
          return new this(t3.getUTCFullYear(), t3.getUTCMonth() + 1, t3.getUTCDate(), t3.getUTCHours(), t3.getUTCMinutes(), t3.getUTCSeconds(), t3.valueOf() % 1e3);
        }, X.prototype.getWeekday = function() {
          return s3.getWeekday(new Date(this.getTime()));
        }, X.prototype.getTime = function() {
          return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)).getTime();
        }, X.prototype.getDay = function() {
          return this.day;
        }, X.prototype.getMonth = function() {
          return this.month;
        }, X.prototype.getYear = function() {
          return this.year;
        }, X.prototype.addYears = function(t3) {
          this.year += t3;
        }, X.prototype.addMonths = function(t3) {
          if (this.month += t3, 12 < this.month) {
            var e3 = Math.floor(this.month / 12), n3 = U(this.month, 12);
            this.month = n3, this.year += e3, this.month === 0 && (this.month = 12, --this.year);
          }
        }, X.prototype.addWeekly = function(t3, e3) {
          e3 > this.getWeekday() ? this.day += -(this.getWeekday() + 1 + (6 - e3)) + 7 * t3 : this.day += -(this.getWeekday() - e3) + 7 * t3, this.fixDay();
        }, X.prototype.addDaily = function(t3) {
          this.day += t3, this.fixDay();
        }, X.prototype.addHours = function(t3, e3, n3) {
          for (e3 && (this.hour += Math.floor((23 - this.hour) / t3) * t3); ; ) {
            this.hour += t3;
            var r4 = u(this.hour, 24), i4 = r4.div, a2 = r4.mod;
            if (i4 && (this.hour = a2, this.addDaily(i4)), S2(n3) || L(n3, this.hour))
              break;
          }
        }, X.prototype.addMinutes = function(t3, e3, n3, r4) {
          for (e3 && (this.minute += Math.floor((1439 - (60 * this.hour + this.minute)) / t3) * t3); ; ) {
            this.minute += t3;
            var i4 = u(this.minute, 60), a2 = i4.div, o2 = i4.mod;
            if (a2 && (this.minute = o2, this.addHours(a2, false, n3)), (S2(n3) || L(n3, this.hour)) && (S2(r4) || L(r4, this.minute)))
              break;
          }
        }, X.prototype.addSeconds = function(t3, e3, n3, r4, i4) {
          for (e3 && (this.second += Math.floor((86399 - (3600 * this.hour + 60 * this.minute + this.second)) / t3) * t3); ; ) {
            this.second += t3;
            var a2 = u(this.second, 60), o2 = a2.div, s4 = a2.mod;
            if (o2 && (this.second = s4, this.addMinutes(o2, false, n3, r4)), (S2(n3) || L(n3, this.hour)) && (S2(r4) || L(r4, this.minute)) && (S2(i4) || L(i4, this.second)))
              break;
          }
        }, X.prototype.fixDay = function() {
          if (!(this.day <= 28)) {
            var t3 = s3.monthRange(this.year, this.month - 1)[1];
            if (!(this.day <= t3))
              for (; this.day > t3; ) {
                if (this.day -= t3, ++this.month, this.month === 13 && (this.month = 1, ++this.year, this.year > s3.MAXYEAR))
                  return;
                t3 = s3.monthRange(this.year, this.month - 1)[1];
              }
          }
        }, X.prototype.add = function(t3, e3) {
          var n3 = t3.freq, r4 = t3.interval, i4 = t3.wkst, a2 = t3.byhour, o2 = t3.byminute, s4 = t3.bysecond;
          switch (n3) {
            case C.YEARLY:
              return this.addYears(r4);
            case C.MONTHLY:
              return this.addMonths(r4);
            case C.WEEKLY:
              return this.addWeekly(r4, i4);
            case C.DAILY:
              return this.addDaily(r4);
            case C.HOURLY:
              return this.addHours(r4, e3, a2);
            case C.MINUTELY:
              return this.addMinutes(r4, e3, a2, o2);
            case C.SECONDLY:
              return this.addSeconds(r4, e3, a2, o2, s4);
          }
        }, X);
        function X(t3, e3, n3, r4, i4, a2, o2) {
          var s4 = Z2.call(this, r4, i4, a2, o2) || this;
          return s4.year = t3, s4.month = e3, s4.day = n3, s4;
        }
        function G(t3) {
          for (var e3 = [], n3 = 0, r4 = Object.keys(t3); n3 < r4.length; n3++) {
            var i4 = r4[n3];
            L(It, i4) || e3.push(i4), M.isDate(t3[i4]) && !M.isValidDate(t3[i4]) && e3.push(i4);
          }
          if (e3.length)
            throw new Error("Invalid options: " + e3.join(", "));
          return _({}, t3);
        }
        function J(t3) {
          var e3 = t3.split("\n").map($).filter(function(t4) {
            return t4 !== null;
          });
          return _(_({}, e3[0]), e3[1]);
        }
        function Q(t3) {
          var e3 = {}, n3 = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(t3);
          if (!n3)
            return e3;
          n3[0];
          var r4 = n3[1], i4 = n3[2];
          return r4 && (e3.tzid = r4), e3.dtstart = M.untilStringToDate(i4), e3;
        }
        function $(t3) {
          if (!(t3 = t3.replace(/^\s+|\s+$/, "")).length)
            return null;
          var e3 = /^([A-Z]+?)[:;]/.exec(t3.toUpperCase());
          if (!e3)
            return tt(t3);
          e3[0];
          var n3 = e3[1];
          switch (n3.toUpperCase()) {
            case "RRULE":
            case "EXRULE":
              return tt(t3);
            case "DTSTART":
              return Q(t3);
            default:
              throw new Error("Unsupported RFC prop " + n3 + " in " + t3);
          }
        }
        function tt(u2) {
          var h3 = Q(u2.replace(/^RRULE:/i, ""));
          return u2.replace(/^(?:RRULE|EXRULE):/i, "").split(";").forEach(function(t3) {
            var e3, n3 = t3.split("="), r4 = n3[0], i4 = n3[1];
            switch (r4.toUpperCase()) {
              case "FREQ":
                h3.freq = C[i4.toUpperCase()];
                break;
              case "WKST":
                h3.wkst = Nt[i4.toUpperCase()];
                break;
              case "COUNT":
              case "INTERVAL":
              case "BYSETPOS":
              case "BYMONTH":
              case "BYMONTHDAY":
              case "BYYEARDAY":
              case "BYWEEKNO":
              case "BYHOUR":
              case "BYMINUTE":
              case "BYSECOND":
                var a2 = (e3 = i4).indexOf(",") === -1 ? et(e3) : e3.split(",").map(et), o2 = r4.toLowerCase();
                h3[o2] = a2;
                break;
              case "BYWEEKDAY":
              case "BYDAY":
                h3.byweekday = i4.split(",").map(function(t4) {
                  if (t4.length === 2)
                    return Nt[t4];
                  var e4 = t4.match(/^([+-]?\d{1,2})([A-Z]{2})$/), n4 = Number(e4[1]), r5 = e4[2], i5 = Nt[r5].weekday;
                  return new f3(i5, n4);
                });
                break;
              case "DTSTART":
              case "TZID":
                var s4 = Q(u2);
                h3.tzid = s4.tzid, h3.dtstart = s4.dtstart;
                break;
              case "UNTIL":
                h3.until = M.untilStringToDate(i4);
                break;
              case "BYEASTER":
                h3.byeaster = Number(i4);
                break;
              default:
                throw new Error("Unknown RRULE property '" + r4 + "'");
            }
          }), h3;
        }
        function et(t3) {
          return /^[+-]?\d+$/.test(t3) ? Number(t3) : t3;
        }
        var nt = function() {
          throw new TypeError();
        }, rt = (Object.defineProperty(it.prototype, "isUTC", { get: function() {
          return !this.tzid || this.tzid.toUpperCase() === "UTC";
        }, enumerable: true, configurable: true }), it.prototype.toString = function() {
          var t3 = M.timeToUntilString(this.date.getTime(), this.isUTC);
          return this.isUTC ? ":" + t3 : ";TZID=" + this.tzid + ":" + t3;
        }, it.prototype.getTime = function() {
          return this.date.getTime();
        }, it.prototype.rezonedDate = function() {
          if (this.isUTC)
            return this.date;
          try {
            return nt(this.date).setZone(this.tzid, { keepLocalTime: true }).toJSDate();
          } catch (t3) {
            return t3 instanceof TypeError && console.error("Using TZID without Luxon available is unsupported. Returned times are in UTC, not the requested time zone"), this.date;
          }
        }, it);
        function it(t3, e3) {
          this.date = t3, this.tzid = e3;
        }
        function at(t3) {
          for (var e3, n3 = [], r4 = "", i4 = Object.keys(t3), a2 = Object.keys(Ct), o2 = 0; o2 < i4.length; o2++)
            if (i4[o2] !== "tzid" && L(a2, i4[o2])) {
              var s4 = i4[o2].toUpperCase(), u2 = t3[i4[o2]], h3 = "";
              if (D(u2) && (!b(u2) || u2.length)) {
                switch (s4) {
                  case "FREQ":
                    h3 = jt.FREQUENCIES[t3.freq];
                    break;
                  case "WKST":
                    h3 = p(u2) ? new f3(u2).toString() : u2.toString();
                    break;
                  case "BYWEEKDAY":
                    s4 = "BYDAY", h3 = (b(e3 = u2) ? e3 : [e3]).map(function(t4) {
                      return t4 instanceof f3 ? t4 : b(t4) ? new f3(t4[0], t4[1]) : new f3(t4);
                    }).toString();
                    break;
                  case "DTSTART":
                    r4 = ot(u2, t3.tzid);
                    break;
                  case "UNTIL":
                    h3 = M.timeToUntilString(u2, !t3.tzid);
                    break;
                  default:
                    if (b(u2)) {
                      for (var y2 = [], d2 = 0; d2 < u2.length; d2++)
                        y2[d2] = String(u2[d2]);
                      h3 = y2.toString();
                    } else
                      h3 = String(u2);
                }
                h3 && n3.push([s4, h3]);
              }
            }
          var c2 = n3.map(function(t4) {
            return t4[0] + "=" + t4[1].toString();
          }).join(";"), l2 = "";
          return c2 !== "" && (l2 = "RRULE:" + c2), [r4, l2].filter(function(t4) {
            return !!t4;
          }).join("\n");
        }
        function ot(t3, e3) {
          return t3 ? "DTSTART" + new rt(new Date(t3), e3).toString() : "";
        }
        function st(t3, n3) {
          return Array.isArray(t3) ? !!Array.isArray(n3) && (t3.length === n3.length && t3.every(function(t4, e3) {
            return t4.getTime() === n3[e3].getTime();
          })) : t3 instanceof Date ? n3 instanceof Date && t3.getTime() === n3.getTime() : t3 === n3;
        }
        var ut = (ht.prototype._cacheAdd = function(t3, e3, n3) {
          e3 = e3 && (e3 instanceof Date ? M.clone(e3) : M.cloneDates(e3)), t3 === "all" ? this.all = e3 : (n3._value = e3, this[t3].push(n3));
        }, ht.prototype._cacheGet = function(t3, r4) {
          function e3(t4) {
            for (var e4 = 0; e4 < i4.length; e4++) {
              var n4 = i4[e4];
              if (!st(r4[n4], t4[n4]))
                return true;
            }
            return false;
          }
          var n3 = false, i4 = r4 ? Object.keys(r4) : [], a2 = this[t3];
          if (t3 === "all")
            n3 = this.all;
          else if (b(a2))
            for (var o2 = 0; o2 < a2.length; o2++) {
              var s4 = a2[o2];
              if (!i4.length || !e3(s4)) {
                n3 = s4._value;
                break;
              }
            }
          if (!n3 && this.all) {
            var u2 = new l(t3, r4);
            for (o2 = 0; o2 < this.all.length && u2.accept(this.all[o2]); o2++)
              ;
            n3 = u2.getValue(), this._cacheAdd(t3, n3, r4);
          }
          return b(n3) ? M.cloneDates(n3) : n3 instanceof Date ? M.clone(n3) : n3;
        }, ht);
        function ht() {
          this.all = false, this.before = [], this.after = [], this.between = [];
        }
        var yt = g(Y(1, 31), Y(2, 28), Y(3, 31), Y(4, 30), Y(5, 31), Y(6, 30), Y(7, 31), Y(8, 31), Y(9, 30), Y(10, 31), Y(11, 30), Y(12, 31), Y(1, 7)), dt = g(Y(1, 31), Y(2, 29), Y(3, 31), Y(4, 30), Y(5, 31), Y(6, 30), Y(7, 31), Y(8, 31), Y(9, 30), Y(10, 31), Y(11, 30), Y(12, 31), Y(1, 7)), ct = a(1, 29), lt = a(1, 30), ft = a(1, 31), pt = a(1, 32), bt = g(pt, lt, pt, ft, pt, ft, pt, pt, ft, pt, ft, pt, pt.slice(0, 7)), mt = g(pt, ct, pt, ft, pt, ft, pt, pt, ft, pt, ft, pt, pt.slice(0, 7)), wt = a(-28, 0), vt = a(-29, 0), gt2 = a(-30, 0), kt = a(-31, 0), Et = g(kt, vt, kt, gt2, kt, gt2, kt, kt, gt2, kt, gt2, kt, kt.slice(0, 7)), Tt = g(kt, wt, kt, gt2, kt, gt2, kt, kt, gt2, kt, gt2, kt, kt.slice(0, 7)), Dt = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366], xt = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365], Ot = function() {
          for (var t3 = [], e3 = 0; e3 < 55; e3++)
            t3 = t3.concat(a(7));
          return t3;
        }();
        function Yt(t3, e3) {
          var n3, r4, i4, a2, o2, s4, u2 = new Date(Date.UTC(t3, 0, 1)), h3 = M.isLeapYear(t3) ? 366 : 365, y2 = M.isLeapYear(t3 + 1) ? 366 : 365, d2 = M.toOrdinal(u2), c2 = M.getWeekday(u2), l2 = _(_({ yearlen: h3, nextyearlen: y2, yearordinal: d2, yearweekday: c2 }, (n3 = t3, r4 = M.isLeapYear(n3) ? 366 : 365, i4 = new Date(Date.UTC(n3, 0, 1)), a2 = M.getWeekday(i4), r4 != 365 ? { mmask: dt, mdaymask: bt, nmdaymask: Et, wdaymask: Ot.slice(a2), mrange: Dt } : { mmask: yt, mdaymask: mt, nmdaymask: Tt, wdaymask: Ot.slice(a2), mrange: xt })), { wnomask: null });
          if (S2(e3.byweekno))
            return l2;
          l2.wnomask = Y(0, 7 + h3);
          var f4 = o2 = U(7 - c2 + e3.wkst, 7);
          s4 = 4 <= f4 ? (f4 = 0, l2.yearlen + U(c2 - e3.wkst, 7)) : h3 - f4;
          for (var p2 = Math.floor(s4 / 7), b2 = U(s4, 7), m3 = Math.floor(p2 + b2 / 4), w2 = 0; w2 < e3.byweekno.length; w2++) {
            var v2 = e3.byweekno[w2];
            if (v2 < 0 && (v2 += m3 + 1), 0 < v2 && v2 <= m3) {
              var g2 = void 0;
              1 < v2 ? (g2 = f4 + 7 * (v2 - 1), f4 !== o2 && (g2 -= 7 - o2)) : g2 = f4;
              for (var k2 = 0; k2 < 7 && (l2.wnomask[g2] = 1, g2++, l2.wdaymask[g2] !== e3.wkst); k2++)
                ;
            }
          }
          if (L(e3.byweekno, 1)) {
            g2 = f4 + 7 * m3;
            if (f4 !== o2 && (g2 -= 7 - o2), g2 < h3)
              for (w2 = 0; w2 < 7 && (g2 += l2.wnomask[g2] = 1, l2.wdaymask[g2] !== e3.wkst); w2++)
                ;
          }
          if (f4) {
            var E2 = void 0;
            if (L(e3.byweekno, -1))
              E2 = -1;
            else {
              var T2 = M.getWeekday(new Date(Date.UTC(t3 - 1, 0, 1))), D2 = U(7 - T2.valueOf() + e3.wkst, 7), x3 = M.isLeapYear(t3 - 1) ? 366 : 365, O2 = void 0;
              O2 = 4 <= D2 ? (D2 = 0, x3 + U(T2 - e3.wkst, 7)) : h3 - f4, E2 = Math.floor(52 + U(O2, 7) / 4);
            }
            if (L(e3.byweekno, E2))
              for (g2 = 0; g2 < f4; g2++)
                l2.wnomask[g2] = 1;
          }
          return l2;
        }
        function St(t3) {
          this.options = t3;
        }
        var Ut = (St.prototype.rebuild = function(t3, e3) {
          var n3 = this.options;
          if (t3 !== this.lastyear && (this.yearinfo = Yt(t3, n3)), x2(n3.bynweekday) && (e3 !== this.lastmonth || t3 !== this.lastyear)) {
            var r4 = this.yearinfo, i4 = r4.yearlen, a2 = r4.mrange, o2 = r4.wdaymask;
            this.monthinfo = function(t4, e4, n4, r5, i5, a3) {
              var o3 = { lastyear: t4, lastmonth: e4, nwdaymask: [] }, s4 = [];
              if (a3.freq === jt.YEARLY)
                if (S2(a3.bymonth))
                  s4 = [[0, n4]];
                else
                  for (var u2 = 0; u2 < a3.bymonth.length; u2++)
                    e4 = a3.bymonth[u2], s4.push(r5.slice(e4 - 1, e4 + 1));
              else
                a3.freq === jt.MONTHLY && (s4 = [r5.slice(e4 - 1, e4 + 1)]);
              if (S2(s4))
                return o3;
              for (o3.nwdaymask = Y(0, n4), u2 = 0; u2 < s4.length; u2++)
                for (var h3 = s4[u2], y2 = h3[0], d2 = h3[1] - 1, c2 = 0; c2 < a3.bynweekday.length; c2++) {
                  var l2 = void 0, f4 = a3.bynweekday[c2], p2 = f4[0], b2 = f4[1];
                  b2 < 0 ? (l2 = d2 + 7 * (b2 + 1), l2 -= U(i5[l2] - p2, 7)) : (l2 = y2 + 7 * (b2 - 1), l2 += U(7 - i5[l2] + p2, 7)), y2 <= l2 && l2 <= d2 && (o3.nwdaymask[l2] = 1);
                }
              return o3;
            }(t3, e3, i4, a2, o2, n3);
          }
          D(n3.byeaster) && (this.eastermask = function(t4, e4) {
            e4 === void 0 && (e4 = 0);
            var n4 = t4 % 19, r5 = Math.floor(t4 / 100), i5 = t4 % 100, a3 = Math.floor(r5 / 4), o3 = r5 % 4, s4 = Math.floor((r5 + 8) / 25), u2 = Math.floor((r5 - s4 + 1) / 3), h3 = Math.floor(19 * n4 + r5 - a3 - u2 + 15) % 30, y2 = Math.floor(i5 / 4), d2 = i5 % 4, c2 = Math.floor(32 + 2 * o3 + 2 * y2 - h3 - d2) % 7, l2 = Math.floor((n4 + 11 * h3 + 22 * c2) / 451), f4 = Math.floor((h3 + c2 - 7 * l2 + 114) / 31), p2 = (h3 + c2 - 7 * l2 + 114) % 31 + 1, b2 = Date.UTC(t4, f4 - 1, p2 + e4), m3 = Date.UTC(t4, 0, 1);
            return [Math.ceil((b2 - m3) / 864e5)];
          }(t3, n3.byeaster));
        }, Object.defineProperty(St.prototype, "lastyear", { get: function() {
          return this.monthinfo ? this.monthinfo.lastyear : null;
        }, enumerable: true, configurable: true }), Object.defineProperty(St.prototype, "lastmonth", { get: function() {
          return this.monthinfo ? this.monthinfo.lastmonth : null;
        }, enumerable: true, configurable: true }), Object.defineProperty(St.prototype, "yearlen", { get: function() {
          return this.yearinfo.yearlen;
        }, enumerable: true, configurable: true }), Object.defineProperty(St.prototype, "yearordinal", { get: function() {
          return this.yearinfo.yearordinal;
        }, enumerable: true, configurable: true }), Object.defineProperty(St.prototype, "mrange", { get: function() {
          return this.yearinfo.mrange;
        }, enumerable: true, configurable: true }), Object.defineProperty(St.prototype, "wdaymask", { get: function() {
          return this.yearinfo.wdaymask;
        }, enumerable: true, configurable: true }), Object.defineProperty(St.prototype, "mmask", { get: function() {
          return this.yearinfo.mmask;
        }, enumerable: true, configurable: true }), Object.defineProperty(St.prototype, "wnomask", { get: function() {
          return this.yearinfo.wnomask;
        }, enumerable: true, configurable: true }), Object.defineProperty(St.prototype, "nwdaymask", { get: function() {
          return this.monthinfo ? this.monthinfo.nwdaymask : [];
        }, enumerable: true, configurable: true }), Object.defineProperty(St.prototype, "nextyearlen", { get: function() {
          return this.yearinfo.nextyearlen;
        }, enumerable: true, configurable: true }), Object.defineProperty(St.prototype, "mdaymask", { get: function() {
          return this.yearinfo.mdaymask;
        }, enumerable: true, configurable: true }), Object.defineProperty(St.prototype, "nmdaymask", { get: function() {
          return this.yearinfo.nmdaymask;
        }, enumerable: true, configurable: true }), St.prototype.ydayset = function() {
          return [a(this.yearlen), 0, this.yearlen];
        }, St.prototype.mdayset = function(t3, e3, n3) {
          for (var r4 = this.mrange[e3 - 1], i4 = this.mrange[e3], a2 = Y(null, this.yearlen), o2 = r4; o2 < i4; o2++)
            a2[o2] = o2;
          return [a2, r4, i4];
        }, St.prototype.wdayset = function(t3, e3, n3) {
          for (var r4 = Y(null, this.yearlen + 7), i4 = M.toOrdinal(new Date(Date.UTC(t3, e3 - 1, n3))) - this.yearordinal, a2 = i4, o2 = 0; o2 < 7 && (r4[i4] = i4, ++i4, this.wdaymask[i4] !== this.options.wkst); o2++)
            ;
          return [r4, a2, i4];
        }, St.prototype.ddayset = function(t3, e3, n3) {
          var r4 = Y(null, this.yearlen), i4 = M.toOrdinal(new Date(Date.UTC(t3, e3 - 1, n3))) - this.yearordinal;
          return r4[i4] = i4, [r4, i4, 1 + i4];
        }, St.prototype.htimeset = function(e3, t3, n3, r4) {
          var i4 = this, a2 = [];
          return this.options.byminute.forEach(function(t4) {
            a2 = a2.concat(i4.mtimeset(e3, t4, n3, r4));
          }), M.sort(a2), a2;
        }, St.prototype.mtimeset = function(e3, n3, t3, r4) {
          var i4 = this.options.bysecond.map(function(t4) {
            return new K(e3, n3, t4, r4);
          });
          return M.sort(i4), i4;
        }, St.prototype.stimeset = function(t3, e3, n3, r4) {
          return [new K(t3, e3, n3, r4)];
        }, St.prototype.getdayset = function(t3) {
          switch (t3) {
            case C.YEARLY:
              return this.ydayset.bind(this);
            case C.MONTHLY:
              return this.mdayset.bind(this);
            case C.WEEKLY:
              return this.wdayset.bind(this);
            case C.DAILY:
            default:
              return this.ddayset.bind(this);
          }
        }, St.prototype.gettimeset = function(t3) {
          switch (t3) {
            case C.HOURLY:
              return this.htimeset.bind(this);
            case C.MINUTELY:
              return this.mtimeset.bind(this);
            case C.SECONDLY:
              return this.stimeset.bind(this);
          }
        }, St);
        function Lt(t3, e3, n3, r4, i4, a2) {
          for (var o2 = [], s4 = 0; s4 < t3.length; s4++) {
            var u2 = void 0, h3 = void 0, y2 = t3[s4];
            h3 = y2 < 0 ? (u2 = Math.floor(y2 / e3.length), U(y2, e3.length)) : (u2 = Math.floor((y2 - 1) / e3.length), U(y2 - 1, e3.length));
            for (var d2 = [], c2 = n3; c2 < r4; c2++) {
              var l2 = a2[c2];
              D(l2) && d2.push(l2);
            }
            var f4 = void 0;
            f4 = u2 < 0 ? d2.slice(u2)[0] : d2[u2];
            var p2 = e3[h3], b2 = M.fromOrdinal(i4.yearordinal + f4), m3 = M.combine(b2, p2);
            L(o2, m3) || o2.push(m3);
          }
          return M.sort(o2), o2;
        }
        function Mt(t3, e3) {
          var n3 = e3.dtstart, r4 = e3.freq, i4 = e3.interval, a2 = e3.until, o2 = e3.bysetpos, s4 = e3.count;
          if (s4 === 0 || i4 === 0)
            return Rt(t3);
          var u2 = V.fromDate(n3), h3 = new Ut(e3);
          h3.rebuild(u2.year, u2.month);
          for (var y2 = function(t4, e4, n4) {
            var r5 = n4.freq, i5 = n4.byhour, a3 = n4.byminute, o3 = n4.bysecond;
            if (P(r5))
              return function(t5) {
                var r6 = t5.dtstart.getTime() % 1e3;
                if (!P(t5.freq))
                  return [];
                var i6 = [];
                return t5.byhour.forEach(function(n5) {
                  t5.byminute.forEach(function(e5) {
                    t5.bysecond.forEach(function(t6) {
                      i6.push(new K(n5, e5, t6, r6));
                    });
                  });
                }), i6;
              }(n4);
            if (r5 >= jt.HOURLY && x2(i5) && !L(i5, e4.hour) || r5 >= jt.MINUTELY && x2(a3) && !L(a3, e4.minute) || r5 >= jt.SECONDLY && x2(o3) && !L(o3, e4.second))
              return [];
            return t4.gettimeset(r5)(e4.hour, e4.minute, e4.second, e4.millisecond);
          }(h3, u2, e3); ; ) {
            var d2 = h3.getdayset(r4)(u2.year, u2.month, u2.day), c2 = d2[0], l2 = d2[1], f4 = d2[2], p2 = At(c2, l2, f4, h3, e3);
            if (x2(o2))
              for (var b2 = Lt(o2, y2, l2, f4, h3, c2), m3 = 0; m3 < b2.length; m3++) {
                var w2 = b2[m3];
                if (a2 && a2 < w2)
                  return Rt(t3);
                if (n3 <= w2) {
                  var v2 = _t(w2, e3);
                  if (!t3.accept(v2))
                    return Rt(t3);
                  if (s4 && !--s4)
                    return Rt(t3);
                }
              }
            else
              for (m3 = l2; m3 < f4; m3++) {
                var g2 = c2[m3];
                if (D(g2))
                  for (var k2 = M.fromOrdinal(h3.yearordinal + g2), E2 = 0; E2 < y2.length; E2++) {
                    var T2 = y2[E2];
                    w2 = M.combine(k2, T2);
                    if (a2 && a2 < w2)
                      return Rt(t3);
                    if (n3 <= w2) {
                      v2 = _t(w2, e3);
                      if (!t3.accept(v2))
                        return Rt(t3);
                      if (s4 && !--s4)
                        return Rt(t3);
                    }
                  }
              }
            if (e3.interval === 0)
              return Rt(t3);
            if (u2.add(e3, p2), u2.year > M.MAXYEAR)
              return Rt(t3);
            P(r4) || (y2 = h3.gettimeset(r4)(u2.hour, u2.minute, u2.second, 0)), h3.rebuild(u2.year, u2.month);
          }
        }
        function _t(t3, e3) {
          return new rt(t3, e3.tzid).rezonedDate();
        }
        function Rt(t3) {
          return t3.getValue();
        }
        function At(t3, e3, n3, r4, i4) {
          for (var a2, o2, s4, u2, h3, y2, d2, c2, l2, f4, p2 = false, b2 = e3; b2 < n3; b2++) {
            var m3 = t3[b2];
            a2 = r4, o2 = m3, void 0, u2 = (s4 = i4).bymonth, h3 = s4.byweekno, y2 = s4.byweekday, d2 = s4.byeaster, c2 = s4.bymonthday, l2 = s4.bynmonthday, f4 = s4.byyearday, (p2 = x2(u2) && !L(u2, a2.mmask[o2]) || x2(h3) && !a2.wnomask[o2] || x2(y2) && !L(y2, a2.wdaymask[o2]) || x2(a2.nwdaymask) && !a2.nwdaymask[o2] || d2 !== null && !L(a2.eastermask, o2) || (x2(c2) || x2(l2)) && !L(c2, a2.mdaymask[o2]) && !L(l2, a2.nmdaymask[o2]) || x2(f4) && (o2 < a2.yearlen && !L(f4, o2 + 1) && !L(f4, -a2.yearlen + o2) || o2 >= a2.yearlen && !L(f4, o2 + 1 - a2.yearlen) && !L(f4, -a2.nextyearlen + o2 - a2.yearlen))) && (t3[m3] = null);
          }
          return p2;
        }
        var Nt = { MO: new f3(0), TU: new f3(1), WE: new f3(2), TH: new f3(3), FR: new f3(4), SA: new f3(5), SU: new f3(6) }, Ct = { freq: C.YEARLY, dtstart: null, interval: 1, wkst: Nt.MO, count: null, until: null, tzid: null, bysetpos: null, bymonth: null, bymonthday: null, bynmonthday: null, byyearday: null, byweekno: null, byweekday: null, bynweekday: null, byhour: null, byminute: null, bysecond: null, byeaster: null }, It = Object.keys(Ct);
        function Wt(t3, e3) {
          t3 === void 0 && (t3 = {}), e3 === void 0 && (e3 = false), this._cache = e3 ? null : new ut(), this.origOptions = G(t3);
          var n3 = function(t4) {
            var e4 = _(_({}, Ct), G(t4));
            if (D(e4.byeaster) && (e4.freq = jt.YEARLY), !D(e4.freq) || !jt.FREQUENCIES[e4.freq])
              throw new Error("Invalid frequency: " + e4.freq + " " + t4.freq);
            if (e4.dtstart || (e4.dtstart = new Date(new Date().setMilliseconds(0))), D(e4.wkst) ? p(e4.wkst) || (e4.wkst = e4.wkst.weekday) : e4.wkst = jt.MO.weekday, D(e4.bysetpos)) {
              p(e4.bysetpos) && (e4.bysetpos = [e4.bysetpos]);
              for (var n4 = 0; n4 < e4.bysetpos.length; n4++) {
                if ((a2 = e4.bysetpos[n4]) === 0 || !(-366 <= a2 && a2 <= 366))
                  throw new Error("bysetpos must be between 1 and 366, or between -366 and -1");
              }
            }
            if (!(Boolean(e4.byweekno) || x2(e4.byweekno) || x2(e4.byyearday) || Boolean(e4.bymonthday) || x2(e4.bymonthday) || D(e4.byweekday) || D(e4.byeaster)))
              switch (e4.freq) {
                case jt.YEARLY:
                  e4.bymonth || (e4.bymonth = e4.dtstart.getUTCMonth() + 1), e4.bymonthday = e4.dtstart.getUTCDate();
                  break;
                case jt.MONTHLY:
                  e4.bymonthday = e4.dtstart.getUTCDate();
                  break;
                case jt.WEEKLY:
                  e4.byweekday = [M.getWeekday(e4.dtstart)];
              }
            if (D(e4.bymonth) && !b(e4.bymonth) && (e4.bymonth = [e4.bymonth]), D(e4.byyearday) && !b(e4.byyearday) && p(e4.byyearday) && (e4.byyearday = [e4.byyearday]), D(e4.bymonthday))
              if (b(e4.bymonthday)) {
                var r4 = [], i4 = [];
                for (n4 = 0; n4 < e4.bymonthday.length; n4++) {
                  var a2;
                  0 < (a2 = e4.bymonthday[n4]) ? r4.push(a2) : a2 < 0 && i4.push(a2);
                }
                e4.bymonthday = r4, e4.bynmonthday = i4;
              } else
                e4.bymonthday < 0 ? (e4.bynmonthday = [e4.bymonthday], e4.bymonthday = []) : (e4.bynmonthday = [], e4.bymonthday = [e4.bymonthday]);
            else
              e4.bymonthday = [], e4.bynmonthday = [];
            if (D(e4.byweekno) && !b(e4.byweekno) && (e4.byweekno = [e4.byweekno]), D(e4.byweekday))
              if (p(e4.byweekday))
                e4.byweekday = [e4.byweekday], e4.bynweekday = null;
              else if (h2(e4.byweekday))
                e4.byweekday = [f3.fromStr(e4.byweekday).weekday], e4.bynweekday = null;
              else if (e4.byweekday instanceof f3)
                !e4.byweekday.n || e4.freq > jt.MONTHLY ? (e4.byweekday = [e4.byweekday.weekday], e4.bynweekday = null) : (e4.bynweekday = [[e4.byweekday.weekday, e4.byweekday.n]], e4.byweekday = null);
              else {
                var o2 = [], s4 = [];
                for (n4 = 0; n4 < e4.byweekday.length; n4++) {
                  var u2 = e4.byweekday[n4];
                  p(u2) ? o2.push(u2) : h2(u2) ? o2.push(f3.fromStr(u2).weekday) : !u2.n || e4.freq > jt.MONTHLY ? o2.push(u2.weekday) : s4.push([u2.weekday, u2.n]);
                }
                e4.byweekday = x2(o2) ? o2 : null, e4.bynweekday = x2(s4) ? s4 : null;
              }
            else
              e4.bynweekday = null;
            return D(e4.byhour) ? p(e4.byhour) && (e4.byhour = [e4.byhour]) : e4.byhour = e4.freq < jt.HOURLY ? [e4.dtstart.getUTCHours()] : null, D(e4.byminute) ? p(e4.byminute) && (e4.byminute = [e4.byminute]) : e4.byminute = e4.freq < jt.MINUTELY ? [e4.dtstart.getUTCMinutes()] : null, D(e4.bysecond) ? p(e4.bysecond) && (e4.bysecond = [e4.bysecond]) : e4.bysecond = e4.freq < jt.SECONDLY ? [e4.dtstart.getUTCSeconds()] : null, { parsedOptions: e4 };
          }(t3).parsedOptions;
          this.options = n3;
        }
        var jt = (Wt.parseText = function(t3, e3) {
          return q(t3, e3);
        }, Wt.fromText = function(t3, e3) {
          return (n3 = e3) === void 0 && (n3 = A2), new jt(q(t3, n3) || void 0);
          var n3;
        }, Wt.fromString = function(t3) {
          return new Wt(Wt.parseString(t3) || void 0);
        }, Wt.prototype._iter = function(t3) {
          return Mt(t3, this.options);
        }, Wt.prototype._cacheGet = function(t3, e3) {
          return !!this._cache && this._cache._cacheGet(t3, e3);
        }, Wt.prototype._cacheAdd = function(t3, e3, n3) {
          if (this._cache)
            return this._cache._cacheAdd(t3, e3, n3);
        }, Wt.prototype.all = function(t3) {
          if (t3)
            return this._iter(new R("all", {}, t3));
          var e3 = this._cacheGet("all");
          return e3 === false && (e3 = this._iter(new l("all", {})), this._cacheAdd("all", e3)), e3;
        }, Wt.prototype.between = function(t3, e3, n3, r4) {
          if (n3 === void 0 && (n3 = false), !M.isValidDate(t3) || !M.isValidDate(e3))
            throw new Error("Invalid date passed in to RRule.between");
          var i4 = { before: e3, after: t3, inc: n3 };
          if (r4)
            return this._iter(new R("between", i4, r4));
          var a2 = this._cacheGet("between", i4);
          return a2 === false && (a2 = this._iter(new l("between", i4)), this._cacheAdd("between", a2, i4)), a2;
        }, Wt.prototype.before = function(t3, e3) {
          if (e3 === void 0 && (e3 = false), !M.isValidDate(t3))
            throw new Error("Invalid date passed in to RRule.before");
          var n3 = { dt: t3, inc: e3 }, r4 = this._cacheGet("before", n3);
          return r4 === false && (r4 = this._iter(new l("before", n3)), this._cacheAdd("before", r4, n3)), r4;
        }, Wt.prototype.after = function(t3, e3) {
          if (e3 === void 0 && (e3 = false), !M.isValidDate(t3))
            throw new Error("Invalid date passed in to RRule.after");
          var n3 = { dt: t3, inc: e3 }, r4 = this._cacheGet("after", n3);
          return r4 === false && (r4 = this._iter(new l("after", n3)), this._cacheAdd("after", r4, n3)), r4;
        }, Wt.prototype.count = function() {
          return this.all().length;
        }, Wt.prototype.toString = function() {
          return at(this.origOptions);
        }, Wt.prototype.toText = function(t3, e3, n3) {
          return new W(this, t3, e3, n3).toString();
        }, Wt.prototype.isFullyConvertibleToText = function() {
          return F2(this);
        }, Wt.prototype.clone = function() {
          return new Wt(this.origOptions);
        }, Wt.FREQUENCIES = ["YEARLY", "MONTHLY", "WEEKLY", "DAILY", "HOURLY", "MINUTELY", "SECONDLY"], Wt.YEARLY = C.YEARLY, Wt.MONTHLY = C.MONTHLY, Wt.WEEKLY = C.WEEKLY, Wt.DAILY = C.DAILY, Wt.HOURLY = C.HOURLY, Wt.MINUTELY = C.MINUTELY, Wt.SECONDLY = C.SECONDLY, Wt.MO = Nt.MO, Wt.TU = Nt.TU, Wt.WE = Nt.WE, Wt.TH = Nt.TH, Wt.FR = Nt.FR, Wt.SA = Nt.SA, Wt.SU = Nt.SU, Wt.parseString = J, Wt.optionsToString = at, Wt);
        var Ht, qt = { dtstart: null, cache: false, unfold: false, forceset: false, compatible: false, tzid: null };
        function Pt(t3, e3) {
          var s4 = [], u2 = [], h3 = [], y2 = [], n3 = Q(t3), r4 = n3.dtstart, d2 = n3.tzid;
          return function(t4, e4) {
            e4 === void 0 && (e4 = false);
            if (!(t4 = t4 && t4.trim()))
              throw new Error("Invalid empty string");
            if (!e4)
              return t4.split(/\s/);
            var n4 = t4.split("\n"), r5 = 0;
            for (; r5 < n4.length; ) {
              var i4 = n4[r5] = n4[r5].replace(/\s+$/g, "");
              i4 ? 0 < r5 && i4[0] === " " ? (n4[r5 - 1] += i4.slice(1), n4.splice(r5, 1)) : r5 += 1 : n4.splice(r5, 1);
            }
            return n4;
          }(t3, e3.unfold).forEach(function(t4) {
            if (t4) {
              var e4 = function(t5) {
                var e5 = function(t6) {
                  if (t6.indexOf(":") === -1)
                    return { name: "RRULE", value: t6 };
                  var e6 = c(t6, ":", 1), n6 = e6[0], r7 = e6[1];
                  return { name: n6, value: r7 };
                }(t5), n5 = e5.name, r6 = e5.value, i5 = n5.split(";");
                if (!i5)
                  throw new Error("empty property name");
                return { name: i5[0].toUpperCase(), parms: i5.slice(1), value: r6 };
              }(t4), n4 = e4.name, r5 = e4.parms, i4 = e4.value;
              switch (n4.toUpperCase()) {
                case "RRULE":
                  if (r5.length)
                    throw new Error("unsupported RRULE parm: " + r5.join(","));
                  s4.push(J(t4));
                  break;
                case "RDATE":
                  var a2 = /RDATE(?:;TZID=([^:=]+))?/i.exec(t4), o2 = (a2[0], a2[1]);
                  o2 && !d2 && (d2 = o2), u2 = u2.concat(Kt(i4, r5));
                  break;
                case "EXRULE":
                  if (r5.length)
                    throw new Error("unsupported EXRULE parm: " + r5.join(","));
                  h3.push(J(i4));
                  break;
                case "EXDATE":
                  y2 = y2.concat(Kt(i4, r5));
                  break;
                case "DTSTART":
                  break;
                default:
                  throw new Error("unsupported property: " + n4);
              }
            }
          }), { dtstart: r4, tzid: d2, rrulevals: s4, rdatevals: u2, exrulevals: h3, exdatevals: y2 };
        }
        function zt(t3, e3) {
          return e3 === void 0 && (e3 = {}), function(t4, e4) {
            var n3 = Pt(t4, e4), r4 = n3.rrulevals, i4 = n3.rdatevals, a2 = n3.exrulevals, o2 = n3.exdatevals, s4 = n3.dtstart, u2 = n3.tzid, h3 = e4.cache === false;
            if (e4.compatible && (e4.forceset = true, e4.unfold = true), e4.forceset || 1 < r4.length || i4.length || a2.length || o2.length) {
              var y2 = new Vt(h3);
              return y2.dtstart(s4), y2.tzid(u2 || void 0), r4.forEach(function(t5) {
                y2.rrule(new jt(Ft(t5, s4, u2), h3));
              }), i4.forEach(function(t5) {
                y2.rdate(t5);
              }), a2.forEach(function(t5) {
                y2.exrule(new jt(Ft(t5, s4, u2), h3));
              }), o2.forEach(function(t5) {
                y2.exdate(t5);
              }), e4.compatible && e4.dtstart && y2.rdate(s4), y2;
            }
            var d2 = r4[0] || {};
            return new jt(Ft(d2, d2.dtstart || e4.dtstart || s4, d2.tzid || e4.tzid || u2), h3);
          }(t3, function(t4) {
            var e4 = [], n3 = Object.keys(t4), r4 = Object.keys(qt);
            if (n3.forEach(function(t5) {
              L(r4, t5) || e4.push(t5);
            }), e4.length)
              throw new Error("Invalid options: " + e4.join(", "));
            return _(_({}, qt), t4);
          }(e3));
        }
        function Ft(t3, e3, n3) {
          return _(_({}, t3), { dtstart: e3, tzid: n3 });
        }
        function Kt(t3, e3) {
          return e3.forEach(function(t4) {
            if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(t4))
              throw new Error("unsupported RDATE/EXDATE parm: " + t4);
          }), t3.split(",").map(function(t4) {
            return M.untilStringToDate(t4);
          });
        }
        function Bt(r4) {
          var i4 = this;
          return function(t3) {
            if (t3 !== void 0 && (i4["_" + r4] = t3), i4["_" + r4] !== void 0)
              return i4["_" + r4];
            for (var e3 = 0; e3 < i4._rrule.length; e3++) {
              var n3 = i4._rrule[e3].origOptions[r4];
              if (n3)
                return n3;
            }
          };
        }
        function Zt(t3) {
          t3 === void 0 && (t3 = false);
          var e3 = Ht.call(this, {}, t3) || this;
          return e3.dtstart = Bt.apply(e3, ["dtstart"]), e3.tzid = Bt.apply(e3, ["tzid"]), e3._rrule = [], e3._rdate = [], e3._exrule = [], e3._exdate = [], e3;
        }
        var Vt = (w(Zt, Ht = jt), Zt.prototype._iter = function(t3) {
          return function(e3, t4, r4, n3, i4, a2) {
            var o2 = {}, s4 = e3.accept;
            function u2(e4, n4) {
              r4.forEach(function(t5) {
                t5.between(e4, n4, true).forEach(function(t6) {
                  o2[Number(t6)] = true;
                });
              });
            }
            i4.forEach(function(t5) {
              var e4 = new rt(t5, a2).rezonedDate();
              o2[Number(e4)] = true;
            }), e3.accept = function(t5) {
              var e4 = Number(t5);
              return isNaN(e4) ? s4.call(this, t5) : !(!o2[e4] && (u2(new Date(e4 - 1), new Date(e4 + 1)), !o2[e4])) || (o2[e4] = true, s4.call(this, t5));
            }, e3.method === "between" && (u2(e3.args.after, e3.args.before), e3.accept = function(t5) {
              var e4 = Number(t5);
              return !!o2[e4] || (o2[e4] = true, s4.call(this, t5));
            });
            for (var h3 = 0; h3 < n3.length; h3++) {
              var y2 = new rt(n3[h3], a2).rezonedDate();
              if (!e3.accept(new Date(y2.getTime())))
                break;
            }
            t4.forEach(function(t5) {
              Mt(e3, t5.options);
            });
            var d2 = e3._result;
            switch (M.sort(d2), e3.method) {
              case "all":
              case "between":
                return d2;
              case "before":
                return d2.length && d2[d2.length - 1] || null;
              case "after":
              default:
                return d2.length && d2[0] || null;
            }
          }(t3, this._rrule, this._exrule, this._rdate, this._exdate, this.tzid());
        }, Zt.prototype.rrule = function(t3) {
          Xt(t3, this._rrule);
        }, Zt.prototype.exrule = function(t3) {
          Xt(t3, this._exrule);
        }, Zt.prototype.rdate = function(t3) {
          Gt(t3, this._rdate);
        }, Zt.prototype.exdate = function(t3) {
          Gt(t3, this._exdate);
        }, Zt.prototype.rrules = function() {
          return this._rrule.map(function(t3) {
            return zt(t3.toString());
          });
        }, Zt.prototype.exrules = function() {
          return this._exrule.map(function(t3) {
            return zt(t3.toString());
          });
        }, Zt.prototype.rdates = function() {
          return this._rdate.map(function(t3) {
            return new Date(t3.getTime());
          });
        }, Zt.prototype.exdates = function() {
          return this._exdate.map(function(t3) {
            return new Date(t3.getTime());
          });
        }, Zt.prototype.valueOf = function() {
          var e3 = [];
          return !this._rrule.length && this._dtstart && (e3 = e3.concat(at({ dtstart: this._dtstart }))), this._rrule.forEach(function(t3) {
            e3 = e3.concat(t3.toString().split("\n"));
          }), this._exrule.forEach(function(t3) {
            e3 = e3.concat(t3.toString().split("\n").map(function(t4) {
              return t4.replace(/^RRULE:/, "EXRULE:");
            }).filter(function(t4) {
              return !/^DTSTART/.test(t4);
            }));
          }), this._rdate.length && e3.push(Jt("RDATE", this._rdate, this.tzid())), this._exdate.length && e3.push(Jt("EXDATE", this._exdate, this.tzid())), e3;
        }, Zt.prototype.toString = function() {
          return this.valueOf().join("\n");
        }, Zt.prototype.clone = function() {
          var e3 = new Zt(!!this._cache);
          return this._rrule.forEach(function(t3) {
            return e3.rrule(t3.clone());
          }), this._exrule.forEach(function(t3) {
            return e3.exrule(t3.clone());
          }), this._rdate.forEach(function(t3) {
            return e3.rdate(new Date(t3.getTime()));
          }), this._exdate.forEach(function(t3) {
            return e3.exdate(new Date(t3.getTime()));
          }), e3;
        }, Zt);
        function Xt(t3, e3) {
          if (!(t3 instanceof jt))
            throw new TypeError(String(t3) + " is not RRule instance");
          L(e3.map(String), String(t3)) || e3.push(t3);
        }
        function Gt(t3, e3) {
          if (!(t3 instanceof Date))
            throw new TypeError(String(t3) + " is not Date instance");
          L(e3.map(Number), Number(t3)) || (e3.push(t3), M.sort(e3));
        }
        function Jt(t3, e3, n3) {
          var r4 = !n3 || n3.toUpperCase() === "UTC";
          return (r4 ? t3 + ":" : t3 + ";TZID=" + n3 + ":") + e3.map(function(t4) {
            return M.timeToUntilString(t4.valueOf(), r4);
          }).join(",");
        }
        n2.d(e2, "rrulestr", function() {
          return zt;
        }), n2.d(e2, "Frequency", function() {
          return C;
        }), n2.d(e2, "Weekday", function() {
          return f3;
        }), n2.d(e2, "RRule", function() {
          return jt;
        }), n2.d(e2, "RRuleSet", function() {
          return Vt;
        });
        e2.default = jt;
      }], i2.c = r2, i2.d = function(t2, e2, n2) {
        i2.o(t2, e2) || Object.defineProperty(t2, e2, { enumerable: true, get: n2 });
      }, i2.r = function(t2) {
        typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      }, i2.t = function(e2, t2) {
        if (1 & t2 && (e2 = i2(e2)), 8 & t2)
          return e2;
        if (4 & t2 && typeof e2 == "object" && e2 && e2.__esModule)
          return e2;
        var n2 = /* @__PURE__ */ Object.create(null);
        if (i2.r(n2), Object.defineProperty(n2, "default", { enumerable: true, value: e2 }), 2 & t2 && typeof e2 != "string")
          for (var r3 in e2)
            i2.d(n2, r3, function(t3) {
              return e2[t3];
            }.bind(null, r3));
        return n2;
      }, i2.n = function(t2) {
        var e2 = t2 && t2.__esModule ? function() {
          return t2.default;
        } : function() {
          return t2;
        };
        return i2.d(e2, "a", e2), e2;
      }, i2.o = function(t2, e2) {
        return Object.prototype.hasOwnProperty.call(t2, e2);
      }, i2.p = "", i2(i2.s = 0);
      function i2(t2) {
        if (r2[t2])
          return r2[t2].exports;
        var e2 = r2[t2] = { i: t2, l: false, exports: {} };
        return n[t2].call(e2.exports, e2, e2.exports, i2), e2.l = true, e2.exports;
      }
      var n, r2;
    });
  }
});

// .svelte-kit/output/server/entries/endpoints/events/index.json.ts.js
var index_json_ts_exports = {};
__export(index_json_ts_exports, {
  get: () => get2
});
function* walkICAL(rawICAL) {
  const output = {};
  const lines = rawICAL.split(/\r\n|\n|\r/);
  const parents = [];
  let parent = {};
  let current = output;
  let currentKey = "";
  for (const line of lines) {
    let currentValue = "";
    if (line.charAt(0) === " ") {
      current[currentKey] += line.substring(1);
    } else {
      const splitAt = line.indexOf(":");
      if (splitAt < 0) {
        continue;
      }
      currentKey = ((key2) => {
        if (key2.startsWith("DTSTART"))
          return "DTSTART";
        if (key2.startsWith("DTEND"))
          return "DTEND";
        return key2;
      })(line.substring(0, splitAt));
      currentValue = line.substring(splitAt + 1);
      switch (currentKey) {
        case "BEGIN": {
          parents.push(parent);
          parent = current;
          if (parent[currentValue] == null) {
            parent[currentValue] = [];
          }
          current = {};
          parent[currentValue].push(current);
          break;
        }
        case "END": {
          current = parent;
          parent = parents.pop();
          break;
        }
        default: {
          if (current[currentKey]) {
            if (!Array.isArray(current[currentKey])) {
              current[currentKey] = [current[currentKey]];
            }
            current[currentKey].push(currentValue);
          } else {
            current[currentKey] = currentValue;
          }
        }
      }
    }
  }
  for (const icalEvent of output["VCALENDAR"][0]["VEVENT"]) {
    yield icalEvent;
  }
}
function parseRRULE(rawRRULE) {
  if (rawRRULE === void 0)
    return false;
  try {
    const recurrence = RRule.fromString(rawRRULE);
    return recurrence.isFullyConvertibleToText();
  } catch {
    return false;
  }
}
function makeEventSlug(title, date) {
  const normalizedTitle = title.replace(/[^\w\s-_]/g, "").replace(/(\s|-|_)+/g, "-");
  return [
    normalizedTitle,
    date.year,
    date.toLocaleString("en-US", { month: "long" }).toLowerCase(),
    date.day
  ].join("-").toLowerCase();
}
function makeEventLink(slug, baseURL = "https://acmcsuf.com/events") {
  if (slug === void 0)
    return baseURL;
  return baseURL + "#" + slug;
}
function wrapText(text, width = 100) {
  const lines = [];
  while (text.length > width) {
    const index = text.lastIndexOf(" ", width);
    if (index === -1) {
      lines.push(text.substring(0, width));
      text = text.substring(width);
    } else {
      lines.push(text.substring(0, index));
      text = text.substring(index + 1);
    }
  }
  lines.push(text);
  return lines;
}
function produceSummary(title, description, selfLink) {
  return description.length > 0 ? [title, "=".repeat(title.length), "", ...wrapText(description), "", selfLink].join("\n") : title + " \u2014 " + selfLink;
}
function replaceHtmlLinkTargets(html, withTarget = "_blank") {
  return html.replace(/<a\W.*?href=".*?".*?>/gm, (match2) => {
    match2 = match2.replace(/target=".*?"\W*/gm, "");
    return match2.slice(0, match2.length - 1) + ` target="${withTarget}">`;
  });
}
function parseDescription(content, varPrefix = "ACM_") {
  if (content === void 0)
    return { description: "", variables: /* @__PURE__ */ new Map() };
  const variables = /* @__PURE__ */ new Map();
  let description = content.replace(/\\n/g, "<br>").replace(/\\/g, "");
  while (description.includes(varPrefix)) {
    const start = description.indexOf(varPrefix);
    const nextTag = description.indexOf("<", start);
    const end = nextTag > -1 ? nextTag : description.length;
    const variable = description.substring(start, end);
    const splitAt = variable.indexOf("=");
    const key2 = variable.substring(0, splitAt).trim();
    const value = variable.substring(splitAt + 1);
    variables.set(key2, value);
    description = (description.substring(0, start) + description.substring(end)).trim();
  }
  description = replaceHtmlLinkTargets(description);
  return { description, variables };
}
function thirdPartyCalendarDateTimeFromZonedDateTime(dt) {
  const yyyyMMdd = [dt.year, dt.month, dt.day].map((d) => d.toString().padStart(2, "0")).join("");
  const hhMMss = [dt.hour, dt.minute, dt.day].map((d) => d.toString().padStart(2, "0")).join("");
  const yyyyMMddThhMMss = yyyyMMdd + "T" + hhMMss;
  return yyyyMMddThhMMss;
}
function makeGoogleCalendarLink(title, summary, location, dtStart, dtEnd) {
  const url = new URL("https://calendar.google.com/calendar/render");
  url.searchParams.set("action", "TEMPLATE");
  url.searchParams.set("text", title);
  url.searchParams.set("details", summary);
  url.searchParams.set("location", location);
  const dateOne = thirdPartyCalendarDateTimeFromZonedDateTime(dtStart);
  const dateTwo = thirdPartyCalendarDateTimeFromZonedDateTime(dtEnd);
  url.searchParams.set("dates", dateOne + "/" + dateTwo);
  return url;
}
function makeOutlookCalendarLink(title, summary, location, dtStart, dtEnd) {
  const url = new URL("https://outlook.live.com/calendar/0/deeplink/compose");
  url.searchParams.set("path", "/calendar/action/compose");
  url.searchParams.set("rru", "addevent");
  url.searchParams.set("startdt", thirdPartyCalendarDateTimeFromZonedDateTime(dtStart));
  url.searchParams.set("enddt", thirdPartyCalendarDateTimeFromZonedDateTime(dtEnd));
  url.searchParams.set("subject", title);
  url.searchParams.set("body", summary);
  url.searchParams.set("location", location);
  return url;
}
function parseLocation(rawLocation, defaultLocation = "TBD", defaultLink = "/discord") {
  rawLocation = (rawLocation == null ? void 0 : rawLocation.trim()) ?? "";
  if (rawLocation.includes("zoom.us")) {
    return { location: "Zoom", meetingLink: rawLocation };
  }
  if (rawLocation.startsWith("https://")) {
    return { location: defaultLocation, meetingLink: rawLocation };
  }
  if (rawLocation.length > 0) {
    return { location: rawLocation, meetingLink: defaultLink };
  }
  return { location: defaultLocation, meetingLink: defaultLink };
}
function zonedDateTimeFromICALDateTime(dtICAL, timeZone2) {
  const options = {
    year: Number(dtICAL.slice(0, 4)),
    month: Number(dtICAL.slice(4, 6)),
    day: Number(dtICAL.slice(6, 8)),
    hour: Number(dtICAL.slice(9, 11)),
    minute: Number(dtICAL.slice(11, 13)),
    second: Number(dtICAL.slice(13, 15))
  };
  if (dtICAL[15] === "Z") {
    options["timeZone"] = temporal.TimeZone.from("+00:00");
    return temporal.ZonedDateTime.from(options).withTimeZone(timeZone2);
  }
  return temporal.PlainDateTime.from(options).toZonedDateTime(timeZone2);
}
function makeAcmEvent(icalEvent, referenceDate) {
  var _a4;
  if (icalEvent["DTSTART"] === void 0 || icalEvent["DTEND"] === void 0) {
    return null;
  }
  const title = icalEvent["SUMMARY"] !== void 0 ? icalEvent["SUMMARY"].replace(/\\/g, "") : "Unnamed Event";
  const recurring = parseRRULE(icalEvent["RRULE"]);
  const dtStart = zonedDateTimeFromICALDateTime(icalEvent["DTSTART"], referenceDate.timeZone);
  const dtEnd = zonedDateTimeFromICALDateTime(icalEvent["DTEND"], referenceDate.timeZone);
  const date = dtStart.toString();
  const month = dtStart.toLocaleString("en-US", { month: "long" });
  const day = dtStart.day;
  const time2 = dtStart.toLocaleString("en-US", { hour: "numeric", minute: "numeric" });
  const hasStarted = temporal.ZonedDateTime.compare(referenceDate, dtStart) >= 0;
  const hasEnded = temporal.ZonedDateTime.compare(referenceDate, dtEnd) >= 0;
  const duration2 = dtEnd.since(dtStart).minutes + " minutes";
  const { description, variables } = parseDescription(icalEvent["DESCRIPTION"]);
  const { location, meetingLink } = parseLocation(icalEvent["LOCATION"], variables.get("ACM_LOCATION"));
  const slug = makeEventSlug(title, dtStart);
  const selfLink = makeEventLink(slug);
  const summary = produceSummary(title, description, selfLink);
  const rawAcmPath = (_a4 = variables.get("ACM_PATH")) == null ? void 0 : _a4.toLowerCase();
  const acmPath = rawAcmPath === void 0 ? acmGeneral : rawAcmPath === acmAlgo.slug ? acmAlgo : rawAcmPath === acmCreate.slug ? acmCreate : rawAcmPath === acmDev.slug ? acmDev : acmGeneral;
  const thirdPartyCalendarLocation = location === "Discord" ? selfLink : location;
  const thirdPartyCalendarArgs = [
    title,
    summary,
    thirdPartyCalendarLocation,
    dtStart,
    dtEnd
  ];
  const calendarLinks = {
    google: makeGoogleCalendarLink(...thirdPartyCalendarArgs).toString(),
    outlook: makeOutlookCalendarLink(...thirdPartyCalendarArgs).toString()
  };
  return {
    month,
    day,
    time: time2,
    date,
    hasStarted,
    hasEnded,
    duration: duration2,
    location,
    title,
    summary,
    description,
    meetingLink,
    slug,
    selfLink,
    recurring,
    acmPath,
    calendarLinks
  };
}
function parse2(rawICAL, options) {
  const acmEvents = [];
  const refDate = options.referenceDate ?? temporal.Now.zonedDateTimeISO("America/Los_Angeles");
  const filterBefore = options.filterBefore !== void 0 ? options.filterBefore : true;
  for (const icalEvent of walkICAL(rawICAL)) {
    const acmEvent = makeAcmEvent(icalEvent, refDate);
    if (filterBefore && acmEvent.hasEnded) {
      continue;
    }
    acmEvents.push(acmEvent);
  }
  const sortedAcmEvents = acmEvents.sort((one, two) => temporal.ZonedDateTime.compare(one.date, two.date));
  if (options.maxEvents !== void 0) {
    const eventsAmt = options.maxEvents ?? 5;
    return sortedAcmEvents.slice(0, eventsAmt);
  }
  return sortedAcmEvents;
}
async function setCache(timestamp) {
  const data = await fetch(ICAL_TARGET_URL).then((response) => response.text());
  events = parse2(data, { maxEvents: DEBUG ? 10 : void 0 });
  return events;
}
async function getCache() {
  return await setCache();
}
async function get2() {
  return new Response(JSON.stringify(await getCache()), {
    status: 200,
    headers: { "Content-Type": "application/json" }
  });
}
var RRule, ICAL_TARGET_URL, events;
var init_index_json_ts = __esm({
  ".svelte-kit/output/server/entries/endpoints/events/index.json.ts.js"() {
    RRule = __toESM(require_rrule_min(), 1);
    init_index_esm();
    init_acm_paths_c5897a25();
    init_index_ba3ba78e();
    ICAL_TARGET_URL = "https://calendar.google.com/calendar/ical/738lnit63cr2lhp7jtduvj0c9g%40group.calendar.google.com/public/basic.ics";
    events = [];
  }
});

// node_modules/rss/node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/rss/node_modules/mime-db/db.json"(exports, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana"
      },
      "application/3gpp-ims+xml": {
        source: "iana"
      },
      "application/a2l": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana"
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        extensions: ["atomsvc"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana"
      },
      "application/bacnet-xdd+zip": {
        source: "iana"
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana"
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana"
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/cbor": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana"
      },
      "application/ccxml+xml": {
        source: "iana",
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana"
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana"
      },
      "application/cellml+xml": {
        source: "iana"
      },
      "application/cfw": {
        source: "iana"
      },
      "application/clue_info+xml": {
        source: "iana"
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana"
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana"
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana"
      },
      "application/cstadata+xml": {
        source: "iana"
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        extensions: ["mpd"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana"
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana"
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        extensions: ["dbk"]
      },
      "application/dskpp+xml": {
        source: "iana"
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana"
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana"
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana"
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana"
      },
      "application/emma+xml": {
        source: "iana",
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana"
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana"
      },
      "application/epub+zip": {
        source: "iana",
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana"
      },
      "application/fits": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false,
        extensions: ["woff"]
      },
      "application/font-woff2": {
        compressible: false,
        extensions: ["woff2"]
      },
      "application/framework-attributes+xml": {
        source: "iana"
      },
      "application/geo+json": {
        source: "iana",
        compressible: true
      },
      "application/gml+xml": {
        source: "apache",
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana"
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana"
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana"
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana"
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana"
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js"]
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana"
      },
      "application/kpml-response+xml": {
        source: "iana"
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana"
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana"
      },
      "application/lost+xml": {
        source: "iana",
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana"
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        extensions: ["mads"]
      },
      "application/manifest+json": {
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana"
      },
      "application/mathml-presentation+xml": {
        source: "iana"
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana"
      },
      "application/mbms-deregister+xml": {
        source: "iana"
      },
      "application/mbms-envelope+xml": {
        source: "iana"
      },
      "application/mbms-msk+xml": {
        source: "iana"
      },
      "application/mbms-msk-response+xml": {
        source: "iana"
      },
      "application/mbms-protection-description+xml": {
        source: "iana"
      },
      "application/mbms-reception-report+xml": {
        source: "iana"
      },
      "application/mbms-register+xml": {
        source: "iana"
      },
      "application/mbms-register-response+xml": {
        source: "iana"
      },
      "application/mbms-schedule+xml": {
        source: "iana"
      },
      "application/mbms-user-service-description+xml": {
        source: "iana"
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana"
      },
      "application/media_control+xml": {
        source: "iana"
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mods+xml": {
        source: "iana",
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana"
      },
      "application/mrb-publish+xml": {
        source: "iana"
      },
      "application/msc-ivr+xml": {
        source: "iana"
      },
      "application/msc-mixer+xml": {
        source: "iana"
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana"
      },
      "application/news-groupinfo": {
        source: "iana"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana"
      },
      "application/nss": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p2p-overlay+xml": {
        source: "iana"
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana"
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana"
      },
      "application/pidf-diff+xml": {
        source: "iana"
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana"
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana"
      },
      "application/provenance+xml": {
        source: "iana"
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.hpub+zip": {
        source: "iana"
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana"
      },
      "application/pskc+xml": {
        source: "iana",
        extensions: ["pskcxml"]
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf"]
      },
      "application/reginfo+xml": {
        source: "iana",
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana"
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana"
      },
      "application/rls-services+xml": {
        source: "iana",
        extensions: ["rs"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana"
      },
      "application/samlmetadata+xml": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana"
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/sep+xml": {
        source: "iana"
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana"
      },
      "application/simple-filter+xml": {
        source: "iana"
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        extensions: ["srx"]
      },
      "application/spirits-event+xml": {
        source: "iana"
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        extensions: ["ssml"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        extensions: ["tei", "teicorpus"]
      },
      "application/thraud+xml": {
        source: "iana",
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/ttml+xml": {
        source: "iana"
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana"
      },
      "application/urc-ressheet+xml": {
        source: "iana"
      },
      "application/urc-targetdesc+xml": {
        source: "iana"
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana"
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana"
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana"
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana"
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana"
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana"
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana"
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana"
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana"
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana"
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana"
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        extensions: ["mpkg"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avistar+xml": {
        source: "iana"
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana"
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana"
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        extensions: ["wbs"]
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana"
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana"
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume-movie": {
        source: "iana"
      },
      "application/vnd.desmume.movie": {
        source: "apache"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana"
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana"
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana"
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana"
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana"
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana"
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana"
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana"
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana"
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana"
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana"
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana"
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana"
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana"
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana"
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana"
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana"
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana"
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana"
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana"
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana"
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana"
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana"
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana"
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana"
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana"
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana"
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana"
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana"
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana"
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana"
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana"
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana"
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana"
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana"
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana"
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana"
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana"
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana"
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana"
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana"
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana"
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana"
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        extensions: ["lasxml"]
      },
      "application/vnd.liberty-request+xml": {
        source: "iana"
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        extensions: ["lbe"]
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana"
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana"
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana"
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana"
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana"
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana"
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana"
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache"
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana"
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana"
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana"
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana"
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana"
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana"
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana"
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana"
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana"
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana"
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana"
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana"
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana"
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana"
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana"
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana"
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana"
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana"
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana"
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana"
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana"
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana"
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana"
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana"
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana"
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana"
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana"
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana"
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana"
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana"
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana"
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana"
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana"
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana"
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana"
      },
      "application/vnd.omads-email+xml": {
        source: "iana"
      },
      "application/vnd.omads-file+xml": {
        source: "iana"
      },
      "application/vnd.omads-folder+xml": {
        source: "iana"
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana"
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.presentationml-template": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "apache",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml-template": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "apache",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml-template": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "apache",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana"
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana"
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana"
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos+xml": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "apache"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana"
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana"
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana"
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana"
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana"
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana"
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana"
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana"
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana"
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana"
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana"
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana"
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana"
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana"
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana"
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana"
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana"
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana"
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana"
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana"
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana"
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana"
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana"
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana"
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana"
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        extensions: ["vxml"]
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/watcherinfo+xml": {
        source: "iana"
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-otf": {
        source: "apache",
        compressible: true,
        extensions: ["otf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-ttf": {
        source: "apache",
        compressible: true,
        extensions: ["ttf", "ttc"]
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "apache",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana"
      },
      "application/xaml+xml": {
        source: "apache",
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana"
      },
      "application/xcap-caps+xml": {
        source: "iana"
      },
      "application/xcap-diff+xml": {
        source: "iana",
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana"
      },
      "application/xcap-error+xml": {
        source: "iana"
      },
      "application/xcap-ns+xml": {
        source: "iana"
      },
      "application/xcon-conference-info+xml": {
        source: "iana"
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana"
      },
      "application/xenc+xml": {
        source: "iana",
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache"
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana"
      },
      "application/xmpp+xml": {
        source: "iana"
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        extensions: ["xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana"
      },
      "application/yin+xml": {
        source: "iana",
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana"
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana"
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/opentype": {
        compressible: true,
        extensions: ["otf"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana"
      },
      "image/emf": {
        source: "iana"
      },
      "image/fits": {
        source: "iana"
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana"
      },
      "image/jp2": {
        source: "iana"
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jpm": {
        source: "iana"
      },
      "image/jpx": {
        source: "iana"
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana"
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana"
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tiff", "tif"]
      },
      "image/tiff-fx": {
        source: "iana"
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana"
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana"
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana"
      },
      "image/vnd.valve.source.texture": {
        source: "iana"
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana"
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana"
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana"
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana"
      },
      "message/global-delivery-status": {
        source: "iana"
      },
      "message/global-disposition-notification": {
        source: "iana"
      },
      "message/global-headers": {
        source: "iana"
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana"
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana"
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana"
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana"
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana"
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana"
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana",
        compressible: false
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/css": {
        source: "iana",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/hjson": {
        extensions: ["hjson"]
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana"
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["markdown", "md", "mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "apache"
      },
      "video/3gpp": {
        source: "apache",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "apache"
      },
      "video/3gpp2": {
        source: "apache",
        extensions: ["3g2"]
      },
      "video/bmpeg": {
        source: "apache"
      },
      "video/bt656": {
        source: "apache"
      },
      "video/celb": {
        source: "apache"
      },
      "video/dv": {
        source: "apache"
      },
      "video/encaprtp": {
        source: "apache"
      },
      "video/h261": {
        source: "apache",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "apache",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "apache"
      },
      "video/h263-2000": {
        source: "apache"
      },
      "video/h264": {
        source: "apache",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "apache"
      },
      "video/h264-svc": {
        source: "apache"
      },
      "video/h265": {
        source: "apache"
      },
      "video/iso.segment": {
        source: "apache"
      },
      "video/jpeg": {
        source: "apache",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "apache"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/mj2": {
        source: "apache",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "apache"
      },
      "video/mp2p": {
        source: "apache"
      },
      "video/mp2t": {
        source: "apache",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "apache",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "apache"
      },
      "video/mpeg": {
        source: "apache",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "apache"
      },
      "video/mpv": {
        source: "apache"
      },
      "video/nv": {
        source: "apache"
      },
      "video/ogg": {
        source: "apache",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "apache"
      },
      "video/pointer": {
        source: "apache"
      },
      "video/quicktime": {
        source: "apache",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "apache"
      },
      "video/raw": {
        source: "apache"
      },
      "video/rtp-enc-aescm128": {
        source: "apache"
      },
      "video/rtploopback": {
        source: "apache"
      },
      "video/rtx": {
        source: "apache"
      },
      "video/smpte292m": {
        source: "apache"
      },
      "video/ulpfec": {
        source: "apache"
      },
      "video/vc1": {
        source: "apache"
      },
      "video/vnd.cctv": {
        source: "apache"
      },
      "video/vnd.dece.hd": {
        source: "apache",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "apache",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "apache"
      },
      "video/vnd.dece.pd": {
        source: "apache",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "apache",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "apache",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "apache"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "apache"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "apache"
      },
      "video/vnd.dvb.file": {
        source: "apache",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "apache",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "apache"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "apache"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "apache"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "apache"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "apache"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "apache"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "apache"
      },
      "video/vnd.motorola.video": {
        source: "apache"
      },
      "video/vnd.motorola.videop": {
        source: "apache"
      },
      "video/vnd.mpegurl": {
        source: "apache",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "apache",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "apache"
      },
      "video/vnd.nokia.videovoip": {
        source: "apache"
      },
      "video/vnd.objectvideo": {
        source: "apache"
      },
      "video/vnd.radgamettools.bink": {
        source: "apache"
      },
      "video/vnd.radgamettools.smacker": {
        source: "apache"
      },
      "video/vnd.sealed.mpeg1": {
        source: "apache"
      },
      "video/vnd.sealed.mpeg4": {
        source: "apache"
      },
      "video/vnd.sealed.swf": {
        source: "apache"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "apache"
      },
      "video/vnd.uvvu.mp4": {
        source: "apache",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "apache",
        extensions: ["viv"]
      },
      "video/vp8": {
        source: "apache"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/rss/node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/rss/node_modules/mime-db/index.js"(exports, module2) {
    module2.exports = require_db();
  }
});

// node_modules/rss/node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/rss/node_modules/mime-types/index.js"(exports) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var extractTypeRegExp = /^\s*([^;\s]*)(?:;|\s|$)/;
    var textTypeRegExp = /^text\//i;
    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup;
    exports.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match2 = extractTypeRegExp.exec(type);
      var mime = match2 && db[match2[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match2 && textTypeRegExp.test(match2[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match2 = extractTypeRegExp.exec(type);
      var exts = match2 && exports.extensions[match2[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions, types3) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i2 = 0; i2 < exts.length; i2++) {
          var extension2 = exts[i2];
          if (types3[extension2]) {
            var from = preference.indexOf(db[types3[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types3[extension2] !== "application/octet-stream" && from > to || from === to && types3[extension2].substr(0, 12) === "application/") {
              continue;
            }
          }
          types3[extension2] = type;
        }
      });
    }
  }
});

// node_modules/xml/lib/escapeForXML.js
var require_escapeForXML = __commonJS({
  "node_modules/xml/lib/escapeForXML.js"(exports, module2) {
    var XML_CHARACTER_MAP = {
      "&": "&amp;",
      '"': "&quot;",
      "'": "&apos;",
      "<": "&lt;",
      ">": "&gt;"
    };
    function escapeForXML(string) {
      return string && string.replace ? string.replace(/([&"<>'])/g, function(str, item) {
        return XML_CHARACTER_MAP[item];
      }) : string;
    }
    module2.exports = escapeForXML;
  }
});

// node_modules/xml/lib/xml.js
var require_xml = __commonJS({
  "node_modules/xml/lib/xml.js"(exports, module2) {
    var escapeForXML = require_escapeForXML();
    var Stream2 = require("stream").Stream;
    var DEFAULT_INDENT = "    ";
    function xml(input, options) {
      if (typeof options !== "object") {
        options = {
          indent: options
        };
      }
      var stream = options.stream ? new Stream2() : null, output = "", interrupted = false, indent = !options.indent ? "" : options.indent === true ? DEFAULT_INDENT : options.indent, instant2 = true;
      function delay(func) {
        if (!instant2) {
          func();
        } else {
          process.nextTick(func);
        }
      }
      function append(interrupt, out) {
        if (out !== void 0) {
          output += out;
        }
        if (interrupt && !interrupted) {
          stream = stream || new Stream2();
          interrupted = true;
        }
        if (interrupt && interrupted) {
          var data = output;
          delay(function() {
            stream.emit("data", data);
          });
          output = "";
        }
      }
      function add(value, last) {
        format3(append, resolve2(value, indent, indent ? 1 : 0), last);
      }
      function end() {
        if (stream) {
          var data = output;
          delay(function() {
            stream.emit("data", data);
            stream.emit("end");
            stream.readable = false;
            stream.emit("close");
          });
        }
      }
      function addXmlDeclaration(declaration) {
        var encoding = declaration.encoding || "UTF-8", attr = { version: "1.0", encoding };
        if (declaration.standalone) {
          attr.standalone = declaration.standalone;
        }
        add({ "?xml": { _attr: attr } });
        output = output.replace("/>", "?>");
      }
      delay(function() {
        instant2 = false;
      });
      if (options.declaration) {
        addXmlDeclaration(options.declaration);
      }
      if (input && input.forEach) {
        input.forEach(function(value, i2) {
          var last;
          if (i2 + 1 === input.length)
            last = end;
          add(value, last);
        });
      } else {
        add(input, end);
      }
      if (stream) {
        stream.readable = true;
        return stream;
      }
      return output;
    }
    function element() {
      var input = Array.prototype.slice.call(arguments), self2 = {
        _elem: resolve2(input)
      };
      self2.push = function(input2) {
        if (!this.append) {
          throw new Error("not assigned to a parent!");
        }
        var that = this;
        var indent = this._elem.indent;
        format3(this.append, resolve2(input2, indent, this._elem.icount + (indent ? 1 : 0)), function() {
          that.append(true);
        });
      };
      self2.close = function(input2) {
        if (input2 !== void 0) {
          this.push(input2);
        }
        if (this.end) {
          this.end();
        }
      };
      return self2;
    }
    function create_indent(character, count) {
      return new Array(count || 0).join(character || "");
    }
    function resolve2(data, indent, indent_count) {
      indent_count = indent_count || 0;
      var indent_spaces = create_indent(indent, indent_count);
      var name;
      var values = data;
      var interrupt = false;
      if (typeof data === "object") {
        var keys = Object.keys(data);
        name = keys[0];
        values = data[name];
        if (values && values._elem) {
          values._elem.name = name;
          values._elem.icount = indent_count;
          values._elem.indent = indent;
          values._elem.indents = indent_spaces;
          values._elem.interrupt = values;
          return values._elem;
        }
      }
      var attributes = [], content = [];
      var isStringContent;
      function get_attributes(obj) {
        var keys2 = Object.keys(obj);
        keys2.forEach(function(key2) {
          attributes.push(attribute(key2, obj[key2]));
        });
      }
      switch (typeof values) {
        case "object":
          if (values === null)
            break;
          if (values._attr) {
            get_attributes(values._attr);
          }
          if (values._cdata) {
            content.push(("<![CDATA[" + values._cdata).replace(/\]\]>/g, "]]]]><![CDATA[>") + "]]>");
          }
          if (values.forEach) {
            isStringContent = false;
            content.push("");
            values.forEach(function(value) {
              if (typeof value == "object") {
                var _name2 = Object.keys(value)[0];
                if (_name2 == "_attr") {
                  get_attributes(value._attr);
                } else {
                  content.push(resolve2(value, indent, indent_count + 1));
                }
              } else {
                content.pop();
                isStringContent = true;
                content.push(escapeForXML(value));
              }
            });
            if (!isStringContent) {
              content.push("");
            }
          }
          break;
        default:
          content.push(escapeForXML(values));
      }
      return {
        name,
        interrupt,
        attributes,
        content,
        icount: indent_count,
        indents: indent_spaces,
        indent
      };
    }
    function format3(append, elem, end) {
      if (typeof elem != "object") {
        return append(false, elem);
      }
      var len = elem.interrupt ? 1 : elem.content.length;
      function proceed() {
        while (elem.content.length) {
          var value = elem.content.shift();
          if (value === void 0)
            continue;
          if (interrupt(value))
            return;
          format3(append, value);
        }
        append(false, (len > 1 ? elem.indents : "") + (elem.name ? "</" + elem.name + ">" : "") + (elem.indent && !end ? "\n" : ""));
        if (end) {
          end();
        }
      }
      function interrupt(value) {
        if (value.interrupt) {
          value.interrupt.append = append;
          value.interrupt.end = proceed;
          value.interrupt = false;
          append(true);
          return true;
        }
        return false;
      }
      append(false, elem.indents + (elem.name ? "<" + elem.name : "") + (elem.attributes.length ? " " + elem.attributes.join(" ") : "") + (len ? elem.name ? ">" : "" : elem.name ? "/>" : "") + (elem.indent && len > 1 ? "\n" : ""));
      if (!len) {
        return append(false, elem.indent ? "\n" : "");
      }
      if (!interrupt(elem)) {
        proceed();
      }
    }
    function attribute(key2, value) {
      return key2 + '="' + escapeForXML(value) + '"';
    }
    module2.exports = xml;
    module2.exports.element = module2.exports.Element = element;
  }
});

// node_modules/rss/lib/index.js
var require_lib = __commonJS({
  "node_modules/rss/lib/index.js"(exports, module2) {
    "use strict";
    var mime = require_mime_types();
    var xml = require_xml();
    var fs = require("fs");
    function ifTruePush(bool, array, data) {
      if (bool) {
        array.push(data);
      }
    }
    function ifTruePushArray(bool, array, dataArray) {
      if (!bool) {
        return;
      }
      dataArray.forEach(function(item) {
        ifTruePush(item, array, item);
      });
    }
    function getSize(filename) {
      if (typeof fs === "undefined") {
        return 0;
      }
      return fs.statSync(filename).size;
    }
    function generateXML(data) {
      var channel = [];
      channel.push({ title: { _cdata: data.title } });
      channel.push({ description: { _cdata: data.description || data.title } });
      channel.push({ link: data.site_url || "http://github.com/dylang/node-rss" });
      if (data.image_url) {
        channel.push({ image: [{ url: data.image_url }, { title: data.title }, { link: data.site_url }] });
      }
      channel.push({ generator: data.generator });
      channel.push({ lastBuildDate: new Date().toUTCString() });
      ifTruePush(data.feed_url, channel, { "atom:link": { _attr: { href: data.feed_url, rel: "self", type: "application/rss+xml" } } });
      ifTruePush(data.author, channel, { "author": { _cdata: data.author } });
      ifTruePush(data.pubDate, channel, { "pubDate": new Date(data.pubDate).toGMTString() });
      ifTruePush(data.copyright, channel, { "copyright": { _cdata: data.copyright } });
      ifTruePush(data.language, channel, { "language": { _cdata: data.language } });
      ifTruePush(data.managingEditor, channel, { "managingEditor": { _cdata: data.managingEditor } });
      ifTruePush(data.webMaster, channel, { "webMaster": { _cdata: data.webMaster } });
      ifTruePush(data.docs, channel, { "docs": data.docs });
      ifTruePush(data.ttl, channel, { "ttl": data.ttl });
      ifTruePush(data.hub, channel, { "atom:link": { _attr: { href: data.hub, rel: "hub" } } });
      if (data.categories) {
        data.categories.forEach(function(category) {
          ifTruePush(category, channel, { category: { _cdata: category } });
        });
      }
      ifTruePushArray(data.custom_elements, channel, data.custom_elements);
      data.items.forEach(function(item) {
        var item_values = [
          { title: { _cdata: item.title } }
        ];
        ifTruePush(item.description, item_values, { description: { _cdata: item.description } });
        ifTruePush(item.url, item_values, { link: item.url });
        ifTruePush(item.link || item.guid || item.title, item_values, { guid: [{ _attr: { isPermaLink: !item.guid && !!item.url } }, item.guid || item.url || item.title] });
        item.categories.forEach(function(category) {
          ifTruePush(category, item_values, { category: { _cdata: category } });
        });
        ifTruePush(item.author || data.author, item_values, { "dc:creator": { _cdata: item.author || data.author } });
        ifTruePush(item.date, item_values, { pubDate: new Date(item.date).toGMTString() });
        data.geoRSS = data.geoRSS || item.lat && item.long;
        ifTruePush(item.lat, item_values, { "geo:lat": item.lat });
        ifTruePush(item.long, item_values, { "geo:long": item.long });
        if (item.enclosure && item.enclosure.url) {
          if (item.enclosure.file) {
            item_values.push({
              enclosure: {
                _attr: {
                  url: item.enclosure.url,
                  length: item.enclosure.size || getSize(item.enclosure.file),
                  type: item.enclosure.type || mime.lookup(item.enclosure.file)
                }
              }
            });
          } else {
            item_values.push({
              enclosure: {
                _attr: {
                  url: item.enclosure.url,
                  length: item.enclosure.size || 0,
                  type: item.enclosure.type || mime.lookup(item.enclosure.url)
                }
              }
            });
          }
        }
        ifTruePushArray(item.custom_elements, item_values, item.custom_elements);
        channel.push({ item: item_values });
      });
      var _attr = {
        "xmlns:dc": "http://purl.org/dc/elements/1.1/",
        "xmlns:content": "http://purl.org/rss/1.0/modules/content/",
        "xmlns:atom": "http://www.w3.org/2005/Atom",
        version: "2.0"
      };
      Object.keys(data.custom_namespaces).forEach(function(name) {
        _attr["xmlns:" + name] = data.custom_namespaces[name];
      });
      if (data.geoRSS) {
        _attr["xmlns:geo"] = "http://www.w3.org/2003/01/geo/wgs84_pos#";
      }
      return {
        rss: [
          { _attr },
          { channel }
        ]
      };
    }
    function RSS2(options, items) {
      options = options || {};
      this.title = options.title || "Untitled RSS Feed";
      this.description = options.description || "";
      this.generator = options.generator || "RSS for Node";
      this.feed_url = options.feed_url;
      this.site_url = options.site_url;
      this.image_url = options.image_url;
      this.author = options.author;
      this.categories = options.categories;
      this.pubDate = options.pubDate;
      this.hub = options.hub;
      this.docs = options.docs;
      this.copyright = options.copyright;
      this.language = options.language;
      this.managingEditor = options.managingEditor;
      this.webMaster = options.webMaster;
      this.ttl = options.ttl;
      this.geoRSS = options.geoRSS || false;
      this.custom_namespaces = options.custom_namespaces || {};
      this.custom_elements = options.custom_elements || [];
      this.items = items || [];
      this.item = function(options2) {
        options2 = options2 || {};
        var item = {
          title: options2.title || "No title",
          description: options2.description || "",
          url: options2.url,
          guid: options2.guid,
          categories: options2.categories || [],
          author: options2.author,
          date: options2.date,
          lat: options2.lat,
          long: options2.long,
          enclosure: options2.enclosure || false,
          custom_elements: options2.custom_elements || []
        };
        this.items.push(item);
        return this;
      };
      this.xml = function(indent) {
        return '<?xml version="1.0" encoding="UTF-8"?>' + xml(generateXML(this), indent);
      };
    }
    module2.exports = RSS2;
  }
});

// .svelte-kit/output/server/chunks/_query-97d68e29.js
function getOfficerByGhUsername(ghUsername) {
  const officer = OFFICERS.find((o) => o.displayName !== void 0 && o.displayName === ghUsername);
  return officer ?? null;
}
function formatNewsletters(output) {
  const discussions = output.data.repository.discussions.nodes;
  return discussions.map((discussion) => {
    const {
      title,
      author,
      createdAt,
      lastEditedAt: lastEdited,
      number: id,
      bodyHTML: html,
      url: discussionUrl
    } = discussion;
    const url = "/blog/" + id;
    const labels = discussion.labels.nodes.map(({ name }) => name);
    const officer = getOfficerByGhUsername(author.login);
    const authorUrl = author.url;
    const displayname = (officer == null ? void 0 : officer.fullName) ?? author.login;
    const picture = (officer == null ? void 0 : officer.picture) ?? author.avatarUrl;
    return {
      id,
      url,
      discussionUrl,
      title,
      html,
      createdAt,
      lastEdited,
      labels,
      author: { url: authorUrl, displayname, picture }
    };
  });
}
async function fetchNewsletters() {
  const ghAccessToken = {}.VITE_GH_ACCESS_TOKEN;
  const response = await fetch("https://api.github.com/graphql", {
    method: "POST",
    headers: { Authorization: `token ${ghAccessToken}`, "Content-Type": "application/json" },
    body: JSON.stringify({ query: newslettersQuery })
  });
  const newsletters = formatNewsletters(await response.json());
  return newsletters.sort((a, b) => {
    return new Date(b.createdAt).valueOf() - new Date(a.createdAt).valueOf();
  });
}
var newslettersQuery;
var init_query_97d68e29 = __esm({
  ".svelte-kit/output/server/chunks/_query-97d68e29.js"() {
    init_index_ba3ba78e();
    init_officers_1f1dc4ef();
    newslettersQuery = `{
  repository(owner: "ethanthatonekid", name: "acmcsuf.com") {
    discussions(first: 100, categoryId: "${{}.VITE_GH_DISCUSSION_CATEGORY_ID}") {
      nodes {
        title
        url
        number
        bodyHTML
        createdAt
        lastEditedAt
        
        author {
          login
          url
          avatarUrl
        }
        
        labels(first: 100) {
          nodes {
            name
          }
        }
      }
    }
  }
}`;
  }
});

// .svelte-kit/output/server/entries/endpoints/blog/index.xml.ts.js
var index_xml_ts_exports = {};
__export(index_xml_ts_exports, {
  get: () => get3
});
function getCategories(posts2) {
  const categories = /* @__PURE__ */ new Set();
  for (const newsletter of posts2) {
    for (const label of newsletter.labels) {
      categories.add(label);
    }
  }
  return Array.from(categories);
}
function truncateDescription(description, length) {
  const indexOfEndOfLastWord = description.lastIndexOf(" ", length);
  return description.slice(0, indexOfEndOfLastWord);
}
function makeRssFeed(posts2) {
  const feed = new import_rss.default({
    title: "acmCSUF README",
    description: "Posts written about computer science topics by the ACM community at California State Univerity Fullerton. It covers all the latest news and events for acmCSUF.",
    feed_url: "https://acmcsuf.com/blog.xml",
    site_url: "https://acmcsuf.com",
    image_url: "https://acmcsuf.com/assets/png/acm-csuf-badge.png",
    categories: getCategories(posts2),
    pubDate: "Jan 24, 2022 08:00:00 GMT",
    docs: "https://acmcsuf.com/history-of-rss",
    copyright: "2022 acmCSUF",
    language: "en",
    managingEditor: "mikeploythai",
    webMaster: "EthanThatOneKid",
    ttl: 60
  });
  for (const newsletter of posts2) {
    feed.item({
      title: newsletter.title,
      description: truncateDescription(newsletter.html, 250),
      url: newsletter.url,
      categories: newsletter.labels,
      author: newsletter.author.displayname,
      date: new Date(newsletter.lastEdited).toISOString()
    });
  }
  return feed.xml({ indent: " ".repeat(2) });
}
async function get3() {
  return new Response(JSON.stringify(makeRssFeed(await fetchNewsletters())), {
    status: 200,
    headers: { "Cache-Control": "max-age=0, s-maxage=3600", "Content-Type": "application/xml" }
  });
}
var import_rss;
var init_index_xml_ts = __esm({
  ".svelte-kit/output/server/entries/endpoints/blog/index.xml.ts.js"() {
    import_rss = __toESM(require_lib(), 1);
    init_query_97d68e29();
    init_index_ba3ba78e();
    init_officers_1f1dc4ef();
  }
});

// .svelte-kit/output/server/entries/endpoints/blog/index.json.ts.js
var index_json_ts_exports2 = {};
__export(index_json_ts_exports2, {
  get: () => get4
});
async function get4() {
  const isSatisfied = {}.VITE_GH_ACCESS_TOKEN !== void 0 && {}.VITE_GH_DISCUSSION_CATEGORY_ID !== void 0;
  return new Response(DEBUG || !isSatisfied ? SAMPLE_POSTS : JSON.stringify(await fetchNewsletters()), {
    status: 200,
    headers: { "Content-Type": "application/json" }
  });
}
var posts, SAMPLE_POSTS;
var init_index_json_ts2 = __esm({
  ".svelte-kit/output/server/entries/endpoints/blog/index.json.ts.js"() {
    init_query_97d68e29();
    init_index_ba3ba78e();
    init_officers_1f1dc4ef();
    posts = [
      {
        id: 491,
        url: "/blog/491",
        discussionUrl: "https://github.com/EthanThatOneKid/acmcsuf.com/discussions/491",
        title: "What's poppin in acmcsuf.com v3.0?",
        html: `<h1 dir="auto"><a href="https://acmcsuf.com/" rel="nofollow"><code class="notranslate">acmcsuf.com</code></a> v3.0</h1>
<p dir="auto">This release marks the completion of the ACM CSUF website <a href="https://github.com/EthanThatOneKid/acmcsuf.com/milestone/3">v3.0 milestone <g-emoji class="g-emoji" alias="dizzy" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4ab.png">\u{1F4AB}</g-emoji></a></p>
<h2 dir="auto">Spring '22 semester sprint</h2>
<ul dir="auto">
<li><strong>Contributors</strong>: <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a>, <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/anhduy1202/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/anhduy1202">@anhduy1202</a>, <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/MohamedHabarneh/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/MohamedHabarneh">@MohamedHabarneh</a>, <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/adityashah6/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/adityashah6">@adityashah6</a>, <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/janiljohn/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/janiljohn">@janiljohn</a>, <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/jaasonw/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/jaasonw">@jaasonw</a>, <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/Angus-1/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/Angus-1">@Angus-1</a>, <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/hhoang91/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/hhoang91">@hhoang91</a>, <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/karnikaavelumani/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/karnikaavelumani">@karnikaavelumani</a>, <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/NLTN/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/NLTN">@NLTN</a>, <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/TRA3H/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/TRA3H">@TRA3H</a>, <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/AaronLieb/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/AaronLieb">@AaronLieb</a>, <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/Angel-Armendariz/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/Angel-Armendariz">@Angel-Armendariz</a></li>
<li><strong>Project Board</strong>: <a href="https://github.com/EthanThatOneKid/acmcsuf.com/projects/3">https://github.com/EthanThatOneKid/acmcsuf.com/projects/3</a></li>
<li><strong>Reflection</strong>: We learned how to learn from one another by participating in the code review cycle on GitHub, suggesting ideas, or asking questions during coding sessions or on Discord.</li>
</ul>
<h2 dir="auto">Contributors</h2>
<p dir="auto">During the Spring 2022 school semester, the acmcsuf.com team accomplished another great number of feats. This semester we gained an additional 8 new members to the web dev team! Each contributor got a step closer into the field of website development and through this experience, they can take this knowledge to further improve their skills. Thank you to everyone for the contributions!</p>
<h3 dir="auto">New to acmcsuf.com hub</h3>
<ul dir="auto">
<li><a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/github-actions/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/github-actions">@github-actions</a> made their first contribution in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1144523196" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/300" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/300/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/300">#300</a></li>
<li><a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/jaasonw/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/jaasonw">@jaasonw</a> made their first contribution in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1177198669" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/359" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/359/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/359">#359</a></li>
<li><a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/Angus-1/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/Angus-1">@Angus-1</a> made their first contribution in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1181374645" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/397" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/397/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/397">#397</a></li>
<li><a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/hhoang91/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/hhoang91">@hhoang91</a> made their first contribution in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1205965818" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/433" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/433/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/433">#433</a></li>
<li><a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/karnikaavelumani/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/karnikaavelumani">@karnikaavelumani</a> made their first contribution in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1209135137" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/444" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/444/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/444">#444</a></li>
<li><a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/NLTN/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/NLTN">@NLTN</a> made their first contribution in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1206812558" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/439" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/439/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/439">#439</a></li>
<li><a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/TRA3H/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/TRA3H">@TRA3H</a> made their first contribution in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1221676156" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/457" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/457/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/457">#457</a></li>
<li><a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/AaronLieb/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/AaronLieb">@AaronLieb</a> made their first contribution in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1223268685" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/460" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/460/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/460">#460</a></li>
<li><a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/Angel-Armendariz/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/Angel-Armendariz">@Angel-Armendariz</a> made their first contribution in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1221914644" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/458" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/458/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/458">#458</a></li>
</ul>
<p dir="auto">If you are interested in following along with us and becoming an acmcsuf.com v4.0 contributor, just watch out for any announcements on our blog (<a href="https://acmcsuf.com/blog" rel="nofollow">https://acmcsuf.com/blog</a>) or the acmCSUF Discord server.</p>
<h2 dir="auto">What's Changed</h2>
<ul dir="auto">
<li>Added createdAt to plaintext blogpost metadata by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1113422348" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/276" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/276/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/276">#276</a></li>
<li>Removed <code class="notranslate">async</code> from non-async function in close-issue-channel.js by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1125367366" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/283" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/283/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/283">#283</a></li>
<li>Hotfix "Removed <code class="notranslate">async</code> from non-async function in close-issue-channel.js" by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1127953671" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/284" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/284/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/284">#284</a></li>
<li>Make EventCarousel a vertical list by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/diamondburned/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/diamondburned">@diamondburned</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1123599598" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/280" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/280/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/280">#280</a></li>
<li>Added workflow step to check for formatting in PRs by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1132294951" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/290" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/290/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/290">#290</a></li>
<li>Add DST check in ICAL parser by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1132223706" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/289" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/289/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/289">#289</a></li>
<li>Events: Join from new tab by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1133714295" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/293" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/293/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/293">#293</a></li>
<li>Events: Migrated from CSR to SSR in SvelteKit by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1132209137" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/288" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/288/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/288">#288</a></li>
<li>Add/Update officer Jacob Nguyen by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/github-actions/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/github-actions">@github-actions</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1144523196" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/300" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/300/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/300">#300</a></li>
<li>Officer Automation: Disabled issue closing and minor bugfixes by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1144541591" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/301" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/301/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/301">#301</a></li>
<li>Added special colors to event items based on which path is hosting <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="790351804" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/2" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/2/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/2">#2</a> by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1144357804" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/298" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/298/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/298">#298</a></li>
<li>Only send messages in open issue channels by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1132382892" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/291" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/291/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/291">#291</a></li>
<li>Added Intro to Figma project link by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/mikeploythai/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mikeploythai">@mikeploythai</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1146368765" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/304" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/304/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/304">#304</a></li>
<li>Combined format and lint check by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1147313147" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/306" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/306/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/306">#306</a></li>
<li>Updated Discord link, removed unnecessary links by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/mikeploythai/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mikeploythai">@mikeploythai</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1152397281" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/308" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/308/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/308">#308</a></li>
<li>Added action that copies event link to clipboard by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1156708294" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/311" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/311/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/311">#311</a></li>
<li>Fixed button hover effect by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1159083244" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/314" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/314/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/314">#314</a></li>
<li>Adding PWA support by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1159126652" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/316" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/316/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/316">#316</a></li>
<li>Added <code class="notranslate">npm run all</code> <g-emoji class="g-emoji" alias="man_technologist" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f468-1f4bb.png">\u{1F468}\u200D\u{1F4BB}</g-emoji> by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1159248675" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/319" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/319/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/319">#319</a></li>
<li>Update ARCHITECTURE.md by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1159253986" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/320" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/320/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/320">#320</a></li>
<li>Set up network-first service worker by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1159420562" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/321" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/321/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/321">#321</a></li>
<li>Added "copy title" action by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1159100061" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/315" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/315/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/315">#315</a></li>
<li>Add/Update officer Daniel Truong by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/github-actions/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/github-actions">@github-actions</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1160140685" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/325" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/325/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/325">#325</a></li>
<li>Events: Added "add to calendar" actions to each event item by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1159203498" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/318" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/318/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/318">#318</a></li>
<li>Officer List: Integrated tier-based ordering by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1160719470" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/326" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/326/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/326">#326</a></li>
<li>Events: Force long words to break in event item description by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1167206587" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/331" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/331/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/331">#331</a></li>
<li>Fixing button hover effect by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/anhduy1202/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/anhduy1202">@anhduy1202</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1168720052" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/338" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/338/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/338">#338</a></li>
<li>Add/Update officer Angel Armendariz by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/github-actions/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/github-actions">@github-actions</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1169227423" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/343" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/343/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/343">#343</a></li>
<li>Add/Update officer Jason Wong by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/github-actions/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/github-actions">@github-actions</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1169141130" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/341" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/341/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/341">#341</a></li>
<li>Revert "Events: Force long words to break in event item description" by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1169271473" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/344" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/344/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/344">#344</a></li>
<li>Events: Force long words to break in event item description pt. 2 by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1169282634" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/345" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/345/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/345">#345</a></li>
<li>Resolved annoying 'css-unused-selector' warning messages by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1167246912" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/333" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/333/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/333">#333</a></li>
<li>Add/Update officer diamondburned by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/github-actions/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/github-actions">@github-actions</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1170648582" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/350" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/350/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/350">#350</a></li>
<li>Set up Vitest and added some tests by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1167517249" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/337" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/337/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/337">#337</a></li>
<li>Show set amount of events on <code class="notranslate">acmcsuf.com/events</code> when DEBUG=1 by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1167202208" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/329" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/329/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/329">#329</a></li>
<li>Integrating dark and light mode <g-emoji class="g-emoji" alias="tada" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png">\u{1F389}</g-emoji> by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1172875587" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/352" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/352/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/352">#352</a></li>
<li>Add/Update officer Ibrahim Israr by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/github-actions/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/github-actions">@github-actions</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1177286542" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/361" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/361/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/361">#361</a></li>
<li>Add/Update officer Stephanie Pocci by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/github-actions/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/github-actions">@github-actions</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1177292668" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/363" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/363/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/363">#363</a></li>
<li>Add/Update officer Nurhaliza Hassan by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/github-actions/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/github-actions">@github-actions</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1177294098" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/365" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/365/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/365">#365</a></li>
<li>Add/Update officer Nolan Lee by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/github-actions/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/github-actions">@github-actions</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1177297205" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/367" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/367/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/367">#367</a></li>
<li>Add/Update officer Justin Stitt by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/github-actions/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/github-actions">@github-actions</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1177302247" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/370" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/370/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/370">#370</a></li>
<li>Add/Update officer Iftekharul Islam by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/github-actions/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/github-actions">@github-actions</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1177308670" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/372" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/372/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/372">#372</a></li>
<li>Add/Update officer Sami Bajwa by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/github-actions/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/github-actions">@github-actions</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1177329104" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/374" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/374/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/374">#374</a></li>
<li>Add/Update officer Alan Cortez by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/github-actions/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/github-actions">@github-actions</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1177333036" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/376" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/376/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/376">#376</a></li>
<li>Add/Update officer Kirsten Ochoa by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/github-actions/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/github-actions">@github-actions</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1177334544" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/378" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/378/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/378">#378</a></li>
<li>Add/Update officer Minh Le by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/github-actions/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/github-actions">@github-actions</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1177335794" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/380" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/380/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/380">#380</a></li>
<li>Add/Update officer Justin Stitt by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/github-actions/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/github-actions">@github-actions</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1177344254" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/381" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/381/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/381">#381</a></li>
<li>Add/Update officer Joel Anil John by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/github-actions/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/github-actions">@github-actions</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1177346137" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/383" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/383/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/383">#383</a></li>
<li>Add/Update officer Rina Watanabe by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/github-actions/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/github-actions">@github-actions</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1177357805" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/386" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/386/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/386">#386</a></li>
<li>Add/Update officer Johnathan Carranza by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/github-actions/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/github-actions">@github-actions</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1177359978" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/388" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/388/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/388">#388</a></li>
<li>Add/Update officer Alex Truong by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/github-actions/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/github-actions">@github-actions</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1177360767" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/390" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/390/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/390">#390</a></li>
<li>1 high severity vulnerability btw by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/jaasonw/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/jaasonw">@jaasonw</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1177198669" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/359" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/359/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/359">#359</a></li>
<li>remove extra name property by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/jaasonw/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/jaasonw">@jaasonw</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1174773340" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/357" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/357/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/357">#357</a></li>
<li>HBD AARON <g-emoji class="g-emoji" alias="crown" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f451.png">\u{1F451}</g-emoji> by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/mikeploythai/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mikeploythai">@mikeploythai</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1181217637" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/395" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/395/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/395">#395</a></li>
<li>Change color of officer title prefixes only by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/Angus-1/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/Angus-1">@Angus-1</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1181374645" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/397" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/397/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/397">#397</a></li>
<li>Darkmode: Fixed initial flash of light <g-emoji class="g-emoji" alias="camera_flash" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4f8.png">\u{1F4F8}</g-emoji> by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1181350151" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/396" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/396/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/396">#396</a></li>
<li>Events: Migrated custom ICAL parser from <code class="notranslate">Date</code> to <code class="notranslate">Temporal</code> API by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1178801269" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/391" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/391/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/391">#391</a></li>
<li>Implemented Svelte style directive where applicable by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1174386495" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/353" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/353/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/353">#353</a></li>
<li>Minor design tweaks by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/mikeploythai/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mikeploythai">@mikeploythai</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1182288275" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/405" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/405/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/405">#405</a></li>
<li>Nav bar and footer refactor by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/mikeploythai/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mikeploythai">@mikeploythai</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1182283889" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/401" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/401/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/401">#401</a></li>
<li>Revert "Minor design tweaks" by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/jaasonw/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/jaasonw">@jaasonw</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1188986724" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/412" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/412/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/412">#412</a></li>
<li>Added '/create-html/ link by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/mikeploythai/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mikeploythai">@mikeploythai</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1194894595" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/421" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/421/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/421">#421</a></li>
<li>Added replaceHtmlWithExternalLinks function to utils.ts by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/janiljohn/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/janiljohn">@janiljohn</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1205897219" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/431" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/431/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/431">#431</a></li>
<li>Updates dependencies by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/MohamedHabarneh/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/MohamedHabarneh">@MohamedHabarneh</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1205954459" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/432" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/432/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/432">#432</a></li>
<li>Updated version to 2.0.0 by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/MohamedHabarneh/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/MohamedHabarneh">@MohamedHabarneh</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1185175809" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/409" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/409/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/409">#409</a></li>
<li>Index refactor by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/mikeploythai/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mikeploythai">@mikeploythai</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1206485778" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/437" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/437/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/437">#437</a></li>
<li>Footer tweaks by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/mikeploythai/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mikeploythai">@mikeploythai</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1206457212" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/436" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/436/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/436">#436</a></li>
<li>fixed the logo path by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/hhoang91/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/hhoang91">@hhoang91</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1205965818" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/433" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/433/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/433">#433</a></li>
<li>Nav design tweaks by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/mikeploythai/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mikeploythai">@mikeploythai</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1206453756" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/435" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/435/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/435">#435</a></li>
<li>Added /apply link by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/mikeploythai/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mikeploythai">@mikeploythai</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1207280755" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/440" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/440/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/440">#440</a></li>
<li>"This week's event" changed to "Upcoming Events" by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/karnikaavelumani/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/karnikaavelumani">@karnikaavelumani</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1209135137" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/444" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/444/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/444">#444</a></li>
<li>Fix/441 by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/karnikaavelumani/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/karnikaavelumani">@karnikaavelumani</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1209212621" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/446" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/446/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/446">#446</a></li>
<li>About refactor by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/mikeploythai/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mikeploythai">@mikeploythai</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1207499456" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/442" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/442/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/442">#442</a></li>
<li>Updated page title by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/NLTN/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/NLTN">@NLTN</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1206812558" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/439" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/439/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/439">#439</a></li>
<li>Added QR Code feature  by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/Angus-1/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/Angus-1">@Angus-1</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1213039277" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/450" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/450/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/450">#450</a></li>
<li>Links in events description open in new tab by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/janiljohn/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/janiljohn">@janiljohn</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1216863066" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/453" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/453/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/453">#453</a></li>
<li>enlarged font size on paths route by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/TRA3H/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/TRA3H">@TRA3H</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1221676156" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/457" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/457/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/457">#457</a></li>
<li>f22apply by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/AaronLieb/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/AaronLieb">@AaronLieb</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1223268685" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/460" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/460/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/460">#460</a></li>
<li>Changed padding to make all link area clickable in Blog by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/hhoang91/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/hhoang91">@hhoang91</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1230197888" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/463" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/463/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/463">#463</a></li>
<li>Removed <code class="notranslate">DEBUG</code> from parse() by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1233247677" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/465" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/465/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/465">#465</a></li>
<li>Show sample data on blog by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/MohamedHabarneh/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/MohamedHabarneh">@MohamedHabarneh</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1213565355" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/451" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/451/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/451">#451</a></li>
<li>Removed calendar emoji and replaced with blue calendar SVG by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/karnikaavelumani/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/karnikaavelumani">@karnikaavelumani</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1236153245" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/469" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/469/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/469">#469</a></li>
<li>Renamed src/routes/blog/_testdata/posts.json \u2192 posts.ts by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1236389648" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/472" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/472/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/472">#472</a></li>
<li>Events: Set up simple ICAL parser integration testing by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1241459342" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/475" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/475/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/475">#475</a></li>
<li>Update CONTRIBUTING.md by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/MohamedHabarneh/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/MohamedHabarneh">@MohamedHabarneh</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1219083694" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/454" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/454/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/454">#454</a></li>
<li>Replaced old 404 image with blank frank picture and text by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/Angel-Armendariz/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/Angel-Armendariz">@Angel-Armendariz</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1221914644" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/458" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/458/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/458">#458</a></li>
</ul>
<p dir="auto"><strong>Full Changelog</strong>: <a class="commit-link" href="https://github.com/EthanThatOneKid/acmcsuf.com/compare/v2.0...v3.0"><tt>v2.0...v3.0</tt></a><br>
<strong>GitHub Discussion (Mirror)</strong>: <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="4114741" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/discussions/491" data-hovercard-type="discussion" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/discussions/491/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/discussions/491">#491</a><br>
<strong>Blog Post on acmcsuf.com (Mirror)</strong>: <a href="https://acmcsuf.com/blog/491" rel="nofollow">https://acmcsuf.com/blog/491</a><br>
<strong>GitHub Release (Original post)</strong>: <a href="https://github.com/EthanThatOneKid/acmcsuf.com/releases/tag/v3.0">https://github.com/EthanThatOneKid/acmcsuf.com/releases/tag/v3.0</a></p>
<hr><em>This discussion was created from the release <a href="https://github.com/EthanThatOneKid/acmcsuf.com/releases/tag/v3.0">What's poppin in acmcsuf.com v3.0?</a>.</em>`,
        createdAt: "2022-06-02T07:01:19Z",
        lastEdited: "2022-06-02T07:11:44Z",
        labels: [],
        author: {
          url: "https://github.com/karnikaavelumani",
          displayname: "karnikaavelumani",
          picture: "https://avatars.githubusercontent.com/u/60043611?u=cc6df12480c211fef382ee737ceb7aef256610d1&v=4"
        }
      },
      {
        id: 490,
        url: "/blog/480",
        discussionUrl: "https://github.com/EthanThatOneKid/acmcsuf.com/discussions/480",
        title: "Git Good #1: Rewriting History",
        html: `<div class="highlight highlight-source-ts notranslate position-relative overflow-auto">
<pre>
<span class="pl-k">export</span> <span class="pl-k">function</span> <span class="pl-en">readingTime</span><span class="pl-kos">(</span><span class="pl-s1">blogContent</span>: <span class="pl-smi">string</span><span class="pl-kos">,</span> <span class="pl-s1">wpm</span> <span class="pl-c1">=</span> <span class="pl-c1">225</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
  <span class="pl-c">// Regex taken from https://stackoverflow.com/a/5002161</span>
  <span class="pl-k">const</span> <span class="pl-s1">text</span> <span class="pl-c1">=</span> <span class="pl-s1">blogContent</span><span class="pl-kos">.</span><span class="pl-en">replace</span><span class="pl-kos">(</span><span class="pl-pds"><span class="pl-c1">/</span>&amp;lt;<span class="pl-cce">\\</span><span class="pl-c1">/</span></span>?<span class="pl-kos">[</span><span class="pl-c1">^</span><span class="pl-c1">&amp;</span><span class="pl-s1">gt</span><span class="pl-kos">;</span><span class="pl-kos">]</span><span class="pl-c1">+</span><span class="pl-kos">(</span><span class="pl-c1">&amp;</span><span class="pl-s1">gt</span><span class="pl-kos">;</span><span class="pl-c1">|</span><span class="pl-s1">$</span><span class="pl-kos">)</span><span class="pl-c1">/</span><span class="pl-kos">,</span> <span class="pl-s">''</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-en">trim</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
  <span class="pl-k">return</span> <span class="pl-smi">Math</span><span class="pl-kos">.</span><span class="pl-en">ceil</span><span class="pl-kos">(</span><span class="pl-s1">text</span><span class="pl-kos">.</span><span class="pl-en">split</span><span class="pl-kos">(</span><span class="pl-pds"><span class="pl-c1">/</span><span class="pl-cce">\\</span>s<span class="pl-c1">+</span><span class="pl-c1">/</span></span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-c1">length</span> <span class="pl-c1">/</span> <span class="pl-s1">wpm</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
<span class="pl-kos">}</span>
</pre>
</div>


<p dir="auto">asdasdasfdf <code class="notranslate">asdasff</code>asdasdasd as</p>`,
        createdAt: "2022-05-23T05:11:12Z",
        lastEdited: "2022-05-23T11:17:14Z",
        labels: [],
        author: {
          url: "https://github.com/jaasonw",
          displayname: "jaasonw",
          picture: "https://avatars.githubusercontent.com/u/8981287?u=4bf37a144d65af7f4d6aa1616fd734f83b566fac&v=4"
        }
      },
      {
        id: 480,
        url: "/blog/480",
        discussionUrl: "https://github.com/EthanThatOneKid/acmcsuf.com/discussions/480",
        title: "Git Good #1: Rewriting History",
        html: `<p dir="auto">Welcome to part 1 out of ??? of my git series (super original title I know) covering slightly intermediate to advanced topics that you may or may not have been familiar with. I figured what better way to start this series than by covering some of what are possibly the most dangerous commands in git and when you might want to use them. This blog post will cover 2 methods to rewrite history.</p>
<p dir="auto"><strong>WARNING</strong>: you almost NEVER want to rewrite history as it tends to end up being a great way to either shoot yourself in the foot, shoot someone else in the foot, or blow off the legs of everybody involved. If this is your own repository and you are the only contributor, then by all means, go off. If this is someone else\u2019s repository then you should reconsider or instead consider using a <strong>git revert</strong> instead as it amends rather than rewrites history. However, if your intent is to erase commits from the commit log entirely then this guide is for you.</p>
<h2 dir="auto">Scenario 1: You want to rewind to a specific commit, nuking all newer commits</h2>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/8981287/169747149-2005f139-aad5-447e-8628-e899551f6439.png"><img src="https://user-images.githubusercontent.com/8981287/169747149-2005f139-aad5-447e-8628-e899551f6439.png" alt="image" style="max-width: 100%;"></a><br>
What\u2019s this? You accidentally directly pushed to the acmcsuf.com main branch and are now panicking because Karni might beat your ass the next time she sees you? Well there\u2019s no need to fear because this is where dangerous git command # 1 comes into play.</p>
<h3 dir="auto">git reset --hard</h3>
<ol dir="auto">
<li>
<p dir="auto">Head over to Github and copy the SHA of the commit you want to rewind to<br>
<a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/8981287/169747276-71967553-5bdb-4645-b5bd-f1ac81369f80.png"><img src="https://user-images.githubusercontent.com/8981287/169747276-71967553-5bdb-4645-b5bd-f1ac81369f80.png" alt="image" style="max-width: 100%;"></a></p>
</li>
<li>
<p dir="auto">Head over to your terminal and run <strong>git reset --hard [SHA]</strong>. This will rewind your local copy of the repository to the commit you want, discarding ALL modified changes. If you\u2019d still like to keep the changes without committing them, just exclude the --hard<br>
<a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/8981287/169747313-fee0a649-a241-4837-80fd-289b0e90325e.png"><img src="https://user-images.githubusercontent.com/8981287/169747313-fee0a649-a241-4837-80fd-289b0e90325e.png" alt="image" style="max-width: 100%;"></a></p>
</li>
<li>
<p dir="auto">If you tried to git push now, your changes would be rejected as they would rewrite history in the upstream copy<br>
<a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/8981287/169747465-e74b5f6e-5c81-4faa-93ce-bac802f3097a.png"><img src="https://user-images.githubusercontent.com/8981287/169747465-e74b5f6e-5c81-4faa-93ce-bac802f3097a.png" alt="image" style="max-width: 100%;"></a></p>
</li>
<li>
<p dir="auto">To remedy this, simply run dangerous git command # 2: <strong>git push --force</strong> which should be pretty self explanatory in what it does, which is to force git to accept your changes whether it likes it or not<br>
<a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/8981287/169747506-3a27b5a3-e4cb-4b20-8eb4-590ac995895b.png"><img src="https://user-images.githubusercontent.com/8981287/169747506-3a27b5a3-e4cb-4b20-8eb4-590ac995895b.png" alt="image" style="max-width: 100%;"></a></p>
</li>
</ol>
<p dir="auto">As you can see, our commits are now gone and your ass is now saved from Karni</p>
<h2 dir="auto">Scenario 2: You want to remove a specific commit or multiple commits but keep the rest</h2>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/8981287/169747555-fe2d8408-6fb7-47e7-9e14-2e790d29cd1f.png"><img src="https://user-images.githubusercontent.com/8981287/169747555-fe2d8408-6fb7-47e7-9e14-2e790d29cd1f.png" alt="image" style="max-width: 100%;"></a><br>
Uh oh, you committed the wrong commit to the wrong branch and then committed more commits on top of that commit, Karni\u2019s really gonna beat your ass now. Don\u2019t worry, once again I got you covered with dangerous git command # 3</p>
<h3 dir="auto">git rebase --interactive (or just git rebase -i)</h3>
<p dir="auto">Admittedly this command tends to be less dangerous, less easy to mess up, and actually legitimately useful for doing things like splitting a pull request with 3 features into 3 separate branches. Rebasing could honestly be a whole blog post on its own but I\u2019ll be covering just 1 specific use case here</p>
<ol dir="auto">
<li>
<p dir="auto">Just like above, pick the commit you want to go back to and start picking from<br>
<a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/8981287/169747603-3b3cd0c7-fc1a-4909-842b-faf36a36d87d.png"><img src="https://user-images.githubusercontent.com/8981287/169747603-3b3cd0c7-fc1a-4909-842b-faf36a36d87d.png" alt="image" style="max-width: 100%;"></a></p>
</li>
<li>
<p dir="auto">Head back over to your terminal and run <strong>git rebase -i [SHA]</strong>, this will open a text editor, either nano or vim (personally I don\u2019t know how to use vim so if you get vim then just press i to put it in notepad mode and use it like notepad)<br>
<a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/8981287/169747642-c6518658-88c8-46cb-94ed-c0ef23712b5c.png"><img src="https://user-images.githubusercontent.com/8981287/169747642-c6518658-88c8-46cb-94ed-c0ef23712b5c.png" alt="image" style="max-width: 100%;"></a></p>
</li>
<li>
<p dir="auto">From here, you\u2019ll see a list of commits past the commit you selected earlier, to remove a commit, either delete the line or replace pick with drop<br>
<a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/8981287/169747683-ed5853a4-341d-4c02-bb27-a45b33e7f7ac.png"><img src="https://user-images.githubusercontent.com/8981287/169747683-ed5853a4-341d-4c02-bb27-a45b33e7f7ac.png" alt="image" style="max-width: 100%;"></a></p>
</li>
<li>
<p dir="auto">If you\u2019re using vim it\u2019s escape -&gt; :wq to save and quit, if you\u2019re using nano it\u2019s ctrl + x</p>
</li>
<li>
<p dir="auto">From here you may or may not have to resolve any rebase conflicts which are just like merge conflicts so go ahead and get those resolved if applicable</p>
</li>
<li>
<p dir="auto">Once again, this rewrites history so you\u2019ll have to use <strong>git push --force</strong> again and the commit in question should now be erased and your ass is once again saved from a beating<br>
<a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/8981287/169747719-8405d468-971b-4ed3-a2be-e5a47c9ccdf5.png"><img src="https://user-images.githubusercontent.com/8981287/169747719-8405d468-971b-4ed3-a2be-e5a47c9ccdf5.png" alt="image" style="max-width: 100%;"></a><br>
Thanks for reading and once again please use caution when using these as they are as dangerous as they are powerful and you can easily lose your own or someone else's commits in the process or create a merge conflict problem for someone else when they suddenly can't push to main. Best advice I can give to minimizing this kind of damage is to only use these commands on branches/forks that only you work on and to never do this on main.</p>
</li>
</ol>`,
        createdAt: "2022-05-23T05:11:12Z",
        lastEdited: "2022-05-23T11:17:14Z",
        labels: [],
        author: {
          url: "https://github.com/jaasonw",
          displayname: "jaasonw",
          picture: "https://avatars.githubusercontent.com/u/8981287?u=4bf37a144d65af7f4d6aa1616fd734f83b566fac&v=4"
        }
      },
      {
        id: 322,
        url: "/blog/322",
        discussionUrl: "https://github.com/EthanThatOneKid/acmcsuf.com/discussions/322",
        title: "Participating in the ICPC 2022 SoCal Regionals",
        html: '<p dir="auto">5 students made CSUF history on Saturday, February 26th at the ICPC 2022 SoCal regionals:</p>\n<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/31261035/156796570-8b2e6590-d461-40d3-b332-017535616126.jpeg"><img src="https://user-images.githubusercontent.com/31261035/156796570-8b2e6590-d461-40d3-b332-017535616126.jpeg" alt="ICPC 2022 CSUF athlete portraits (right to left, top to bottom): Aaron Lieberman, Justin Stitt, Yao Lin, Ethan Davidson, and Charlie Taylor" style="max-width: 100%;"></a></p>\n<p dir="auto">The event was held at Riverside City College. Check-in began in the morning, then breakfast was served at the event once we got in.</p>\n<p dir="auto">There was a practice session after breakfast to make sure the competition would go smoothly on the technical side and to make sure all the competitors were aware of the given development environment\u2019s capabilities.</p>\n<p dir="auto">After the practice session, we had free lunch out of a <em>Habit</em> food truck. We then began the competition after the lunch break ended.</p>\n<p dir="auto">Once the time for the competition had run out, all the competitors left their battle stations that they had been hunched over for the last 5 hours. We then went back to the place where we originally ate breakfast. At that point, the results of the competition were not finalized; the results of the last fifteen minutes of code submissions were unknown so that we could experience a suspenseful ending ceremony.</p>\n<p dir="auto">In the end, a team from Caltech narrowly earned the highest score with the UCLA team coming in a close second. As for us, our 2022 teams scored the highest combined total score in CSUF x ICPC history <g-emoji class="g-emoji" alias="laughing" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png">\u{1F606}</g-emoji></p>\n<p dir="auto">If you are interested in learning valuable competitive programming skills, you can come to <a href="https://acmcsuf.com/paths#algo" rel="nofollow"><strong>acmAlgo</strong></a> meetings throughout the semester where our acmAlgo officers will guide you down the mind-blowing rabbit-hole of programming. To learn more, register as a CSUF student on our Discord server to chat with our community members.</p>',
        createdAt: "2022-03-04T16:13:40Z",
        lastEdited: "2022-03-05T17:41:33Z",
        labels: ["algo", "poggers", "wayson is poggers"],
        author: {
          url: "https://github.com/EthanThatOneKid",
          displayname: "EthanThatOneKid",
          picture: "https://avatars.githubusercontent.com/u/31261035?u=a623a203593b6a1069aa87b1dfcd894772e285d2&v=4"
        }
      },
      {
        id: 272,
        url: "/blog/272",
        discussionUrl: "https://github.com/EthanThatOneKid/acmcsuf.com/discussions/272",
        title: "Top 10 reasons to not comment your code",
        html: '<p dir="auto">1.) It makes the code longer<br>\n2.) It makes the code uglier (its a weird gray)<br>\n3.) How do you even comment (its different for every language)<br>\n4.) no one be reading your code<br>\n10.) your comments are bad anyways</p>\n<p dir="auto">thank you for coming to my ted talk</p>',
        createdAt: "2022-01-25T03:02:22Z",
        lastEdited: null,
        labels: [],
        author: {
          url: "https://github.com/AaronLieb",
          displayname: "AaronLieb",
          picture: "https://avatars.githubusercontent.com/u/42902411?u=c039a4edfda0edd15a5f110deb778fb5cd4dff26&v=4"
        }
      },
      {
        id: 269,
        url: "/blog/269",
        discussionUrl: "https://github.com/EthanThatOneKid/acmcsuf.com/discussions/269",
        title: "acmcsuf.com \u2665 RSS",
        html: `<h1 dir="auto">acmcsuf.com <g-emoji class="g-emoji" alias="hearts" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2665.png">\u2665</g-emoji> RSS</h1>
<p dir="auto"><strong>tl;dr</strong>: Check out our RSS feed on <a href="https://acmcsuf.com/blog.xml" rel="nofollow"><code class="notranslate">https://acmcsuf.com/blog.xml</code></a>! <g-emoji class="g-emoji" alias="sunglasses" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60e.png">\u{1F60E}</g-emoji></p>
<h2 dir="auto">What is RSS?</h2>
<p dir="auto">RSS is a specification built on top of XML which stands for <a href="https://en.wikipedia.org/wiki/RSS" rel="nofollow"><em>Really Simple Syndication</em></a>. Computer people tend to use RSS to keep track of things on the Internet that they want to be notified about when anything new is published. This technology is useful for the syndication of things like blog posts, but can really be used for all types of digital publications imaginable.</p>
<h2 dir="auto">How do we leverage RSS?</h2>
<p dir="auto">Here on acmcsuf.com, our blog feature is an outlet for our community to publish computer science-related posts or in-depth updates/reflections about community events. In order to make sure people are notified as soon as a new post is published, we must be RSS-compatible. Lucky for us, RSS is really, really simple and only uses a single HTTP endpoint. You can find ours on <a href="https://acmcsuf.com/blog.xml" rel="nofollow"><code class="notranslate">https://acmcsuf.com/blog.xml</code></a>.</p>
<h2 dir="auto">How can you use RSS in your daily life?</h2>
<p dir="auto">There are many ways people choose to indulge in RSS feeds. One way is to use a simple piece of software found online (e.g. desktop application, browser extension, etc.). A simple search in your favorite search engine should give you an up-to-date result.</p>
<p dir="auto">To subscribe to an RSS feed, all you need is a single HTTP endpoint commonly ending with <code class="notranslate">.rss</code> or <code class="notranslate">.xml</code> since RSS is expressed as an <a href="https://en.wikipedia.org/wiki/XML" rel="nofollow">XML (Extensible Markup Language</a>) document. Copy our HTTP endpoint below to subscribe within your RSS feed manager.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="https://acmcsuf.com/blog.xml"><pre class="notranslate"><code>https://acmcsuf.com/blog.xml
</code></pre></div>
<p dir="auto"><strong>Note</strong>: Other standards exist such as <a href="https://en.wikipedia.org/wiki/Atom_(standard)" rel="nofollow">Atom</a> and <a href="https://jsonfeed.org/version/1" rel="nofollow">JSON feed</a> and are often used as alternatives to RSS.</p>
<h3 dir="auto">Choosing RSS feeds to follow</h3>
<p dir="auto">You're free to follow any publication that you like as long as you can find it online for free! For starters, you have <a href="https://acmcsuf.com/blog.xml" rel="nofollow"><code class="notranslate">https://acmcsuf.com/blog.xml</code></a>. If you have a favorite Subreddit, you can subscribe to its RSS feed using the RSS feed URL pattern, <code class="notranslate">https://reddit.com/r/&lt;your_subreddit&gt;.rss</code> (example: <a href="https://reddit.com/r/csuf.rss" rel="nofollow"><code class="notranslate">https://reddit.com/r/csuf.rss</code></a>). Most blogs and major Internet platforms incorporate RSS into their sites, so it is up to you to keep an eye out for the [commonly orange] RSS logo! This symbol indicates the existence of an RSS feed.</p>
<p dir="auto"><a href="https://en.wikipedia.org/wiki/RSS" rel="nofollow"><img src="https://user-images.githubusercontent.com/31261035/150892071-3ec94857-aa5b-4011-9d60-bd569ce1b7c0.png" alt="RSS logo" style="max-width: 100%;"></a></p>
<h3 dir="auto">Making your own RSS feed manager</h3>
<p dir="auto">If you are looking into learning more about RSS hands-on, you can actually interface with any RSS feed on the web as long as your favorite programming language has a trustworthy library for parsing RSS feeds (or at least XML documents).</p>
<p dir="auto"><strong>Note</strong>: If your language-of-choice does not have such a library, you will just have to implement the entire <a href="https://www.rssboard.org/rss-2-0-1" rel="nofollow">RSS specification</a> yourself, which is not particularly trivial, so I\u2019d recommend finding a language that is capable to make things easier for yourself.</p>
<p dir="auto">For instance, we use <a href="https://github.com/dylang/node-rss#readme">node-rss</a> to format the RSS document found on <a href="https://acmcsuf.com/blog.xml" rel="nofollow"><code class="notranslate">https://acmcsuf.com/blog.xml</code></a>. Below are some libraries I found on GitHub that you can start with.</p>
<h4 dir="auto">RSS v2.0.1 Compatible APIs</h4>
<table role="table">
<thead>
<tr>
<th>Language</th>
<th>Library</th>
</tr>
</thead>
<tbody>
<tr>
<td>Node.js</td>
<td><a href="https://github.com/dylang/node-rss#readme">node-rss</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href="https://github.com/kurtmckee/feedparser#readme">feedparser</a></td>
</tr>
<tr>
<td>Go</td>
<td><a href="https://github.com/mmcdole/gofeed#readme">gofeed</a></td>
</tr>
</tbody>
</table>
<h2 dir="auto">See also</h2>
<ul dir="auto">
<li><a href="https://en.wikipedia.org/wiki/RSS#History" rel="nofollow">https://en.wikipedia.org/wiki/RSS#History</a></li>
<li><a href="https://en.wikipedia.org/wiki/Web_syndication" rel="nofollow">https://en.wikipedia.org/wiki/Web_syndication</a></li>
<li>Documentary about prolific programmer, co-founder of Reddit <a href="https://en.wikipedia.org/wiki/Aaron_Swartz" rel="nofollow">Aaron Swartz</a> who co-wrote the RSS specification: <a href="https://www.youtube.com/watch?v=9vz06QO3UkQ" rel="nofollow">The Internet's Own Boy: The Story of Aaron Swartz | full movie (2014)</a></li>
</ul>
<p dir="auto"><em><g-emoji class="g-emoji" alias="tada" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png">\u{1F389}</g-emoji> posted in celebration of v2.0 launch (<a href="https://github.com/EthanThatOneKid/acmcsuf.com/releases/tag/v2.0">release</a>, <a href="https://github.com/EthanThatOneKid/acmcsuf.com/milestone/1">milestone</a>)</em></p>`,
        createdAt: "2022-01-25T01:20:06Z",
        lastEdited: "2022-01-25T19:20:47Z",
        labels: [],
        author: {
          url: "https://github.com/EthanThatOneKid",
          displayname: "EthanThatOneKid",
          picture: "https://avatars.githubusercontent.com/u/31261035?u=a623a203593b6a1069aa87b1dfcd894772e285d2&v=4"
        }
      },
      {
        id: 262,
        url: "/blog/262",
        discussionUrl: "https://github.com/EthanThatOneKid/acmcsuf.com/discussions/262",
        title: "What's new in acmcsuf.com v2.0?",
        html: `<h1 dir="auto"><a href="https://acmcsuf.com/" rel="nofollow"><code class="notranslate">acmcsuf.com</code></a> v2.0</h1>
<p dir="auto">This release marks the completion of the ACM CSUF website <a href="https://github.com/EthanThatOneKid/acmcsuf.com/milestone/1">v2.0 milestone <g-emoji class="g-emoji" alias="dizzy" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4ab.png">\u{1F4AB}</g-emoji></a></p>
<h2 dir="auto">Fall '21 semester sprint</h2>
<ul dir="auto">
<li><strong>Contributors</strong>: <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a>, <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/diamondburned/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/diamondburned">@diamondburned</a>, <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/mikeploythai/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mikeploythai">@mikeploythai</a>, <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/anhduy1202/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/anhduy1202">@anhduy1202</a>, <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/MohamedHabarneh/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/MohamedHabarneh">@MohamedHabarneh</a>, <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/dustinchavez1/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/dustinchavez1">@dustinchavez1</a>, <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/adityashah6/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/adityashah6">@adityashah6</a>, <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/janiljohn/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/janiljohn">@janiljohn</a></li>
<li><strong>Project Board</strong>: <a href="https://github.com/EthanThatOneKid/acmcsuf.com/projects/2">https://github.com/EthanThatOneKid/acmcsuf.com/projects/2</a></li>
<li><strong>Reflection</strong>: We learned how to learn from one another by participating in the code review cycle on GitHub, suggesting ideas, or asking questions during coding sessions or on Discord.</li>
</ul>
<h2 dir="auto">Contributors</h2>
<p dir="auto">During the Fall 2021 school semester, the acmcsuf.com team accomplished many feats of engineering and broadened our technical horizons. This semester, we broke <strong>10</strong> (OMG!) total contributors in this repository! Each contributor took major steps forward in learning about open source web development and working in an organization-like setting with other human engineers. Congrats to everyone who contributed towards this release!</p>
<h3 dir="auto">New to acmcsuf.com hub</h3>
<ul dir="auto">
<li><a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/anhduy1202/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/anhduy1202">@anhduy1202</a> made their first contribution in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1029786899" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/153" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/153/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/153">#153</a></li>
<li><a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/MohamedHabarneh/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/MohamedHabarneh">@MohamedHabarneh</a> made their first contribution in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1034330071" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/157" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/157/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/157">#157</a></li>
<li><a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/dustinchavez1/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/dustinchavez1">@dustinchavez1</a> made their first contribution in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1038674711" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/163" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/163/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/163">#163</a></li>
<li><a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/adityashah6/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/adityashah6">@adityashah6</a> made their first contribution in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1040018991" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/176" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/176/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/176">#176</a></li>
<li><a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/janiljohn/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/janiljohn">@janiljohn</a> made their first contribution in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1046660139" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/204" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/204/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/204">#204</a></li>
</ul>
<p dir="auto">If you are interested in following along with us and becoming an acmcsuf.com v3.0 contributor, just watch out for any announcements on our blog (<a href="https://acmcsuf.com/blog" rel="nofollow">https://acmcsuf.com/blog</a>) or the acmCSUF Discord server.</p>
<h2 dir="auto">What's changed</h2>
<h3 dir="auto">This release at a glance</h3>
<ul dir="auto">
<li>Migrated from Sapper to SvelteKit in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1024772252" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/147" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/147/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/147">#147</a></li>
<li>Created GitHub action that creates/archives Discord text channels based on GitHub issues in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1039111868" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/165" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/165/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/165">#165</a></li>
<li>Added brand new 404 page in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1040018991" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/176" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/176/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/176">#176</a> (preview: <a href="https://acmcsuf.com/this/goes/nowhere" rel="nofollow">https://acmcsuf.com/this/goes/nowhere</a>)</li>
<li>Added privacy policy page by in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1108767416" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/255" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/255/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/255">#255</a></li>
<li>Minor bug fixes and site improvements in <a class="commit-link" href="https://github.com/EthanThatOneKid/acmcsuf.com/compare/v1.1...v2.0"><tt>v1.1...v2.0</tt></a></li>
<li>Achieved <a href="https://github.com/EthanThatOneKid/acmcsuf.com/milestone/1">v2.0 milestone <g-emoji class="g-emoji" alias="dizzy" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4ab.png">\u{1F4AB}</g-emoji></a></li>
</ul>
<h3 dir="auto">Notable changes [Auto-generated]</h3>
<ul dir="auto">
<li>Migrated to SvelteKit (before the v1.0 milestone lol) by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1024772252" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/147" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/147/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/147">#147</a></li>
<li>Modified navbar.svelte such that menu will close when link clicked by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/anhduy1202/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/anhduy1202">@anhduy1202</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1029786899" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/153" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/153/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/153">#153</a></li>
<li>Fixed navigation tab bug by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/dustinchavez1/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/dustinchavez1">@dustinchavez1</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1038674711" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/163" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/163/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/163">#163</a></li>
<li>Created GitHub workflow that creates text channels on issue open by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1039111868" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/165" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/165/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/165">#165</a></li>
<li>Added Frank to 404 page by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/adityashah6/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/adityashah6">@adityashah6</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1040018991" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/176" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/176/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/176">#176</a></li>
<li>Created officer data workflow by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1042942922" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/186" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/186/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/186">#186</a></li>
<li>Fix Spacing component parameters by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/diamondburned/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/diamondburned">@diamondburned</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1043094452" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/189" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/189/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/189">#189</a></li>
<li>Created <a href="https://github.com/EthanThatOneKid/acmcsuf.com/blob/main/.github/workflows/check_website.yaml"><code class="notranslate">check_website.yaml</code></a> workflow and eliminated remaining lint errors by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1046354802" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/192" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/192/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/192">#192</a></li>
<li>Created GitHub Action that discards closed issue channels by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1043336250" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/190" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/190/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/190">#190</a></li>
<li>Added indentation checking with Eslint by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1046416764" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/199" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/199/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/199">#199</a></li>
<li>Discord Bot sends PR and new Issue comments into corresponding channel (Issue: 238) by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/janiljohn/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/janiljohn">@janiljohn</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1068886626" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/239" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/239/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/239">#239</a></li>
<li>Added privacy policy page by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1108767416" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/255" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/255/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/255">#255</a></li>
<li>Created initial, read-only newsletters web interface by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/adityashah6/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/adityashah6">@adityashah6</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1072640808" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/244" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/244/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/244">#244</a></li>
</ul>
<h3 dir="auto">Minor changes [Auto-generated]</h3>
<ul dir="auto">
<li>Fixed accidental space in about page, credited ACM W in nodeBuds page by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/mikeploythai/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mikeploythai">@mikeploythai</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1007283466" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/139" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/139/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/139">#139</a></li>
<li>Imported new members by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/mikeploythai/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mikeploythai">@mikeploythai</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1023340014" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/145" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/145/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/145">#145</a></li>
<li>Fixed bug on NodeBuds officer section (wrong officers showing) by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1024302051" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/146" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/146/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/146">#146</a></li>
<li>fixed links for the paths from the homepage  by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/MohamedHabarneh/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/MohamedHabarneh">@MohamedHabarneh</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1034330071" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/157" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/157/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/157">#157</a></li>
<li>Modify acm-select.svelte to create a custom select dropdown by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/anhduy1202/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/anhduy1202">@anhduy1202</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1034282481" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/156" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/156/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/156">#156</a></li>
<li>Refactored iCal parser to parse RRules by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1036905413" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/160" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/160/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/160">#160</a></li>
<li>fix the issues channel name for Issue Bot by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/anhduy1202/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/anhduy1202">@anhduy1202</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1040008590" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/175" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/175/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/175">#175</a></li>
<li>Refactored Spacing component to use CSS variables by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1041903556" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/184" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/184/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/184">#184</a></li>
<li>Welcomed Johnathan Carranza to acmCSUF F21 by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1043068473" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/188" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/188/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/188">#188</a></li>
<li>Removed SkipNavbarContent Component by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1044128198" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/191" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/191/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/191">#191</a></li>
<li>Removed unneeded arrow buttons for event carousel by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/MohamedHabarneh/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/MohamedHabarneh">@MohamedHabarneh</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1040302281" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/178" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/178/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/178">#178</a></li>
<li>Stripped unwanted backslashes from event titles by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/janiljohn/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/janiljohn">@janiljohn</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1046660139" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/204" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/204/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/204">#204</a></li>
<li>Switch from pinning to labeling for <code class="notranslate">scripts/close-issue-channel.js</code> by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1048047998" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/208" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/208/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/208">#208</a></li>
<li>Improved the officer update request workflow by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1049612722" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/217" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/217/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/217">#217</a></li>
<li>Fix path color by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/anhduy1202/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/anhduy1202">@anhduy1202</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1050590230" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/225" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/225/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/225">#225</a></li>
<li>Created <code class="notranslate">check_site_changes.sh</code> script by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1050674255" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/229" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/229/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/229">#229</a></li>
<li>Added documentation for v2.0 workflows by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1050421343" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/222" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/222/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/222">#222</a></li>
<li>Created CODE_OF_CONDUCT.md by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1050637806" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/228" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/228/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/228">#228</a></li>
<li>Adjusted strange spacing in various places by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1056933271" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/233" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/233/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/233">#233</a></li>
<li>Create LICENSE by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1054574343" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/230" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/230/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/230">#230</a></li>
<li>Initialized a basic PR template by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1054583655" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/231" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/231/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/231">#231</a></li>
<li>Created <code class="notranslate">/newsletters</code> entrypoint by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1064893098" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/236" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/236/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/236">#236</a></li>
<li>Refactor flex-box to grid (update) by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/anhduy1202/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/anhduy1202">@anhduy1202</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1071400343" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/241" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/241/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/241">#241</a></li>
<li>added link to apply for 2022 board positions by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/mikeploythai/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mikeploythai">@mikeploythai</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1097629375" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/253" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/253/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/253">#253</a></li>
<li>Added Size Limit for <code class="notranslate">node_modules</code> by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1086185148" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/248" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/248/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/248">#248</a></li>
<li>Integrated issue channel label blocklist by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1049621830" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/218" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/218/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/218">#218</a></li>
<li>Created initial, read-only newsletters web interface by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/adityashah6/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/adityashah6">@adityashah6</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1072640808" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/244" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/244/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/244">#244</a></li>
<li>Mike/2022 updates by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/mikeploythai/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mikeploythai">@mikeploythai</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1112087111" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/258" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/258/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/258">#258</a></li>
<li>Renamed COVID-19 Notice to COVID-19 Policy in footer by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/mikeploythai/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mikeploythai">@mikeploythai</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1113060867" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/260" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/260/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/260">#260</a></li>
<li>Added prefer-arrow-callback and func-style rules to our Eslint config by <a class="user-mention notranslate" data-hovercard-type="user" data-hovercard-url="/users/EthanThatOneKid/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/EthanThatOneKid">@EthanThatOneKid</a> in <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1113144388" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/issues/261" data-hovercard-type="pull_request" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/pull/261/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/pull/261">#261</a></li>
</ul>
<p dir="auto"><strong>Full Changelog</strong>: <a class="commit-link" href="https://github.com/EthanThatOneKid/acmcsuf.com/compare/v1.1...v2.0"><tt>v1.1...v2.0</tt></a><br>
<strong>GitHub Discussion (Mirror)</strong>: <a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="3831125" data-permission-text="Title is private" data-url="https://github.com/EthanThatOneKid/acmcsuf.com/discussions/262" data-hovercard-type="discussion" data-hovercard-url="/EthanThatOneKid/acmcsuf.com/discussions/262/hovercard" href="https://github.com/EthanThatOneKid/acmcsuf.com/discussions/262">#262</a><br>
<strong>Blog Post on acmcsuf.com (Mirror)</strong>: <a href="https://acmcsuf.com/blog/262" rel="nofollow">https://acmcsuf.com/blog/262</a><br>
<strong>GitHub Release (Original post)</strong>: <a href="https://github.com/EthanThatOneKid/acmcsuf.com/releases/tag/v2.0">https://github.com/EthanThatOneKid/acmcsuf.com/releases/tag/v2.0</a></p>`,
        createdAt: "2022-01-24T23:42:50Z",
        lastEdited: "2022-01-29T17:26:37Z",
        labels: ["release"],
        author: {
          url: "https://github.com/EthanThatOneKid",
          displayname: "EthanThatOneKid",
          picture: "https://avatars.githubusercontent.com/u/31261035?u=a623a203593b6a1069aa87b1dfcd894772e285d2&v=4"
        }
      }
    ];
    SAMPLE_POSTS = JSON.stringify(posts);
  }
});

// node_modules/domelementtype/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/domelementtype/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
    var ElementType;
    (function(ElementType2) {
      ElementType2["Root"] = "root";
      ElementType2["Text"] = "text";
      ElementType2["Directive"] = "directive";
      ElementType2["Comment"] = "comment";
      ElementType2["Script"] = "script";
      ElementType2["Style"] = "style";
      ElementType2["Tag"] = "tag";
      ElementType2["CDATA"] = "cdata";
      ElementType2["Doctype"] = "doctype";
    })(ElementType = exports.ElementType || (exports.ElementType = {}));
    function isTag(elem) {
      return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
    }
    exports.isTag = isTag;
    exports.Root = ElementType.Root;
    exports.Text = ElementType.Text;
    exports.Directive = ElementType.Directive;
    exports.Comment = ElementType.Comment;
    exports.Script = ElementType.Script;
    exports.Style = ElementType.Style;
    exports.Tag = ElementType.Tag;
    exports.CDATA = ElementType.CDATA;
    exports.Doctype = ElementType.Doctype;
  }
});

// node_modules/domhandler/lib/node.js
var require_node = __commonJS({
  "node_modules/domhandler/lib/node.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s3, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s3 = arguments[i2];
          for (var p in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p))
              t2[p] = s3[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
    var domelementtype_1 = require_lib2();
    var nodeTypes = /* @__PURE__ */ new Map([
      [domelementtype_1.ElementType.Tag, 1],
      [domelementtype_1.ElementType.Script, 1],
      [domelementtype_1.ElementType.Style, 1],
      [domelementtype_1.ElementType.Directive, 1],
      [domelementtype_1.ElementType.Text, 3],
      [domelementtype_1.ElementType.CDATA, 4],
      [domelementtype_1.ElementType.Comment, 8],
      [domelementtype_1.ElementType.Root, 9]
    ]);
    var Node = function() {
      function Node2(type) {
        this.type = type;
        this.parent = null;
        this.prev = null;
        this.next = null;
        this.startIndex = null;
        this.endIndex = null;
      }
      Object.defineProperty(Node2.prototype, "nodeType", {
        get: function() {
          var _a4;
          return (_a4 = nodeTypes.get(this.type)) !== null && _a4 !== void 0 ? _a4 : 1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node2.prototype, "parentNode", {
        get: function() {
          return this.parent;
        },
        set: function(parent) {
          this.parent = parent;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node2.prototype, "previousSibling", {
        get: function() {
          return this.prev;
        },
        set: function(prev) {
          this.prev = prev;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node2.prototype, "nextSibling", {
        get: function() {
          return this.next;
        },
        set: function(next) {
          this.next = next;
        },
        enumerable: false,
        configurable: true
      });
      Node2.prototype.cloneNode = function(recursive) {
        if (recursive === void 0) {
          recursive = false;
        }
        return cloneNode(this, recursive);
      };
      return Node2;
    }();
    exports.Node = Node;
    var DataNode = function(_super) {
      __extends(DataNode2, _super);
      function DataNode2(type, data) {
        var _this = _super.call(this, type) || this;
        _this.data = data;
        return _this;
      }
      Object.defineProperty(DataNode2.prototype, "nodeValue", {
        get: function() {
          return this.data;
        },
        set: function(data) {
          this.data = data;
        },
        enumerable: false,
        configurable: true
      });
      return DataNode2;
    }(Node);
    exports.DataNode = DataNode;
    var Text = function(_super) {
      __extends(Text2, _super);
      function Text2(data) {
        return _super.call(this, domelementtype_1.ElementType.Text, data) || this;
      }
      return Text2;
    }(DataNode);
    exports.Text = Text;
    var Comment = function(_super) {
      __extends(Comment2, _super);
      function Comment2(data) {
        return _super.call(this, domelementtype_1.ElementType.Comment, data) || this;
      }
      return Comment2;
    }(DataNode);
    exports.Comment = Comment;
    var ProcessingInstruction = function(_super) {
      __extends(ProcessingInstruction2, _super);
      function ProcessingInstruction2(name, data) {
        var _this = _super.call(this, domelementtype_1.ElementType.Directive, data) || this;
        _this.name = name;
        return _this;
      }
      return ProcessingInstruction2;
    }(DataNode);
    exports.ProcessingInstruction = ProcessingInstruction;
    var NodeWithChildren = function(_super) {
      __extends(NodeWithChildren2, _super);
      function NodeWithChildren2(type, children) {
        var _this = _super.call(this, type) || this;
        _this.children = children;
        return _this;
      }
      Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
        get: function() {
          var _a4;
          return (_a4 = this.children[0]) !== null && _a4 !== void 0 ? _a4 : null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
        get: function() {
          return this.children.length > 0 ? this.children[this.children.length - 1] : null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
        get: function() {
          return this.children;
        },
        set: function(children) {
          this.children = children;
        },
        enumerable: false,
        configurable: true
      });
      return NodeWithChildren2;
    }(Node);
    exports.NodeWithChildren = NodeWithChildren;
    var Document = function(_super) {
      __extends(Document2, _super);
      function Document2(children) {
        return _super.call(this, domelementtype_1.ElementType.Root, children) || this;
      }
      return Document2;
    }(NodeWithChildren);
    exports.Document = Document;
    var Element = function(_super) {
      __extends(Element2, _super);
      function Element2(name, attribs, children, type) {
        if (children === void 0) {
          children = [];
        }
        if (type === void 0) {
          type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
        }
        var _this = _super.call(this, type, children) || this;
        _this.name = name;
        _this.attribs = attribs;
        return _this;
      }
      Object.defineProperty(Element2.prototype, "tagName", {
        get: function() {
          return this.name;
        },
        set: function(name) {
          this.name = name;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Element2.prototype, "attributes", {
        get: function() {
          var _this = this;
          return Object.keys(this.attribs).map(function(name) {
            var _a4, _b;
            return {
              name,
              value: _this.attribs[name],
              namespace: (_a4 = _this["x-attribsNamespace"]) === null || _a4 === void 0 ? void 0 : _a4[name],
              prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
            };
          });
        },
        enumerable: false,
        configurable: true
      });
      return Element2;
    }(NodeWithChildren);
    exports.Element = Element;
    function isTag(node) {
      return (0, domelementtype_1.isTag)(node);
    }
    exports.isTag = isTag;
    function isCDATA(node) {
      return node.type === domelementtype_1.ElementType.CDATA;
    }
    exports.isCDATA = isCDATA;
    function isText(node) {
      return node.type === domelementtype_1.ElementType.Text;
    }
    exports.isText = isText;
    function isComment(node) {
      return node.type === domelementtype_1.ElementType.Comment;
    }
    exports.isComment = isComment;
    function isDirective(node) {
      return node.type === domelementtype_1.ElementType.Directive;
    }
    exports.isDirective = isDirective;
    function isDocument(node) {
      return node.type === domelementtype_1.ElementType.Root;
    }
    exports.isDocument = isDocument;
    function hasChildren(node) {
      return Object.prototype.hasOwnProperty.call(node, "children");
    }
    exports.hasChildren = hasChildren;
    function cloneNode(node, recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      var result;
      if (isText(node)) {
        result = new Text(node.data);
      } else if (isComment(node)) {
        result = new Comment(node.data);
      } else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
        children.forEach(function(child) {
          return child.parent = clone_1;
        });
        if (node.namespace != null) {
          clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
          clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
          clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
      } else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new NodeWithChildren(domelementtype_1.ElementType.CDATA, children);
        children.forEach(function(child) {
          return child.parent = clone_2;
        });
        result = clone_2;
      } else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document(children);
        children.forEach(function(child) {
          return child.parent = clone_3;
        });
        if (node["x-mode"]) {
          clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
      } else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
          instruction["x-name"] = node["x-name"];
          instruction["x-publicId"] = node["x-publicId"];
          instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
      } else {
        throw new Error("Not implemented yet: ".concat(node.type));
      }
      result.startIndex = node.startIndex;
      result.endIndex = node.endIndex;
      if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
      }
      return result;
    }
    exports.cloneNode = cloneNode;
    function cloneChildren(childs) {
      var children = childs.map(function(child) {
        return cloneNode(child, true);
      });
      for (var i2 = 1; i2 < children.length; i2++) {
        children[i2].prev = children[i2 - 1];
        children[i2 - 1].next = children[i2];
      }
      return children;
    }
  }
});

// node_modules/domhandler/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/domhandler/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m2[k];
      } });
    } : function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m2[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p in m2)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m2, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DomHandler = void 0;
    var domelementtype_1 = require_lib2();
    var node_1 = require_node();
    __exportStar(require_node(), exports);
    var reWhitespace = /\s+/g;
    var defaultOpts = {
      normalizeWhitespace: false,
      withStartIndices: false,
      withEndIndices: false,
      xmlMode: false
    };
    var DomHandler = function() {
      function DomHandler2(callback, options, elementCB) {
        this.dom = [];
        this.root = new node_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
        if (typeof options === "function") {
          elementCB = options;
          options = defaultOpts;
        }
        if (typeof callback === "object") {
          options = callback;
          callback = void 0;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options !== null && options !== void 0 ? options : defaultOpts;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
      }
      DomHandler2.prototype.onparserinit = function(parser) {
        this.parser = parser;
      };
      DomHandler2.prototype.onreset = function() {
        this.dom = [];
        this.root = new node_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
      };
      DomHandler2.prototype.onend = function() {
        if (this.done)
          return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
      };
      DomHandler2.prototype.onerror = function(error2) {
        this.handleCallback(error2);
      };
      DomHandler2.prototype.onclosetag = function() {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
          elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
          this.elementCB(elem);
      };
      DomHandler2.prototype.onopentag = function(name, attribs) {
        var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : void 0;
        var element = new node_1.Element(name, attribs, void 0, type);
        this.addNode(element);
        this.tagStack.push(element);
      };
      DomHandler2.prototype.ontext = function(data) {
        var normalizeWhitespace = this.options.normalizeWhitespace;
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
          if (normalizeWhitespace) {
            lastNode.data = (lastNode.data + data).replace(reWhitespace, " ");
          } else {
            lastNode.data += data;
          }
          if (this.options.withEndIndices) {
            lastNode.endIndex = this.parser.endIndex;
          }
        } else {
          if (normalizeWhitespace) {
            data = data.replace(reWhitespace, " ");
          }
          var node = new node_1.Text(data);
          this.addNode(node);
          this.lastNode = node;
        }
      };
      DomHandler2.prototype.oncomment = function(data) {
        if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
          this.lastNode.data += data;
          return;
        }
        var node = new node_1.Comment(data);
        this.addNode(node);
        this.lastNode = node;
      };
      DomHandler2.prototype.oncommentend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.oncdatastart = function() {
        var text = new node_1.Text("");
        var node = new node_1.NodeWithChildren(domelementtype_1.ElementType.CDATA, [text]);
        this.addNode(node);
        text.parent = node;
        this.lastNode = text;
      };
      DomHandler2.prototype.oncdataend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.onprocessinginstruction = function(name, data) {
        var node = new node_1.ProcessingInstruction(name, data);
        this.addNode(node);
      };
      DomHandler2.prototype.handleCallback = function(error2) {
        if (typeof this.callback === "function") {
          this.callback(error2, this.dom);
        } else if (error2) {
          throw error2;
        }
      };
      DomHandler2.prototype.addNode = function(node) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
          node.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
          node.endIndex = this.parser.endIndex;
        }
        parent.children.push(node);
        if (previousSibling) {
          node.prev = previousSibling;
          previousSibling.next = node;
        }
        node.parent = parent;
        this.lastNode = null;
      };
      return DomHandler2;
    }();
    exports.DomHandler = DomHandler;
    exports.default = DomHandler;
  }
});

// node_modules/nearley/lib/nearley.js
var require_nearley = __commonJS({
  "node_modules/nearley/lib/nearley.js"(exports, module2) {
    (function(root, factory) {
      if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root.nearley = factory();
      }
    })(exports, function() {
      function Rule(name, symbols, postprocess) {
        this.id = ++Rule.highestId;
        this.name = name;
        this.symbols = symbols;
        this.postprocess = postprocess;
        return this;
      }
      Rule.highestId = 0;
      Rule.prototype.toString = function(withCursorAt) {
        var symbolSequence = typeof withCursorAt === "undefined" ? this.symbols.map(getSymbolShortDisplay).join(" ") : this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(" ") + " \u25CF " + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(" ");
        return this.name + " \u2192 " + symbolSequence;
      };
      function State(rule, dot, reference, wantedBy) {
        this.rule = rule;
        this.dot = dot;
        this.reference = reference;
        this.data = [];
        this.wantedBy = wantedBy;
        this.isComplete = this.dot === rule.symbols.length;
      }
      State.prototype.toString = function() {
        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
      };
      State.prototype.nextState = function(child) {
        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);
        state.left = this;
        state.right = child;
        if (state.isComplete) {
          state.data = state.build();
          state.right = void 0;
        }
        return state;
      };
      State.prototype.build = function() {
        var children = [];
        var node = this;
        do {
          children.push(node.right.data);
          node = node.left;
        } while (node.left);
        children.reverse();
        return children;
      };
      State.prototype.finish = function() {
        if (this.rule.postprocess) {
          this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);
        }
      };
      function Column(grammar, index) {
        this.grammar = grammar;
        this.index = index;
        this.states = [];
        this.wants = {};
        this.scannable = [];
        this.completed = {};
      }
      Column.prototype.process = function(nextColumn) {
        var states = this.states;
        var wants = this.wants;
        var completed = this.completed;
        for (var w = 0; w < states.length; w++) {
          var state = states[w];
          if (state.isComplete) {
            state.finish();
            if (state.data !== Parser.fail) {
              var wantedBy = state.wantedBy;
              for (var i2 = wantedBy.length; i2--; ) {
                var left = wantedBy[i2];
                this.complete(left, state);
              }
              if (state.reference === this.index) {
                var exp = state.rule.name;
                (this.completed[exp] = this.completed[exp] || []).push(state);
              }
            }
          } else {
            var exp = state.rule.symbols[state.dot];
            if (typeof exp !== "string") {
              this.scannable.push(state);
              continue;
            }
            if (wants[exp]) {
              wants[exp].push(state);
              if (completed.hasOwnProperty(exp)) {
                var nulls = completed[exp];
                for (var i2 = 0; i2 < nulls.length; i2++) {
                  var right = nulls[i2];
                  this.complete(state, right);
                }
              }
            } else {
              wants[exp] = [state];
              this.predict(exp);
            }
          }
        }
      };
      Column.prototype.predict = function(exp) {
        var rules = this.grammar.byName[exp] || [];
        for (var i2 = 0; i2 < rules.length; i2++) {
          var r2 = rules[i2];
          var wantedBy = this.wants[exp];
          var s3 = new State(r2, 0, this.index, wantedBy);
          this.states.push(s3);
        }
      };
      Column.prototype.complete = function(left, right) {
        var copy = left.nextState(right);
        this.states.push(copy);
      };
      function Grammar(rules, start) {
        this.rules = rules;
        this.start = start || this.rules[0].name;
        var byName = this.byName = {};
        this.rules.forEach(function(rule) {
          if (!byName.hasOwnProperty(rule.name)) {
            byName[rule.name] = [];
          }
          byName[rule.name].push(rule);
        });
      }
      Grammar.fromCompiled = function(rules, start) {
        var lexer = rules.Lexer;
        if (rules.ParserStart) {
          start = rules.ParserStart;
          rules = rules.ParserRules;
        }
        var rules = rules.map(function(r2) {
          return new Rule(r2.name, r2.symbols, r2.postprocess);
        });
        var g = new Grammar(rules, start);
        g.lexer = lexer;
        return g;
      };
      function StreamLexer() {
        this.reset("");
      }
      StreamLexer.prototype.reset = function(data, state) {
        this.buffer = data;
        this.index = 0;
        this.line = state ? state.line : 1;
        this.lastLineBreak = state ? -state.col : 0;
      };
      StreamLexer.prototype.next = function() {
        if (this.index < this.buffer.length) {
          var ch = this.buffer[this.index++];
          if (ch === "\n") {
            this.line += 1;
            this.lastLineBreak = this.index;
          }
          return { value: ch };
        }
      };
      StreamLexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.index - this.lastLineBreak
        };
      };
      StreamLexer.prototype.formatError = function(token, message) {
        var buffer = this.buffer;
        if (typeof buffer === "string") {
          var lines = buffer.split("\n").slice(Math.max(0, this.line - 5), this.line);
          var nextLineBreak = buffer.indexOf("\n", this.index);
          if (nextLineBreak === -1)
            nextLineBreak = buffer.length;
          var col = this.index - this.lastLineBreak;
          var lastLineDigits = String(this.line).length;
          message += " at line " + this.line + " col " + col + ":\n\n";
          message += lines.map(function(line, i2) {
            return pad(this.line - lines.length + i2 + 1, lastLineDigits) + " " + line;
          }, this).join("\n");
          message += "\n" + pad("", lastLineDigits + col) + "^\n";
          return message;
        } else {
          return message + " at index " + (this.index - 1);
        }
        function pad(n, length) {
          var s3 = String(n);
          return Array(length - s3.length + 1).join(" ") + s3;
        }
      };
      function Parser(rules, start, options) {
        if (rules instanceof Grammar) {
          var grammar = rules;
          var options = start;
        } else {
          var grammar = Grammar.fromCompiled(rules, start);
        }
        this.grammar = grammar;
        this.options = {
          keepHistory: false,
          lexer: grammar.lexer || new StreamLexer()
        };
        for (var key2 in options || {}) {
          this.options[key2] = options[key2];
        }
        this.lexer = this.options.lexer;
        this.lexerState = void 0;
        var column = new Column(grammar, 0);
        var table = this.table = [column];
        column.wants[grammar.start] = [];
        column.predict(grammar.start);
        column.process();
        this.current = 0;
      }
      Parser.fail = {};
      Parser.prototype.feed = function(chunk) {
        var lexer = this.lexer;
        lexer.reset(chunk, this.lexerState);
        var token;
        while (true) {
          try {
            token = lexer.next();
            if (!token) {
              break;
            }
          } catch (e2) {
            var nextColumn = new Column(this.grammar, this.current + 1);
            this.table.push(nextColumn);
            var err = new Error(this.reportLexerError(e2));
            err.offset = this.current;
            err.token = e2.token;
            throw err;
          }
          var column = this.table[this.current];
          if (!this.options.keepHistory) {
            delete this.table[this.current - 1];
          }
          var n = this.current + 1;
          var nextColumn = new Column(this.grammar, n);
          this.table.push(nextColumn);
          var literal = token.text !== void 0 ? token.text : token.value;
          var value = lexer.constructor === StreamLexer ? token.value : token;
          var scannable = column.scannable;
          for (var w = scannable.length; w--; ) {
            var state = scannable[w];
            var expect = state.rule.symbols[state.dot];
            if (expect.test ? expect.test(value) : expect.type ? expect.type === token.type : expect.literal === literal) {
              var next = state.nextState({ data: value, token, isToken: true, reference: n - 1 });
              nextColumn.states.push(next);
            }
          }
          nextColumn.process();
          if (nextColumn.states.length === 0) {
            var err = new Error(this.reportError(token));
            err.offset = this.current;
            err.token = token;
            throw err;
          }
          if (this.options.keepHistory) {
            column.lexerState = lexer.save();
          }
          this.current++;
        }
        if (column) {
          this.lexerState = lexer.save();
        }
        this.results = this.finish();
        return this;
      };
      Parser.prototype.reportLexerError = function(lexerError) {
        var tokenDisplay, lexerMessage;
        var token = lexerError.token;
        if (token) {
          tokenDisplay = "input " + JSON.stringify(token.text[0]) + " (lexer error)";
          lexerMessage = this.lexer.formatError(token, "Syntax error");
        } else {
          tokenDisplay = "input (lexer error)";
          lexerMessage = lexerError.message;
        }
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser.prototype.reportError = function(token) {
        var tokenDisplay = (token.type ? token.type + " token: " : "") + JSON.stringify(token.value !== void 0 ? token.value : token);
        var lexerMessage = this.lexer.formatError(token, "Syntax error");
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {
        var lines = [];
        lines.push(lexerMessage);
        var lastColumnIndex = this.table.length - 2;
        var lastColumn = this.table[lastColumnIndex];
        var expectantStates = lastColumn.states.filter(function(state) {
          var nextSymbol = state.rule.symbols[state.dot];
          return nextSymbol && typeof nextSymbol !== "string";
        });
        if (expectantStates.length === 0) {
          lines.push("Unexpected " + tokenDisplay + ". I did not expect any more input. Here is the state of my parse table:\n");
          this.displayStateStack(lastColumn.states, lines);
        } else {
          lines.push("Unexpected " + tokenDisplay + ". Instead, I was expecting to see one of the following:\n");
          var stateStacks = expectantStates.map(function(state) {
            return this.buildFirstStateStack(state, []) || [state];
          }, this);
          stateStacks.forEach(function(stateStack) {
            var state = stateStack[0];
            var nextSymbol = state.rule.symbols[state.dot];
            var symbolDisplay = this.getSymbolDisplay(nextSymbol);
            lines.push("A " + symbolDisplay + " based on:");
            this.displayStateStack(stateStack, lines);
          }, this);
        }
        lines.push("");
        return lines.join("\n");
      };
      Parser.prototype.displayStateStack = function(stateStack, lines) {
        var lastDisplay;
        var sameDisplayCount = 0;
        for (var j = 0; j < stateStack.length; j++) {
          var state = stateStack[j];
          var display = state.rule.toString(state.dot);
          if (display === lastDisplay) {
            sameDisplayCount++;
          } else {
            if (sameDisplayCount > 0) {
              lines.push("    ^ " + sameDisplayCount + " more lines identical to this");
            }
            sameDisplayCount = 0;
            lines.push("    " + display);
          }
          lastDisplay = display;
        }
      };
      Parser.prototype.getSymbolDisplay = function(symbol) {
        return getSymbolLongDisplay(symbol);
      };
      Parser.prototype.buildFirstStateStack = function(state, visited) {
        if (visited.indexOf(state) !== -1) {
          return null;
        }
        if (state.wantedBy.length === 0) {
          return [state];
        }
        var prevState = state.wantedBy[0];
        var childVisited = [state].concat(visited);
        var childResult = this.buildFirstStateStack(prevState, childVisited);
        if (childResult === null) {
          return null;
        }
        return [state].concat(childResult);
      };
      Parser.prototype.save = function() {
        var column = this.table[this.current];
        column.lexerState = this.lexerState;
        return column;
      };
      Parser.prototype.restore = function(column) {
        var index = column.index;
        this.current = index;
        this.table[index] = column;
        this.table.splice(index + 1);
        this.lexerState = column.lexerState;
        this.results = this.finish();
      };
      Parser.prototype.rewind = function(index) {
        if (!this.options.keepHistory) {
          throw new Error("set option `keepHistory` to enable rewinding");
        }
        this.restore(this.table[index]);
      };
      Parser.prototype.finish = function() {
        var considerations = [];
        var start = this.grammar.start;
        var column = this.table[this.table.length - 1];
        column.states.forEach(function(t2) {
          if (t2.rule.name === start && t2.dot === t2.rule.symbols.length && t2.reference === 0 && t2.data !== Parser.fail) {
            considerations.push(t2);
          }
        });
        return considerations.map(function(c) {
          return c.data;
        });
      };
      function getSymbolLongDisplay(symbol) {
        var type = typeof symbol;
        if (type === "string") {
          return symbol;
        } else if (type === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return "character matching " + symbol;
          } else if (symbol.type) {
            return symbol.type + " token";
          } else if (symbol.test) {
            return "token matching " + String(symbol.test);
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      function getSymbolShortDisplay(symbol) {
        var type = typeof symbol;
        if (type === "string") {
          return symbol;
        } else if (type === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return symbol.toString();
          } else if (symbol.type) {
            return "%" + symbol.type;
          } else if (symbol.test) {
            return "<" + String(symbol.test) + ">";
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      return {
        Parser,
        Grammar,
        Rule
      };
    });
  }
});

// node_modules/moo/moo.js
var require_moo = __commonJS({
  "node_modules/moo/moo.js"(exports, module2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root.moo = factory();
      }
    })(exports, function() {
      "use strict";
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var toString = Object.prototype.toString;
      var hasSticky = typeof new RegExp().sticky === "boolean";
      function isRegExp(o) {
        return o && toString.call(o) === "[object RegExp]";
      }
      function isObject(o) {
        return o && typeof o === "object" && !isRegExp(o) && !Array.isArray(o);
      }
      function reEscape(s3) {
        return s3.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      function reGroups(s3) {
        var re = new RegExp("|" + s3);
        return re.exec("").length - 1;
      }
      function reCapture(s3) {
        return "(" + s3 + ")";
      }
      function reUnion(regexps) {
        if (!regexps.length)
          return "(?!)";
        var source = regexps.map(function(s3) {
          return "(?:" + s3 + ")";
        }).join("|");
        return "(?:" + source + ")";
      }
      function regexpOrLiteral(obj) {
        if (typeof obj === "string") {
          return "(?:" + reEscape(obj) + ")";
        } else if (isRegExp(obj)) {
          if (obj.ignoreCase)
            throw new Error("RegExp /i flag not allowed");
          if (obj.global)
            throw new Error("RegExp /g flag is implied");
          if (obj.sticky)
            throw new Error("RegExp /y flag is implied");
          if (obj.multiline)
            throw new Error("RegExp /m flag is implied");
          return obj.source;
        } else {
          throw new Error("Not a pattern: " + obj);
        }
      }
      function objectToRules(object) {
        var keys = Object.getOwnPropertyNames(object);
        var result = [];
        for (var i2 = 0; i2 < keys.length; i2++) {
          var key2 = keys[i2];
          var thing = object[key2];
          var rules = [].concat(thing);
          if (key2 === "include") {
            for (var j = 0; j < rules.length; j++) {
              result.push({ include: rules[j] });
            }
            continue;
          }
          var match2 = [];
          rules.forEach(function(rule) {
            if (isObject(rule)) {
              if (match2.length)
                result.push(ruleOptions(key2, match2));
              result.push(ruleOptions(key2, rule));
              match2 = [];
            } else {
              match2.push(rule);
            }
          });
          if (match2.length)
            result.push(ruleOptions(key2, match2));
        }
        return result;
      }
      function arrayToRules(array) {
        var result = [];
        for (var i2 = 0; i2 < array.length; i2++) {
          var obj = array[i2];
          if (obj.include) {
            var include = [].concat(obj.include);
            for (var j = 0; j < include.length; j++) {
              result.push({ include: include[j] });
            }
            continue;
          }
          if (!obj.type) {
            throw new Error("Rule has no type: " + JSON.stringify(obj));
          }
          result.push(ruleOptions(obj.type, obj));
        }
        return result;
      }
      function ruleOptions(type, obj) {
        if (!isObject(obj)) {
          obj = { match: obj };
        }
        if (obj.include) {
          throw new Error("Matching rules cannot also include states");
        }
        var options = {
          defaultType: type,
          lineBreaks: !!obj.error || !!obj.fallback,
          pop: false,
          next: null,
          push: null,
          error: false,
          fallback: false,
          value: null,
          type: null,
          shouldThrow: false
        };
        for (var key2 in obj) {
          if (hasOwnProperty.call(obj, key2)) {
            options[key2] = obj[key2];
          }
        }
        if (typeof options.type === "string" && type !== options.type) {
          throw new Error("Type transform cannot be a string (type '" + options.type + "' for token '" + type + "')");
        }
        var match2 = options.match;
        options.match = Array.isArray(match2) ? match2 : match2 ? [match2] : [];
        options.match.sort(function(a, b) {
          return isRegExp(a) && isRegExp(b) ? 0 : isRegExp(b) ? -1 : isRegExp(a) ? 1 : b.length - a.length;
        });
        return options;
      }
      function toRules(spec) {
        return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec);
      }
      var defaultErrorRule = ruleOptions("error", { lineBreaks: true, shouldThrow: true });
      function compileRules(rules, hasStates) {
        var errorRule = null;
        var fast = /* @__PURE__ */ Object.create(null);
        var fastAllowed = true;
        var unicodeFlag = null;
        var groups = [];
        var parts = [];
        for (var i2 = 0; i2 < rules.length; i2++) {
          if (rules[i2].fallback) {
            fastAllowed = false;
          }
        }
        for (var i2 = 0; i2 < rules.length; i2++) {
          var options = rules[i2];
          if (options.include) {
            throw new Error("Inheritance is not allowed in stateless lexers");
          }
          if (options.error || options.fallback) {
            if (errorRule) {
              if (!options.fallback === !errorRule.fallback) {
                throw new Error("Multiple " + (options.fallback ? "fallback" : "error") + " rules not allowed (for token '" + options.defaultType + "')");
              } else {
                throw new Error("fallback and error are mutually exclusive (for token '" + options.defaultType + "')");
              }
            }
            errorRule = options;
          }
          var match2 = options.match.slice();
          if (fastAllowed) {
            while (match2.length && typeof match2[0] === "string" && match2[0].length === 1) {
              var word = match2.shift();
              fast[word.charCodeAt(0)] = options;
            }
          }
          if (options.pop || options.push || options.next) {
            if (!hasStates) {
              throw new Error("State-switching options are not allowed in stateless lexers (for token '" + options.defaultType + "')");
            }
            if (options.fallback) {
              throw new Error("State-switching options are not allowed on fallback tokens (for token '" + options.defaultType + "')");
            }
          }
          if (match2.length === 0) {
            continue;
          }
          fastAllowed = false;
          groups.push(options);
          for (var j = 0; j < match2.length; j++) {
            var obj = match2[j];
            if (!isRegExp(obj)) {
              continue;
            }
            if (unicodeFlag === null) {
              unicodeFlag = obj.unicode;
            } else if (unicodeFlag !== obj.unicode && options.fallback === false) {
              throw new Error("If one rule is /u then all must be");
            }
          }
          var pat = reUnion(match2.map(regexpOrLiteral));
          var regexp = new RegExp(pat);
          if (regexp.test("")) {
            throw new Error("RegExp matches empty string: " + regexp);
          }
          var groupCount = reGroups(pat);
          if (groupCount > 0) {
            throw new Error("RegExp has capture groups: " + regexp + "\nUse (?: \u2026 ) instead");
          }
          if (!options.lineBreaks && regexp.test("\n")) {
            throw new Error("Rule should declare lineBreaks: " + regexp);
          }
          parts.push(reCapture(pat));
        }
        var fallbackRule = errorRule && errorRule.fallback;
        var flags = hasSticky && !fallbackRule ? "ym" : "gm";
        var suffix = hasSticky || fallbackRule ? "" : "|";
        if (unicodeFlag === true)
          flags += "u";
        var combined = new RegExp(reUnion(parts) + suffix, flags);
        return { regexp: combined, groups, fast, error: errorRule || defaultErrorRule };
      }
      function compile(rules) {
        var result = compileRules(toRules(rules));
        return new Lexer({ start: result }, "start");
      }
      function checkStateGroup(g, name, map) {
        var state = g && (g.push || g.next);
        if (state && !map[state]) {
          throw new Error("Missing state '" + state + "' (in token '" + g.defaultType + "' of state '" + name + "')");
        }
        if (g && g.pop && +g.pop !== 1) {
          throw new Error("pop must be 1 (in token '" + g.defaultType + "' of state '" + name + "')");
        }
      }
      function compileStates(states, start) {
        var all = states.$all ? toRules(states.$all) : [];
        delete states.$all;
        var keys = Object.getOwnPropertyNames(states);
        if (!start)
          start = keys[0];
        var ruleMap = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0; i2 < keys.length; i2++) {
          var key2 = keys[i2];
          ruleMap[key2] = toRules(states[key2]).concat(all);
        }
        for (var i2 = 0; i2 < keys.length; i2++) {
          var key2 = keys[i2];
          var rules = ruleMap[key2];
          var included = /* @__PURE__ */ Object.create(null);
          for (var j = 0; j < rules.length; j++) {
            var rule = rules[j];
            if (!rule.include)
              continue;
            var splice = [j, 1];
            if (rule.include !== key2 && !included[rule.include]) {
              included[rule.include] = true;
              var newRules = ruleMap[rule.include];
              if (!newRules) {
                throw new Error("Cannot include nonexistent state '" + rule.include + "' (in state '" + key2 + "')");
              }
              for (var k = 0; k < newRules.length; k++) {
                var newRule = newRules[k];
                if (rules.indexOf(newRule) !== -1)
                  continue;
                splice.push(newRule);
              }
            }
            rules.splice.apply(rules, splice);
            j--;
          }
        }
        var map = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0; i2 < keys.length; i2++) {
          var key2 = keys[i2];
          map[key2] = compileRules(ruleMap[key2], true);
        }
        for (var i2 = 0; i2 < keys.length; i2++) {
          var name = keys[i2];
          var state = map[name];
          var groups = state.groups;
          for (var j = 0; j < groups.length; j++) {
            checkStateGroup(groups[j], name, map);
          }
          var fastKeys = Object.getOwnPropertyNames(state.fast);
          for (var j = 0; j < fastKeys.length; j++) {
            checkStateGroup(state.fast[fastKeys[j]], name, map);
          }
        }
        return new Lexer(map, start);
      }
      function keywordTransform(map) {
        var reverseMap = /* @__PURE__ */ Object.create(null);
        var byLength = /* @__PURE__ */ Object.create(null);
        var types3 = Object.getOwnPropertyNames(map);
        for (var i2 = 0; i2 < types3.length; i2++) {
          var tokenType = types3[i2];
          var item = map[tokenType];
          var keywordList = Array.isArray(item) ? item : [item];
          keywordList.forEach(function(keyword) {
            (byLength[keyword.length] = byLength[keyword.length] || []).push(keyword);
            if (typeof keyword !== "string") {
              throw new Error("keyword must be string (in keyword '" + tokenType + "')");
            }
            reverseMap[keyword] = tokenType;
          });
        }
        function str(x2) {
          return JSON.stringify(x2);
        }
        var source = "";
        source += "switch (value.length) {\n";
        for (var length in byLength) {
          var keywords = byLength[length];
          source += "case " + length + ":\n";
          source += "switch (value) {\n";
          keywords.forEach(function(keyword) {
            var tokenType2 = reverseMap[keyword];
            source += "case " + str(keyword) + ": return " + str(tokenType2) + "\n";
          });
          source += "}\n";
        }
        source += "}\n";
        return Function("value", source);
      }
      var Lexer = function(states, state) {
        this.startState = state;
        this.states = states;
        this.buffer = "";
        this.stack = [];
        this.reset();
      };
      Lexer.prototype.reset = function(data, info) {
        this.buffer = data || "";
        this.index = 0;
        this.line = info ? info.line : 1;
        this.col = info ? info.col : 1;
        this.queuedToken = info ? info.queuedToken : null;
        this.queuedThrow = info ? info.queuedThrow : null;
        this.setState(info ? info.state : this.startState);
        this.stack = info && info.stack ? info.stack.slice() : [];
        return this;
      };
      Lexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.col,
          state: this.state,
          stack: this.stack.slice(),
          queuedToken: this.queuedToken,
          queuedThrow: this.queuedThrow
        };
      };
      Lexer.prototype.setState = function(state) {
        if (!state || this.state === state)
          return;
        this.state = state;
        var info = this.states[state];
        this.groups = info.groups;
        this.error = info.error;
        this.re = info.regexp;
        this.fast = info.fast;
      };
      Lexer.prototype.popState = function() {
        this.setState(this.stack.pop());
      };
      Lexer.prototype.pushState = function(state) {
        this.stack.push(this.state);
        this.setState(state);
      };
      var eat = hasSticky ? function(re, buffer) {
        return re.exec(buffer);
      } : function(re, buffer) {
        var match2 = re.exec(buffer);
        if (match2[0].length === 0) {
          return null;
        }
        return match2;
      };
      Lexer.prototype._getGroup = function(match2) {
        var groupCount = this.groups.length;
        for (var i2 = 0; i2 < groupCount; i2++) {
          if (match2[i2 + 1] !== void 0) {
            return this.groups[i2];
          }
        }
        throw new Error("Cannot find token type for matched text");
      };
      function tokenToString() {
        return this.value;
      }
      Lexer.prototype.next = function() {
        var index = this.index;
        if (this.queuedGroup) {
          var token = this._token(this.queuedGroup, this.queuedText, index);
          this.queuedGroup = null;
          this.queuedText = "";
          return token;
        }
        var buffer = this.buffer;
        if (index === buffer.length) {
          return;
        }
        var group = this.fast[buffer.charCodeAt(index)];
        if (group) {
          return this._token(group, buffer.charAt(index), index);
        }
        var re = this.re;
        re.lastIndex = index;
        var match2 = eat(re, buffer);
        var error2 = this.error;
        if (match2 == null) {
          return this._token(error2, buffer.slice(index, buffer.length), index);
        }
        var group = this._getGroup(match2);
        var text = match2[0];
        if (error2.fallback && match2.index !== index) {
          this.queuedGroup = group;
          this.queuedText = text;
          return this._token(error2, buffer.slice(index, match2.index), index);
        }
        return this._token(group, text, index);
      };
      Lexer.prototype._token = function(group, text, offset2) {
        var lineBreaks = 0;
        if (group.lineBreaks) {
          var matchNL = /\n/g;
          var nl = 1;
          if (text === "\n") {
            lineBreaks = 1;
          } else {
            while (matchNL.exec(text)) {
              lineBreaks++;
              nl = matchNL.lastIndex;
            }
          }
        }
        var token = {
          type: typeof group.type === "function" && group.type(text) || group.defaultType,
          value: typeof group.value === "function" ? group.value(text) : text,
          text,
          toString: tokenToString,
          offset: offset2,
          lineBreaks,
          line: this.line,
          col: this.col
        };
        var size = text.length;
        this.index += size;
        this.line += lineBreaks;
        if (lineBreaks !== 0) {
          this.col = size - nl + 1;
        } else {
          this.col += size;
        }
        if (group.shouldThrow) {
          throw new Error(this.formatError(token, "invalid syntax"));
        }
        if (group.pop)
          this.popState();
        else if (group.push)
          this.pushState(group.push);
        else if (group.next)
          this.setState(group.next);
        return token;
      };
      if (typeof Symbol !== "undefined" && Symbol.iterator) {
        var LexerIterator = function(lexer) {
          this.lexer = lexer;
        };
        LexerIterator.prototype.next = function() {
          var token = this.lexer.next();
          return { value: token, done: !token };
        };
        LexerIterator.prototype[Symbol.iterator] = function() {
          return this;
        };
        Lexer.prototype[Symbol.iterator] = function() {
          return new LexerIterator(this);
        };
      }
      Lexer.prototype.formatError = function(token, message) {
        if (token == null) {
          var text = this.buffer.slice(this.index);
          var token = {
            text,
            offset: this.index,
            lineBreaks: text.indexOf("\n") === -1 ? 0 : 1,
            line: this.line,
            col: this.col
          };
        }
        var start = Math.max(0, token.offset - token.col + 1);
        var eol = token.lineBreaks ? token.text.indexOf("\n") : token.text.length;
        var firstLine = this.buffer.substring(start, token.offset + eol);
        message += " at line " + token.line + " col " + token.col + ":\n\n";
        message += "  " + firstLine + "\n";
        message += "  " + Array(token.col).join(" ") + "^";
        return message;
      };
      Lexer.prototype.clone = function() {
        return new Lexer(this.states, this.state);
      };
      Lexer.prototype.has = function(tokenType) {
        return true;
      };
      return {
        compile,
        states: compileStates,
        error: Object.freeze({ error: true }),
        fallback: Object.freeze({ fallback: true }),
        keywords: keywordTransform
      };
    });
  }
});

// node_modules/parseley/lib/parseley.cjs
var require_parseley = __commonJS({
  "node_modules/parseley/lib/parseley.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var nearley = require_nearley();
    var moo = require_moo();
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n = /* @__PURE__ */ Object.create(null);
      if (e2) {
        Object.keys(e2).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e2, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e2[k];
              }
            });
          }
        });
      }
      n["default"] = e2;
      return Object.freeze(n);
    }
    var moo__namespace = /* @__PURE__ */ _interopNamespace(moo);
    function id(d) {
      return d[0];
    }
    var lexer = moo__namespace.compile({
      ws: { match: /[ \t\r\n\f]+/, lineBreaks: true },
      idn: { match: /[a-zA-Z_-][a-zA-Z0-9_-]*/ },
      hashToken: { match: /#[a-zA-Z0-9_-]+/, value: (s3) => s3.slice(1) },
      str1: { match: /'(?:\\['\\]|[^\n'\\])*'/, value: (s3) => s3.slice(1, -1) },
      str2: { match: /"(?:\\["\\]|[^\n"\\])*"/, value: (s3) => s3.slice(1, -1) },
      asterisk: "*",
      fullstop: ".",
      comma: ",",
      lbr: "[",
      rbr: "]",
      eq: "=",
      gt: ">",
      vbar: "|",
      plus: "+",
      tilde: "~",
      caret: "^",
      dollar: "$"
    });
    function firstTokenValue(tokens) {
      return tokens[0].value;
    }
    function second(tokens) {
      return tokens[1];
    }
    function sumSpec([a0, a1, a2], [b0, b1, b2]) {
      return [a0 + b0, a1 + b1, a2 + b2];
    }
    var grammar = {
      Lexer: lexer,
      ParserRules: [
        { "name": "main", "symbols": ["_", "listSelector", "_"], "postprocess": second },
        { "name": "mainNoList", "symbols": ["_", "complexSelector", "_"], "postprocess": second },
        { "name": "listSelector", "symbols": ["complexSelector"], "postprocess": ([next]) => ({ type: "list", list: [next] }) },
        { "name": "listSelector", "symbols": ["listSelector", "_", lexer.has("comma") ? { type: "comma" } : comma, "_", "complexSelector"], "postprocess": ([acc, , , , next]) => ({ type: "list", list: [...acc.list, next] }) },
        { "name": "complexSelector", "symbols": ["compoundSelector"], "postprocess": id },
        { "name": "complexSelector", "symbols": ["complexSelector", "__", "compoundSelector"], "postprocess": ([left, , right]) => ({
          type: "compound",
          list: [...right.list, { type: "combinator", combinator: " ", left, specificity: left.specificity }],
          specificity: sumSpec(left.specificity, right.specificity)
        }) },
        { "name": "complexSelector", "symbols": ["complexSelector", "_", "combinator", "_", "compoundSelector"], "postprocess": ([left, , c, , right]) => ({
          type: "compound",
          list: [...right.list, { type: "combinator", combinator: c, left, specificity: left.specificity }],
          specificity: sumSpec(left.specificity, right.specificity)
        }) },
        { "name": "combinator", "symbols": [lexer.has("gt") ? { type: "gt" } : gt], "postprocess": () => ">" },
        { "name": "combinator", "symbols": [lexer.has("plus") ? { type: "plus" } : plus], "postprocess": () => "+" },
        { "name": "combinator", "symbols": [lexer.has("tilde") ? { type: "tilde" } : tilde], "postprocess": () => "~" },
        { "name": "combinator", "symbols": [lexer.has("vbar") ? { type: "vbar" } : vbar, lexer.has("vbar") ? { type: "vbar" } : vbar], "postprocess": () => "||" },
        { "name": "compoundSelector", "symbols": ["typeSelector"], "postprocess": ([next]) => ({
          type: "compound",
          list: [next],
          specificity: next.specificity
        }) },
        { "name": "compoundSelector", "symbols": ["subclassSelector"], "postprocess": ([next]) => ({
          type: "compound",
          list: [next],
          specificity: next.specificity
        }) },
        { "name": "compoundSelector", "symbols": ["compoundSelector", "subclassSelector"], "postprocess": ([acc, next]) => ({
          type: "compound",
          list: [...acc.list, next],
          specificity: sumSpec(acc.specificity, next.specificity)
        }) },
        { "name": "subclassSelector", "symbols": ["idSelector"], "postprocess": id },
        { "name": "subclassSelector", "symbols": ["classSelector"], "postprocess": id },
        { "name": "subclassSelector", "symbols": ["attrSelector"], "postprocess": id },
        { "name": "attrSelector", "symbols": ["attrPresenceSelector"], "postprocess": id },
        { "name": "attrSelector", "symbols": ["attrValueSelector"], "postprocess": id },
        { "name": "typeSelector", "symbols": ["tagSelector"], "postprocess": id },
        { "name": "typeSelector", "symbols": ["uniSelector"], "postprocess": id },
        {
          "name": "attrPresenceSelector",
          "symbols": [lexer.has("lbr") ? { type: "lbr" } : lbr, "_", "wqname", "_", lexer.has("rbr") ? { type: "rbr" } : rbr],
          "postprocess": ([, , wqname]) => ({
            type: "attrPresence",
            name: wqname.name,
            namespace: wqname.namespace,
            specificity: [0, 1, 0]
          })
        },
        {
          "name": "attrValueSelector",
          "symbols": [lexer.has("lbr") ? { type: "lbr" } : lbr, "_", "wqname", "_", "attrMatcher", "_", "attrValue", "_", lexer.has("rbr") ? { type: "rbr" } : rbr],
          "postprocess": ([, , wqname, , matcher, , v]) => ({
            type: "attrValue",
            name: wqname.name,
            namespace: wqname.namespace,
            matcher,
            value: v.value,
            modifier: v.modifier,
            specificity: [0, 1, 0]
          })
        },
        { "name": "attrMatcher", "symbols": [lexer.has("eq") ? { type: "eq" } : eq], "postprocess": () => "=" },
        { "name": "attrMatcher", "symbols": [lexer.has("tilde") ? { type: "tilde" } : tilde, lexer.has("eq") ? { type: "eq" } : eq], "postprocess": () => "~=" },
        { "name": "attrMatcher", "symbols": [lexer.has("vbar") ? { type: "vbar" } : vbar, lexer.has("eq") ? { type: "eq" } : eq], "postprocess": () => "|=" },
        { "name": "attrMatcher", "symbols": [lexer.has("caret") ? { type: "caret" } : caret, lexer.has("eq") ? { type: "eq" } : eq], "postprocess": () => "^=" },
        { "name": "attrMatcher", "symbols": [lexer.has("dollar") ? { type: "dollar" } : dollar, lexer.has("eq") ? { type: "eq" } : eq], "postprocess": () => "$=" },
        { "name": "attrMatcher", "symbols": [lexer.has("asterisk") ? { type: "asterisk" } : asterisk, lexer.has("eq") ? { type: "eq" } : eq], "postprocess": () => "*=" },
        { "name": "attrValue", "symbols": ["str"], "postprocess": ([v]) => ({ value: v, modifier: null }) },
        { "name": "attrValue", "symbols": ["idn"], "postprocess": ([v]) => ({ value: v, modifier: null }) },
        { "name": "attrValue", "symbols": ["str", "_", "attrModifier"], "postprocess": ([v, , mod]) => ({ value: v, modifier: mod }) },
        { "name": "attrValue", "symbols": ["idn", "__", "attrModifier"], "postprocess": ([v, , mod]) => ({ value: v, modifier: mod }) },
        { "name": "attrModifier", "symbols": [{ "literal": "i" }], "postprocess": () => "i" },
        { "name": "attrModifier", "symbols": [{ "literal": "I" }], "postprocess": () => "i" },
        { "name": "attrModifier", "symbols": [{ "literal": "s" }], "postprocess": () => "s" },
        { "name": "attrModifier", "symbols": [{ "literal": "S" }], "postprocess": () => "s" },
        { "name": "idSelector", "symbols": [lexer.has("hashToken") ? { type: "hashToken" } : hashToken], "postprocess": ([{ value: name }]) => ({ type: "id", name, specificity: [1, 0, 0] }) },
        { "name": "classSelector", "symbols": [lexer.has("fullstop") ? { type: "fullstop" } : fullstop, "idn"], "postprocess": ([, name]) => ({ type: "class", name, specificity: [0, 1, 0] }) },
        {
          "name": "tagSelector",
          "symbols": ["wqname"],
          "postprocess": ([wqname]) => ({
            type: "tag",
            name: wqname.name,
            namespace: wqname.namespace,
            specificity: [0, 0, 1]
          })
        },
        { "name": "uniSelector", "symbols": [lexer.has("asterisk") ? { type: "asterisk" } : asterisk], "postprocess": () => ({ type: "universal", namespace: null, specificity: [0, 0, 0] }) },
        { "name": "uniSelector", "symbols": ["ns", lexer.has("asterisk") ? { type: "asterisk" } : asterisk], "postprocess": ([ns]) => ({ type: "universal", namespace: ns, specificity: [0, 0, 0] }) },
        { "name": "wqname", "symbols": ["idn"], "postprocess": ([name]) => ({ name, namespace: null }) },
        { "name": "wqname", "symbols": ["ns", "idn"], "postprocess": ([ns, name]) => ({ name, namespace: ns }) },
        { "name": "ns", "symbols": [lexer.has("vbar") ? { type: "vbar" } : vbar], "postprocess": () => "" },
        { "name": "ns", "symbols": ["idn", lexer.has("vbar") ? { type: "vbar" } : vbar], "postprocess": id },
        { "name": "str", "symbols": [lexer.has("str1") ? { type: "str1" } : str1], "postprocess": firstTokenValue },
        { "name": "str", "symbols": [lexer.has("str2") ? { type: "str2" } : str2], "postprocess": firstTokenValue },
        { "name": "idn", "symbols": [lexer.has("idn") ? { type: "idn" } : idn], "postprocess": firstTokenValue },
        { "name": "_$ebnf$1", "symbols": [lexer.has("ws") ? { type: "ws" } : ws], "postprocess": id },
        { "name": "_$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "_", "symbols": ["_$ebnf$1"], "postprocess": () => null },
        { "name": "__", "symbols": [lexer.has("ws") ? { type: "ws" } : ws], "postprocess": () => null }
      ],
      ParserStart: "main"
    };
    var ast = /* @__PURE__ */ Object.freeze({
      __proto__: null
    });
    var compiledRulesNoList = __spreadProps(__spreadValues({}, grammar), { ParserStart: "mainNoList" });
    function parse3(str) {
      return _parse(grammar, str);
    }
    function parse1(str) {
      return _parse(compiledRulesNoList, str);
    }
    function _parse(compiledRules1, str) {
      const parser = new nearley.Parser(nearley.Grammar.fromCompiled(compiledRules1));
      parser.feed(str);
      if (parser.results.length === 0) {
        throw new Error("Failed to parse - input string might be incomplete.");
      }
      return parser.results[0];
    }
    function serialize2(selector) {
      if (!selector.type) {
        throw new Error("This is not an AST node.");
      }
      switch (selector.type) {
        case "universal":
          return _serNs(selector.namespace) + "*";
        case "tag":
          return _serNs(selector.namespace) + selector.name;
        case "class":
          return "." + selector.name;
        case "id":
          return "#" + selector.name;
        case "attrPresence":
          return `[${_serNs(selector.namespace)}${selector.name}]`;
        case "attrValue":
          return `[${_serNs(selector.namespace)}${selector.name}${selector.matcher}${_serStr(selector.value)}${selector.modifier ? selector.modifier : ""}]`;
        case "combinator":
          return serialize2(selector.left) + selector.combinator;
        case "compound":
          return selector.list.reduce((acc, node) => {
            if (node.type === "combinator") {
              return serialize2(node) + acc;
            } else {
              return acc + serialize2(node);
            }
          }, "");
        case "list":
          return selector.list.map(serialize2).join(",");
      }
    }
    function _serNs(ns) {
      return ns || ns === "" ? ns + "|" : "";
    }
    function _serStr(str) {
      if (str.indexOf('"') === -1) {
        return `"${str}"`;
      } else if (str.indexOf("'") === -1) {
        return `'${str}'`;
      } else {
        return `"${str.replace('"', '\\"')}"`;
      }
    }
    function normalize2(selector) {
      if (!selector.type) {
        throw new Error("This is not an AST node.");
      }
      switch (selector.type) {
        case "compound": {
          selector.list.forEach(normalize2);
          selector.list.sort((a, b) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b)));
          break;
        }
        case "combinator": {
          normalize2(selector.left);
          break;
        }
        case "list": {
          selector.list.forEach(normalize2);
          selector.list.sort((a, b) => serialize2(a) < serialize2(b) ? -1 : 1);
          break;
        }
      }
      return selector;
    }
    function _getSelectorPriority(selector) {
      switch (selector.type) {
        case "universal":
          return [1];
        case "tag":
          return [1];
        case "id":
          return [2];
        case "class":
          return [3, selector.name];
        case "attrPresence":
          return [4, serialize2(selector)];
        case "attrValue":
          return [5, serialize2(selector)];
        case "combinator":
          return [15, serialize2(selector)];
      }
    }
    function compareSelectors(a, b) {
      return _compareArrays(a.specificity, b.specificity);
    }
    function compareSpecificity(a, b) {
      return _compareArrays(a, b);
    }
    function _compareArrays(a, b) {
      if (!Array.isArray(a) || !Array.isArray(b)) {
        throw new Error("Arguments must be arrays.");
      }
      const shorter = a.length < b.length ? a.length : b.length;
      for (let i2 = 0; i2 < shorter; i2++) {
        if (a[i2] === b[i2]) {
          continue;
        }
        return a[i2] < b[i2] ? -1 : 1;
      }
      return a.length - b.length;
    }
    exports.Ast = ast;
    exports.compareSelectors = compareSelectors;
    exports.compareSpecificity = compareSpecificity;
    exports.normalize = normalize2;
    exports.parse = parse3;
    exports.parse1 = parse1;
    exports.serialize = serialize2;
  }
});

// node_modules/selderee/lib/selderee.cjs
var require_selderee = __commonJS({
  "node_modules/selderee/lib/selderee.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var parseley = require_parseley();
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n = /* @__PURE__ */ Object.create(null);
      if (e2) {
        Object.keys(e2).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e2, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e2[k];
              }
            });
          }
        });
      }
      n["default"] = e2;
      return Object.freeze(n);
    }
    var parseley__namespace = /* @__PURE__ */ _interopNamespace(parseley);
    var Ast = /* @__PURE__ */ Object.freeze({
      __proto__: null
    });
    var Types = /* @__PURE__ */ Object.freeze({
      __proto__: null
    });
    var treeify = (nodes) => "\u25BD\n" + treeifyArray(nodes, thinLines);
    var thinLines = [["\u251C\u2500", "\u2502 "], ["\u2514\u2500", "  "]];
    var heavyLines = [["\u2520\u2500", "\u2503 "], ["\u2516\u2500", "  "]];
    var doubleLines = [["\u255F\u2500", "\u2551 "], ["\u2559\u2500", "  "]];
    function treeifyArray(nodes, tpl = heavyLines) {
      return prefixItems(tpl, nodes.map((n) => treeifyNode(n)));
    }
    function treeifyNode(node) {
      switch (node.type) {
        case "terminal": {
          const vctr = node.valueContainer;
          return `\u25C1 #${vctr.index} ${JSON.stringify(vctr.specificity)} ${vctr.value}`;
        }
        case "tagName":
          return `\u25FB Tag name
${treeifyArray(node.variants, doubleLines)}`;
        case "attrValue":
          return `\u25A3 Attr value: ${node.name}
${treeifyArray(node.matchers, doubleLines)}`;
        case "attrPresence":
          return `\u25E8 Attr presence: ${node.name}
${treeifyArray(node.cont)}`;
        case "pushElement":
          return `\u25C9 Push element: ${node.combinator}
${treeifyArray(node.cont, thinLines)}`;
        case "popElement":
          return `\u25CC Pop element
${treeifyArray(node.cont, thinLines)}`;
        case "variant":
          return `\u25C7 = ${node.value}
${treeifyArray(node.cont)}`;
        case "matcher":
          return `\u25C8 ${node.matcher} "${node.value}"${node.modifier || ""}
${treeifyArray(node.cont)}`;
      }
    }
    function prefixItems(tpl, items) {
      return items.map((item, i2, { length }) => prefixItem(tpl, item, i2 === length - 1)).join("\n");
    }
    function prefixItem(tpl, item, tail = true) {
      const tpl1 = tpl[tail ? 1 : 0];
      return tpl1[0] + item.split("\n").join("\n" + tpl1[1]);
    }
    var TreeifyBuilder = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      treeify
    });
    var DecisionTree = class {
      constructor(input) {
        this.branches = weave(toAstTerminalPairs(input));
      }
      build(builder) {
        return builder(this.branches);
      }
    };
    function toAstTerminalPairs(array) {
      const len = array.length;
      const results = new Array(len);
      for (let i2 = 0; i2 < len; i2++) {
        const [selectorString, val] = array[i2];
        const ast = preprocess(parseley__namespace.parse1(selectorString));
        results[i2] = {
          ast,
          terminal: {
            type: "terminal",
            valueContainer: { index: i2, value: val, specificity: ast.specificity }
          }
        };
      }
      return results;
    }
    function preprocess(ast) {
      reduceSelectorVariants(ast);
      parseley__namespace.normalize(ast);
      return ast;
    }
    function reduceSelectorVariants(ast) {
      const newList = [];
      ast.list.forEach((sel) => {
        switch (sel.type) {
          case "class":
            newList.push({
              matcher: "~=",
              modifier: null,
              name: "class",
              namespace: null,
              specificity: sel.specificity,
              type: "attrValue",
              value: sel.name
            });
            break;
          case "id":
            newList.push({
              matcher: "=",
              modifier: null,
              name: "id",
              namespace: null,
              specificity: sel.specificity,
              type: "attrValue",
              value: sel.name
            });
            break;
          case "combinator":
            reduceSelectorVariants(sel.left);
            newList.push(sel);
            break;
          case "universal":
            break;
          default:
            newList.push(sel);
            break;
        }
      });
      ast.list = newList;
    }
    function weave(items) {
      const branches = [];
      while (items.length) {
        const topKind = findTopKey(items, (sel) => true, getSelectorKind);
        const { matches, nonmatches, empty } = breakByKind(items, topKind);
        items = nonmatches;
        if (matches.length) {
          branches.push(branchOfKind(topKind, matches));
        }
        if (empty.length) {
          branches.push(...terminate(empty));
        }
      }
      return branches;
    }
    function terminate(items) {
      const results = [];
      for (const item of items) {
        const terminal = item.terminal;
        if (terminal.type === "terminal") {
          results.push(terminal);
        } else {
          const { matches, rest } = partition(terminal.cont, (node) => node.type === "terminal");
          matches.forEach((node) => results.push(node));
          if (rest.length) {
            terminal.cont = rest;
            results.push(terminal);
          }
        }
      }
      return results;
    }
    function breakByKind(items, selectedKind) {
      const matches = [];
      const nonmatches = [];
      const empty = [];
      for (const item of items) {
        const simpsels = item.ast.list;
        if (simpsels.length) {
          const isMatch = simpsels.some((node) => getSelectorKind(node) === selectedKind);
          (isMatch ? matches : nonmatches).push(item);
        } else {
          empty.push(item);
        }
      }
      return { matches, nonmatches, empty };
    }
    function getSelectorKind(sel) {
      switch (sel.type) {
        case "attrPresence":
          return `attrPresence ${sel.name}`;
        case "attrValue":
          return `attrValue ${sel.name}`;
        case "combinator":
          return `combinator ${sel.combinator}`;
        default:
          return sel.type;
      }
    }
    function branchOfKind(kind, items) {
      if (kind === "tag") {
        return tagNameBranch(items);
      }
      if (kind.startsWith("attrValue ")) {
        return attrValueBranch(kind.substring(10), items);
      }
      if (kind.startsWith("attrPresence ")) {
        return attrPresenceBranch(kind.substring(13), items);
      }
      if (kind === "combinator >") {
        return combinatorBranch(">", items);
      }
      if (kind === "combinator +") {
        return combinatorBranch("+", items);
      }
      throw new Error(`Unsupported selector kind: ${kind}`);
    }
    function tagNameBranch(items) {
      const groups = spliceAndGroup(items, (x2) => x2.type === "tag", (x2) => x2.name);
      const variants = Object.entries(groups).map(([name, group]) => ({
        type: "variant",
        value: name,
        cont: weave(group.items)
      }));
      return {
        type: "tagName",
        variants
      };
    }
    function attrPresenceBranch(name, items) {
      for (const item of items) {
        spliceSimpleSelector(item, (x2) => x2.type === "attrPresence" && x2.name === name);
      }
      return {
        type: "attrPresence",
        name,
        cont: weave(items)
      };
    }
    function attrValueBranch(name, items) {
      const groups = spliceAndGroup(items, (x2) => x2.type === "attrValue" && x2.name === name, (x2) => `${x2.matcher} ${x2.modifier || ""} ${x2.value}`);
      const matchers = [];
      for (const group of Object.values(groups)) {
        const sel = group.oneSimpleSelector;
        const predicate = getAttrPredicate(sel);
        const continuation = weave(group.items);
        matchers.push({
          type: "matcher",
          matcher: sel.matcher,
          modifier: sel.modifier,
          value: sel.value,
          predicate,
          cont: continuation
        });
      }
      return {
        type: "attrValue",
        name,
        matchers
      };
    }
    function getAttrPredicate(sel) {
      if (sel.modifier === "i") {
        const expected = sel.value.toLowerCase();
        switch (sel.matcher) {
          case "=":
            return (actual) => expected === actual.toLowerCase();
          case "~=":
            return (actual) => actual.toLowerCase().split(/[ \t]+/).includes(expected);
          case "^=":
            return (actual) => actual.toLowerCase().startsWith(expected);
          case "$=":
            return (actual) => actual.toLowerCase().endsWith(expected);
          case "*=":
            return (actual) => actual.toLowerCase().includes(expected);
          case "|=":
            return (actual) => {
              const lower2 = actual.toLowerCase();
              return expected === lower2 || lower2.startsWith(expected) && lower2[expected.length] === "-";
            };
        }
      } else {
        const expected = sel.value;
        switch (sel.matcher) {
          case "=":
            return (actual) => expected === actual;
          case "~=":
            return (actual) => actual.split(/[ \t]+/).includes(expected);
          case "^=":
            return (actual) => actual.startsWith(expected);
          case "$=":
            return (actual) => actual.endsWith(expected);
          case "*=":
            return (actual) => actual.includes(expected);
          case "|=":
            return (actual) => expected === actual || actual.startsWith(expected) && actual[expected.length] === "-";
        }
      }
    }
    function combinatorBranch(combinator, items) {
      const groups = spliceAndGroup(items, (x2) => x2.type === "combinator" && x2.combinator === combinator, (x2) => parseley__namespace.serialize(x2.left));
      const leftItems = [];
      for (const group of Object.values(groups)) {
        const rightCont = weave(group.items);
        const leftAst = group.oneSimpleSelector.left;
        leftItems.push({
          ast: leftAst,
          terminal: { type: "popElement", cont: rightCont }
        });
      }
      return {
        type: "pushElement",
        combinator,
        cont: weave(leftItems)
      };
    }
    function spliceAndGroup(items, predicate, keyCallback) {
      const groups = {};
      while (items.length) {
        const bestKey = findTopKey(items, predicate, keyCallback);
        const bestKeyPredicate = (sel) => predicate(sel) && keyCallback(sel) === bestKey;
        const hasBestKeyPredicate = (item) => item.ast.list.some(bestKeyPredicate);
        const { matches, rest } = partition1(items, hasBestKeyPredicate);
        let oneSimpleSelector = null;
        for (const item of matches) {
          const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);
          if (!oneSimpleSelector) {
            oneSimpleSelector = splicedNode;
          }
        }
        if (oneSimpleSelector == null) {
          throw new Error("No simple selector is found.");
        }
        groups[bestKey] = { oneSimpleSelector, items: matches };
        items = rest;
      }
      return groups;
    }
    function spliceSimpleSelector(item, predicate) {
      const simpsels = item.ast.list;
      const matches = new Array(simpsels.length);
      let firstIndex = -1;
      for (let i2 = simpsels.length; i2-- > 0; ) {
        if (predicate(simpsels[i2])) {
          matches[i2] = true;
          firstIndex = i2;
        }
      }
      if (firstIndex == -1) {
        throw new Error(`Couldn't find the required simple selector.`);
      }
      const result = simpsels[firstIndex];
      item.ast.list = simpsels.filter((sel, i2) => !matches[i2]);
      return result;
    }
    function findTopKey(items, predicate, keyCallback) {
      const candidates = {};
      for (const item of items) {
        const candidates1 = {};
        for (const node of item.ast.list.filter(predicate)) {
          candidates1[keyCallback(node)] = true;
        }
        for (const key2 of Object.keys(candidates1)) {
          if (candidates[key2]) {
            candidates[key2]++;
          } else {
            candidates[key2] = 1;
          }
        }
      }
      let topKind = "";
      let topCounter = 0;
      for (const entry11 of Object.entries(candidates)) {
        if (entry11[1] > topCounter) {
          topKind = entry11[0];
          topCounter = entry11[1];
        }
      }
      return topKind;
    }
    function partition(src, predicate) {
      const matches = [];
      const rest = [];
      for (const x2 of src) {
        if (predicate(x2)) {
          matches.push(x2);
        } else {
          rest.push(x2);
        }
      }
      return { matches, rest };
    }
    function partition1(src, predicate) {
      const matches = [];
      const rest = [];
      for (const x2 of src) {
        if (predicate(x2)) {
          matches.push(x2);
        } else {
          rest.push(x2);
        }
      }
      return { matches, rest };
    }
    var Picker = class {
      constructor(f3) {
        this.f = f3;
      }
      pickAll(el) {
        return this.f(el);
      }
      pick1(el, preferFirst = false) {
        const results = this.f(el);
        const len = results.length;
        if (len === 0) {
          return null;
        }
        if (len === 1) {
          return results[0].value;
        }
        const comparator = preferFirst ? comparatorPreferFirst : comparatorPreferLast;
        let result = results[0];
        for (let i2 = 1; i2 < len; i2++) {
          const next = results[i2];
          if (comparator(result, next)) {
            result = next;
          }
        }
        return result.value;
      }
    };
    function comparatorPreferFirst(acc, next) {
      const diff = parseley.compareSpecificity(next.specificity, acc.specificity);
      return diff > 0 || diff === 0 && next.index < acc.index;
    }
    function comparatorPreferLast(acc, next) {
      const diff = parseley.compareSpecificity(next.specificity, acc.specificity);
      return diff > 0 || diff === 0 && next.index > acc.index;
    }
    exports.Ast = Ast;
    exports.DecisionTree = DecisionTree;
    exports.Picker = Picker;
    exports.Treeify = TreeifyBuilder;
    exports.Types = Types;
  }
});

// node_modules/@selderee/plugin-htmlparser2/lib/hp2-builder.cjs
var require_hp2_builder = __commonJS({
  "node_modules/@selderee/plugin-htmlparser2/lib/hp2-builder.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var domhandler = require_lib3();
    var selderee = require_selderee();
    function hp2Builder(nodes) {
      return new selderee.Picker(handleArray(nodes));
    }
    function handleArray(nodes) {
      const matchers = nodes.map(handleNode);
      return (el, ...tail) => flatMap(matchers, (m2) => m2(el, ...tail));
    }
    function handleNode(node) {
      switch (node.type) {
        case "terminal": {
          const result = [node.valueContainer];
          return (el, ...tail) => result;
        }
        case "tagName":
          return handleTagName(node);
        case "attrValue":
          return handleAttrValueName(node);
        case "attrPresence":
          return handleAttrPresenceName(node);
        case "pushElement":
          return handlePushElementNode(node);
        case "popElement":
          return handlePopElementNode(node);
      }
    }
    function handleTagName(node) {
      const variants = {};
      for (const variant of node.variants) {
        variants[variant.value] = handleArray(variant.cont);
      }
      return (el, ...tail) => {
        const continuation = variants[el.name];
        return continuation ? continuation(el, ...tail) : [];
      };
    }
    function handleAttrPresenceName(node) {
      const attrName = node.name;
      const continuation = handleArray(node.cont);
      return (el, ...tail) => Object.prototype.hasOwnProperty.call(el.attribs, attrName) ? continuation(el, ...tail) : [];
    }
    function handleAttrValueName(node) {
      const callbacks = [];
      for (const matcher of node.matchers) {
        const predicate = matcher.predicate;
        const continuation = handleArray(matcher.cont);
        callbacks.push((attr, el, ...tail) => predicate(attr) ? continuation(el, ...tail) : []);
      }
      const attrName = node.name;
      return (el, ...tail) => {
        const attr = el.attribs[attrName];
        return attr || attr === "" ? flatMap(callbacks, (cb) => cb(attr, el, ...tail)) : [];
      };
    }
    function handlePushElementNode(node) {
      const continuation = handleArray(node.cont);
      const leftElementGetter = node.combinator === "+" ? getPrecedingElement : getParentElement;
      return (el, ...tail) => {
        const next = leftElementGetter(el);
        if (next === null) {
          return [];
        }
        return continuation(next, el, ...tail);
      };
    }
    var getPrecedingElement = (el) => {
      const prev = el.prev;
      if (prev === null) {
        return null;
      }
      return domhandler.isTag(prev) ? prev : getPrecedingElement(prev);
    };
    var getParentElement = (el) => {
      const parent = el.parent;
      return parent && domhandler.isTag(parent) ? parent : null;
    };
    function handlePopElementNode(node) {
      const continuation = handleArray(node.cont);
      return (el, next, ...tail) => continuation(next, ...tail);
    }
    function flatMap(items, mapper) {
      return [].concat(...amap(items, mapper));
    }
    function amap(items, mapper) {
      const len = items.length;
      const res = new Array(len);
      for (let i2 = 0; i2 < len; i2++) {
        res[i2] = mapper(items[i2]);
      }
      return res;
    }
    exports.hp2Builder = hp2Builder;
  }
});

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/deepmerge/dist/cjs.js"(exports, module2) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key2, options) {
      if (!options.customMerge) {
        return deepmerge;
      }
      var customMerge = options.customMerge(key2);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return target.propertyIsEnumerable(symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key2) {
      return propertyIsOnObject(target, key2) && !(Object.hasOwnProperty.call(target, key2) && Object.propertyIsEnumerable.call(target, key2));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key2) {
          destination[key2] = cloneUnlessOtherwiseSpecified(target[key2], options);
        });
      }
      getKeys(source).forEach(function(key2) {
        if (propertyIsUnsafe(target, key2)) {
          return;
        }
        if (propertyIsOnObject(target, key2) && options.isMergeableObject(source[key2])) {
          destination[key2] = getMergeFunction(key2, options)(target[key2], source[key2], options);
        } else {
          destination[key2] = cloneUnlessOtherwiseSpecified(source[key2], options);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    module2.exports = deepmerge_1;
  }
});

// node_modules/he/he.js
var require_he = __commonJS({
  "node_modules/he/he.js"(exports, module2) {
    (function(root) {
      var freeExports = typeof exports == "object" && exports;
      var freeModule = typeof module2 == "object" && module2 && module2.exports == freeExports && module2;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
      }
      var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var regexAsciiWhitelist = /[\x01-\x7F]/g;
      var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
      var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
      var encodeMap = { "\xAD": "shy", "\u200C": "zwnj", "\u200D": "zwj", "\u200E": "lrm", "\u2063": "ic", "\u2062": "it", "\u2061": "af", "\u200F": "rlm", "\u200B": "ZeroWidthSpace", "\u2060": "NoBreak", "\u0311": "DownBreve", "\u20DB": "tdot", "\u20DC": "DotDot", "	": "Tab", "\n": "NewLine", "\u2008": "puncsp", "\u205F": "MediumSpace", "\u2009": "thinsp", "\u200A": "hairsp", "\u2004": "emsp13", "\u2002": "ensp", "\u2005": "emsp14", "\u2003": "emsp", "\u2007": "numsp", "\xA0": "nbsp", "\u205F\u200A": "ThickSpace", "\u203E": "oline", "_": "lowbar", "\u2010": "dash", "\u2013": "ndash", "\u2014": "mdash", "\u2015": "horbar", ",": "comma", ";": "semi", "\u204F": "bsemi", ":": "colon", "\u2A74": "Colone", "!": "excl", "\xA1": "iexcl", "?": "quest", "\xBF": "iquest", ".": "period", "\u2025": "nldr", "\u2026": "mldr", "\xB7": "middot", "'": "apos", "\u2018": "lsquo", "\u2019": "rsquo", "\u201A": "sbquo", "\u2039": "lsaquo", "\u203A": "rsaquo", '"': "quot", "\u201C": "ldquo", "\u201D": "rdquo", "\u201E": "bdquo", "\xAB": "laquo", "\xBB": "raquo", "(": "lpar", ")": "rpar", "[": "lsqb", "]": "rsqb", "{": "lcub", "}": "rcub", "\u2308": "lceil", "\u2309": "rceil", "\u230A": "lfloor", "\u230B": "rfloor", "\u2985": "lopar", "\u2986": "ropar", "\u298B": "lbrke", "\u298C": "rbrke", "\u298D": "lbrkslu", "\u298E": "rbrksld", "\u298F": "lbrksld", "\u2990": "rbrkslu", "\u2991": "langd", "\u2992": "rangd", "\u2993": "lparlt", "\u2994": "rpargt", "\u2995": "gtlPar", "\u2996": "ltrPar", "\u27E6": "lobrk", "\u27E7": "robrk", "\u27E8": "lang", "\u27E9": "rang", "\u27EA": "Lang", "\u27EB": "Rang", "\u27EC": "loang", "\u27ED": "roang", "\u2772": "lbbrk", "\u2773": "rbbrk", "\u2016": "Vert", "\xA7": "sect", "\xB6": "para", "@": "commat", "*": "ast", "/": "sol", "undefined": null, "&": "amp", "#": "num", "%": "percnt", "\u2030": "permil", "\u2031": "pertenk", "\u2020": "dagger", "\u2021": "Dagger", "\u2022": "bull", "\u2043": "hybull", "\u2032": "prime", "\u2033": "Prime", "\u2034": "tprime", "\u2057": "qprime", "\u2035": "bprime", "\u2041": "caret", "`": "grave", "\xB4": "acute", "\u02DC": "tilde", "^": "Hat", "\xAF": "macr", "\u02D8": "breve", "\u02D9": "dot", "\xA8": "die", "\u02DA": "ring", "\u02DD": "dblac", "\xB8": "cedil", "\u02DB": "ogon", "\u02C6": "circ", "\u02C7": "caron", "\xB0": "deg", "\xA9": "copy", "\xAE": "reg", "\u2117": "copysr", "\u2118": "wp", "\u211E": "rx", "\u2127": "mho", "\u2129": "iiota", "\u2190": "larr", "\u219A": "nlarr", "\u2192": "rarr", "\u219B": "nrarr", "\u2191": "uarr", "\u2193": "darr", "\u2194": "harr", "\u21AE": "nharr", "\u2195": "varr", "\u2196": "nwarr", "\u2197": "nearr", "\u2198": "searr", "\u2199": "swarr", "\u219D": "rarrw", "\u219D\u0338": "nrarrw", "\u219E": "Larr", "\u219F": "Uarr", "\u21A0": "Rarr", "\u21A1": "Darr", "\u21A2": "larrtl", "\u21A3": "rarrtl", "\u21A4": "mapstoleft", "\u21A5": "mapstoup", "\u21A6": "map", "\u21A7": "mapstodown", "\u21A9": "larrhk", "\u21AA": "rarrhk", "\u21AB": "larrlp", "\u21AC": "rarrlp", "\u21AD": "harrw", "\u21B0": "lsh", "\u21B1": "rsh", "\u21B2": "ldsh", "\u21B3": "rdsh", "\u21B5": "crarr", "\u21B6": "cularr", "\u21B7": "curarr", "\u21BA": "olarr", "\u21BB": "orarr", "\u21BC": "lharu", "\u21BD": "lhard", "\u21BE": "uharr", "\u21BF": "uharl", "\u21C0": "rharu", "\u21C1": "rhard", "\u21C2": "dharr", "\u21C3": "dharl", "\u21C4": "rlarr", "\u21C5": "udarr", "\u21C6": "lrarr", "\u21C7": "llarr", "\u21C8": "uuarr", "\u21C9": "rrarr", "\u21CA": "ddarr", "\u21CB": "lrhar", "\u21CC": "rlhar", "\u21D0": "lArr", "\u21CD": "nlArr", "\u21D1": "uArr", "\u21D2": "rArr", "\u21CF": "nrArr", "\u21D3": "dArr", "\u21D4": "iff", "\u21CE": "nhArr", "\u21D5": "vArr", "\u21D6": "nwArr", "\u21D7": "neArr", "\u21D8": "seArr", "\u21D9": "swArr", "\u21DA": "lAarr", "\u21DB": "rAarr", "\u21DD": "zigrarr", "\u21E4": "larrb", "\u21E5": "rarrb", "\u21F5": "duarr", "\u21FD": "loarr", "\u21FE": "roarr", "\u21FF": "hoarr", "\u2200": "forall", "\u2201": "comp", "\u2202": "part", "\u2202\u0338": "npart", "\u2203": "exist", "\u2204": "nexist", "\u2205": "empty", "\u2207": "Del", "\u2208": "in", "\u2209": "notin", "\u220B": "ni", "\u220C": "notni", "\u03F6": "bepsi", "\u220F": "prod", "\u2210": "coprod", "\u2211": "sum", "+": "plus", "\xB1": "pm", "\xF7": "div", "\xD7": "times", "<": "lt", "\u226E": "nlt", "<\u20D2": "nvlt", "=": "equals", "\u2260": "ne", "=\u20E5": "bne", "\u2A75": "Equal", ">": "gt", "\u226F": "ngt", ">\u20D2": "nvgt", "\xAC": "not", "|": "vert", "\xA6": "brvbar", "\u2212": "minus", "\u2213": "mp", "\u2214": "plusdo", "\u2044": "frasl", "\u2216": "setmn", "\u2217": "lowast", "\u2218": "compfn", "\u221A": "Sqrt", "\u221D": "prop", "\u221E": "infin", "\u221F": "angrt", "\u2220": "ang", "\u2220\u20D2": "nang", "\u2221": "angmsd", "\u2222": "angsph", "\u2223": "mid", "\u2224": "nmid", "\u2225": "par", "\u2226": "npar", "\u2227": "and", "\u2228": "or", "\u2229": "cap", "\u2229\uFE00": "caps", "\u222A": "cup", "\u222A\uFE00": "cups", "\u222B": "int", "\u222C": "Int", "\u222D": "tint", "\u2A0C": "qint", "\u222E": "oint", "\u222F": "Conint", "\u2230": "Cconint", "\u2231": "cwint", "\u2232": "cwconint", "\u2233": "awconint", "\u2234": "there4", "\u2235": "becaus", "\u2236": "ratio", "\u2237": "Colon", "\u2238": "minusd", "\u223A": "mDDot", "\u223B": "homtht", "\u223C": "sim", "\u2241": "nsim", "\u223C\u20D2": "nvsim", "\u223D": "bsim", "\u223D\u0331": "race", "\u223E": "ac", "\u223E\u0333": "acE", "\u223F": "acd", "\u2240": "wr", "\u2242": "esim", "\u2242\u0338": "nesim", "\u2243": "sime", "\u2244": "nsime", "\u2245": "cong", "\u2247": "ncong", "\u2246": "simne", "\u2248": "ap", "\u2249": "nap", "\u224A": "ape", "\u224B": "apid", "\u224B\u0338": "napid", "\u224C": "bcong", "\u224D": "CupCap", "\u226D": "NotCupCap", "\u224D\u20D2": "nvap", "\u224E": "bump", "\u224E\u0338": "nbump", "\u224F": "bumpe", "\u224F\u0338": "nbumpe", "\u2250": "doteq", "\u2250\u0338": "nedot", "\u2251": "eDot", "\u2252": "efDot", "\u2253": "erDot", "\u2254": "colone", "\u2255": "ecolon", "\u2256": "ecir", "\u2257": "cire", "\u2259": "wedgeq", "\u225A": "veeeq", "\u225C": "trie", "\u225F": "equest", "\u2261": "equiv", "\u2262": "nequiv", "\u2261\u20E5": "bnequiv", "\u2264": "le", "\u2270": "nle", "\u2264\u20D2": "nvle", "\u2265": "ge", "\u2271": "nge", "\u2265\u20D2": "nvge", "\u2266": "lE", "\u2266\u0338": "nlE", "\u2267": "gE", "\u2267\u0338": "ngE", "\u2268\uFE00": "lvnE", "\u2268": "lnE", "\u2269": "gnE", "\u2269\uFE00": "gvnE", "\u226A": "ll", "\u226A\u0338": "nLtv", "\u226A\u20D2": "nLt", "\u226B": "gg", "\u226B\u0338": "nGtv", "\u226B\u20D2": "nGt", "\u226C": "twixt", "\u2272": "lsim", "\u2274": "nlsim", "\u2273": "gsim", "\u2275": "ngsim", "\u2276": "lg", "\u2278": "ntlg", "\u2277": "gl", "\u2279": "ntgl", "\u227A": "pr", "\u2280": "npr", "\u227B": "sc", "\u2281": "nsc", "\u227C": "prcue", "\u22E0": "nprcue", "\u227D": "sccue", "\u22E1": "nsccue", "\u227E": "prsim", "\u227F": "scsim", "\u227F\u0338": "NotSucceedsTilde", "\u2282": "sub", "\u2284": "nsub", "\u2282\u20D2": "vnsub", "\u2283": "sup", "\u2285": "nsup", "\u2283\u20D2": "vnsup", "\u2286": "sube", "\u2288": "nsube", "\u2287": "supe", "\u2289": "nsupe", "\u228A\uFE00": "vsubne", "\u228A": "subne", "\u228B\uFE00": "vsupne", "\u228B": "supne", "\u228D": "cupdot", "\u228E": "uplus", "\u228F": "sqsub", "\u228F\u0338": "NotSquareSubset", "\u2290": "sqsup", "\u2290\u0338": "NotSquareSuperset", "\u2291": "sqsube", "\u22E2": "nsqsube", "\u2292": "sqsupe", "\u22E3": "nsqsupe", "\u2293": "sqcap", "\u2293\uFE00": "sqcaps", "\u2294": "sqcup", "\u2294\uFE00": "sqcups", "\u2295": "oplus", "\u2296": "ominus", "\u2297": "otimes", "\u2298": "osol", "\u2299": "odot", "\u229A": "ocir", "\u229B": "oast", "\u229D": "odash", "\u229E": "plusb", "\u229F": "minusb", "\u22A0": "timesb", "\u22A1": "sdotb", "\u22A2": "vdash", "\u22AC": "nvdash", "\u22A3": "dashv", "\u22A4": "top", "\u22A5": "bot", "\u22A7": "models", "\u22A8": "vDash", "\u22AD": "nvDash", "\u22A9": "Vdash", "\u22AE": "nVdash", "\u22AA": "Vvdash", "\u22AB": "VDash", "\u22AF": "nVDash", "\u22B0": "prurel", "\u22B2": "vltri", "\u22EA": "nltri", "\u22B3": "vrtri", "\u22EB": "nrtri", "\u22B4": "ltrie", "\u22EC": "nltrie", "\u22B4\u20D2": "nvltrie", "\u22B5": "rtrie", "\u22ED": "nrtrie", "\u22B5\u20D2": "nvrtrie", "\u22B6": "origof", "\u22B7": "imof", "\u22B8": "mumap", "\u22B9": "hercon", "\u22BA": "intcal", "\u22BB": "veebar", "\u22BD": "barvee", "\u22BE": "angrtvb", "\u22BF": "lrtri", "\u22C0": "Wedge", "\u22C1": "Vee", "\u22C2": "xcap", "\u22C3": "xcup", "\u22C4": "diam", "\u22C5": "sdot", "\u22C6": "Star", "\u22C7": "divonx", "\u22C8": "bowtie", "\u22C9": "ltimes", "\u22CA": "rtimes", "\u22CB": "lthree", "\u22CC": "rthree", "\u22CD": "bsime", "\u22CE": "cuvee", "\u22CF": "cuwed", "\u22D0": "Sub", "\u22D1": "Sup", "\u22D2": "Cap", "\u22D3": "Cup", "\u22D4": "fork", "\u22D5": "epar", "\u22D6": "ltdot", "\u22D7": "gtdot", "\u22D8": "Ll", "\u22D8\u0338": "nLl", "\u22D9": "Gg", "\u22D9\u0338": "nGg", "\u22DA\uFE00": "lesg", "\u22DA": "leg", "\u22DB": "gel", "\u22DB\uFE00": "gesl", "\u22DE": "cuepr", "\u22DF": "cuesc", "\u22E6": "lnsim", "\u22E7": "gnsim", "\u22E8": "prnsim", "\u22E9": "scnsim", "\u22EE": "vellip", "\u22EF": "ctdot", "\u22F0": "utdot", "\u22F1": "dtdot", "\u22F2": "disin", "\u22F3": "isinsv", "\u22F4": "isins", "\u22F5": "isindot", "\u22F5\u0338": "notindot", "\u22F6": "notinvc", "\u22F7": "notinvb", "\u22F9": "isinE", "\u22F9\u0338": "notinE", "\u22FA": "nisd", "\u22FB": "xnis", "\u22FC": "nis", "\u22FD": "notnivc", "\u22FE": "notnivb", "\u2305": "barwed", "\u2306": "Barwed", "\u230C": "drcrop", "\u230D": "dlcrop", "\u230E": "urcrop", "\u230F": "ulcrop", "\u2310": "bnot", "\u2312": "profline", "\u2313": "profsurf", "\u2315": "telrec", "\u2316": "target", "\u231C": "ulcorn", "\u231D": "urcorn", "\u231E": "dlcorn", "\u231F": "drcorn", "\u2322": "frown", "\u2323": "smile", "\u232D": "cylcty", "\u232E": "profalar", "\u2336": "topbot", "\u233D": "ovbar", "\u233F": "solbar", "\u237C": "angzarr", "\u23B0": "lmoust", "\u23B1": "rmoust", "\u23B4": "tbrk", "\u23B5": "bbrk", "\u23B6": "bbrktbrk", "\u23DC": "OverParenthesis", "\u23DD": "UnderParenthesis", "\u23DE": "OverBrace", "\u23DF": "UnderBrace", "\u23E2": "trpezium", "\u23E7": "elinters", "\u2423": "blank", "\u2500": "boxh", "\u2502": "boxv", "\u250C": "boxdr", "\u2510": "boxdl", "\u2514": "boxur", "\u2518": "boxul", "\u251C": "boxvr", "\u2524": "boxvl", "\u252C": "boxhd", "\u2534": "boxhu", "\u253C": "boxvh", "\u2550": "boxH", "\u2551": "boxV", "\u2552": "boxdR", "\u2553": "boxDr", "\u2554": "boxDR", "\u2555": "boxdL", "\u2556": "boxDl", "\u2557": "boxDL", "\u2558": "boxuR", "\u2559": "boxUr", "\u255A": "boxUR", "\u255B": "boxuL", "\u255C": "boxUl", "\u255D": "boxUL", "\u255E": "boxvR", "\u255F": "boxVr", "\u2560": "boxVR", "\u2561": "boxvL", "\u2562": "boxVl", "\u2563": "boxVL", "\u2564": "boxHd", "\u2565": "boxhD", "\u2566": "boxHD", "\u2567": "boxHu", "\u2568": "boxhU", "\u2569": "boxHU", "\u256A": "boxvH", "\u256B": "boxVh", "\u256C": "boxVH", "\u2580": "uhblk", "\u2584": "lhblk", "\u2588": "block", "\u2591": "blk14", "\u2592": "blk12", "\u2593": "blk34", "\u25A1": "squ", "\u25AA": "squf", "\u25AB": "EmptyVerySmallSquare", "\u25AD": "rect", "\u25AE": "marker", "\u25B1": "fltns", "\u25B3": "xutri", "\u25B4": "utrif", "\u25B5": "utri", "\u25B8": "rtrif", "\u25B9": "rtri", "\u25BD": "xdtri", "\u25BE": "dtrif", "\u25BF": "dtri", "\u25C2": "ltrif", "\u25C3": "ltri", "\u25CA": "loz", "\u25CB": "cir", "\u25EC": "tridot", "\u25EF": "xcirc", "\u25F8": "ultri", "\u25F9": "urtri", "\u25FA": "lltri", "\u25FB": "EmptySmallSquare", "\u25FC": "FilledSmallSquare", "\u2605": "starf", "\u2606": "star", "\u260E": "phone", "\u2640": "female", "\u2642": "male", "\u2660": "spades", "\u2663": "clubs", "\u2665": "hearts", "\u2666": "diams", "\u266A": "sung", "\u2713": "check", "\u2717": "cross", "\u2720": "malt", "\u2736": "sext", "\u2758": "VerticalSeparator", "\u27C8": "bsolhsub", "\u27C9": "suphsol", "\u27F5": "xlarr", "\u27F6": "xrarr", "\u27F7": "xharr", "\u27F8": "xlArr", "\u27F9": "xrArr", "\u27FA": "xhArr", "\u27FC": "xmap", "\u27FF": "dzigrarr", "\u2902": "nvlArr", "\u2903": "nvrArr", "\u2904": "nvHarr", "\u2905": "Map", "\u290C": "lbarr", "\u290D": "rbarr", "\u290E": "lBarr", "\u290F": "rBarr", "\u2910": "RBarr", "\u2911": "DDotrahd", "\u2912": "UpArrowBar", "\u2913": "DownArrowBar", "\u2916": "Rarrtl", "\u2919": "latail", "\u291A": "ratail", "\u291B": "lAtail", "\u291C": "rAtail", "\u291D": "larrfs", "\u291E": "rarrfs", "\u291F": "larrbfs", "\u2920": "rarrbfs", "\u2923": "nwarhk", "\u2924": "nearhk", "\u2925": "searhk", "\u2926": "swarhk", "\u2927": "nwnear", "\u2928": "toea", "\u2929": "tosa", "\u292A": "swnwar", "\u2933": "rarrc", "\u2933\u0338": "nrarrc", "\u2935": "cudarrr", "\u2936": "ldca", "\u2937": "rdca", "\u2938": "cudarrl", "\u2939": "larrpl", "\u293C": "curarrm", "\u293D": "cularrp", "\u2945": "rarrpl", "\u2948": "harrcir", "\u2949": "Uarrocir", "\u294A": "lurdshar", "\u294B": "ldrushar", "\u294E": "LeftRightVector", "\u294F": "RightUpDownVector", "\u2950": "DownLeftRightVector", "\u2951": "LeftUpDownVector", "\u2952": "LeftVectorBar", "\u2953": "RightVectorBar", "\u2954": "RightUpVectorBar", "\u2955": "RightDownVectorBar", "\u2956": "DownLeftVectorBar", "\u2957": "DownRightVectorBar", "\u2958": "LeftUpVectorBar", "\u2959": "LeftDownVectorBar", "\u295A": "LeftTeeVector", "\u295B": "RightTeeVector", "\u295C": "RightUpTeeVector", "\u295D": "RightDownTeeVector", "\u295E": "DownLeftTeeVector", "\u295F": "DownRightTeeVector", "\u2960": "LeftUpTeeVector", "\u2961": "LeftDownTeeVector", "\u2962": "lHar", "\u2963": "uHar", "\u2964": "rHar", "\u2965": "dHar", "\u2966": "luruhar", "\u2967": "ldrdhar", "\u2968": "ruluhar", "\u2969": "rdldhar", "\u296A": "lharul", "\u296B": "llhard", "\u296C": "rharul", "\u296D": "lrhard", "\u296E": "udhar", "\u296F": "duhar", "\u2970": "RoundImplies", "\u2971": "erarr", "\u2972": "simrarr", "\u2973": "larrsim", "\u2974": "rarrsim", "\u2975": "rarrap", "\u2976": "ltlarr", "\u2978": "gtrarr", "\u2979": "subrarr", "\u297B": "suplarr", "\u297C": "lfisht", "\u297D": "rfisht", "\u297E": "ufisht", "\u297F": "dfisht", "\u299A": "vzigzag", "\u299C": "vangrt", "\u299D": "angrtvbd", "\u29A4": "ange", "\u29A5": "range", "\u29A6": "dwangle", "\u29A7": "uwangle", "\u29A8": "angmsdaa", "\u29A9": "angmsdab", "\u29AA": "angmsdac", "\u29AB": "angmsdad", "\u29AC": "angmsdae", "\u29AD": "angmsdaf", "\u29AE": "angmsdag", "\u29AF": "angmsdah", "\u29B0": "bemptyv", "\u29B1": "demptyv", "\u29B2": "cemptyv", "\u29B3": "raemptyv", "\u29B4": "laemptyv", "\u29B5": "ohbar", "\u29B6": "omid", "\u29B7": "opar", "\u29B9": "operp", "\u29BB": "olcross", "\u29BC": "odsold", "\u29BE": "olcir", "\u29BF": "ofcir", "\u29C0": "olt", "\u29C1": "ogt", "\u29C2": "cirscir", "\u29C3": "cirE", "\u29C4": "solb", "\u29C5": "bsolb", "\u29C9": "boxbox", "\u29CD": "trisb", "\u29CE": "rtriltri", "\u29CF": "LeftTriangleBar", "\u29CF\u0338": "NotLeftTriangleBar", "\u29D0": "RightTriangleBar", "\u29D0\u0338": "NotRightTriangleBar", "\u29DC": "iinfin", "\u29DD": "infintie", "\u29DE": "nvinfin", "\u29E3": "eparsl", "\u29E4": "smeparsl", "\u29E5": "eqvparsl", "\u29EB": "lozf", "\u29F4": "RuleDelayed", "\u29F6": "dsol", "\u2A00": "xodot", "\u2A01": "xoplus", "\u2A02": "xotime", "\u2A04": "xuplus", "\u2A06": "xsqcup", "\u2A0D": "fpartint", "\u2A10": "cirfnint", "\u2A11": "awint", "\u2A12": "rppolint", "\u2A13": "scpolint", "\u2A14": "npolint", "\u2A15": "pointint", "\u2A16": "quatint", "\u2A17": "intlarhk", "\u2A22": "pluscir", "\u2A23": "plusacir", "\u2A24": "simplus", "\u2A25": "plusdu", "\u2A26": "plussim", "\u2A27": "plustwo", "\u2A29": "mcomma", "\u2A2A": "minusdu", "\u2A2D": "loplus", "\u2A2E": "roplus", "\u2A2F": "Cross", "\u2A30": "timesd", "\u2A31": "timesbar", "\u2A33": "smashp", "\u2A34": "lotimes", "\u2A35": "rotimes", "\u2A36": "otimesas", "\u2A37": "Otimes", "\u2A38": "odiv", "\u2A39": "triplus", "\u2A3A": "triminus", "\u2A3B": "tritime", "\u2A3C": "iprod", "\u2A3F": "amalg", "\u2A40": "capdot", "\u2A42": "ncup", "\u2A43": "ncap", "\u2A44": "capand", "\u2A45": "cupor", "\u2A46": "cupcap", "\u2A47": "capcup", "\u2A48": "cupbrcap", "\u2A49": "capbrcup", "\u2A4A": "cupcup", "\u2A4B": "capcap", "\u2A4C": "ccups", "\u2A4D": "ccaps", "\u2A50": "ccupssm", "\u2A53": "And", "\u2A54": "Or", "\u2A55": "andand", "\u2A56": "oror", "\u2A57": "orslope", "\u2A58": "andslope", "\u2A5A": "andv", "\u2A5B": "orv", "\u2A5C": "andd", "\u2A5D": "ord", "\u2A5F": "wedbar", "\u2A66": "sdote", "\u2A6A": "simdot", "\u2A6D": "congdot", "\u2A6D\u0338": "ncongdot", "\u2A6E": "easter", "\u2A6F": "apacir", "\u2A70": "apE", "\u2A70\u0338": "napE", "\u2A71": "eplus", "\u2A72": "pluse", "\u2A73": "Esim", "\u2A77": "eDDot", "\u2A78": "equivDD", "\u2A79": "ltcir", "\u2A7A": "gtcir", "\u2A7B": "ltquest", "\u2A7C": "gtquest", "\u2A7D": "les", "\u2A7D\u0338": "nles", "\u2A7E": "ges", "\u2A7E\u0338": "nges", "\u2A7F": "lesdot", "\u2A80": "gesdot", "\u2A81": "lesdoto", "\u2A82": "gesdoto", "\u2A83": "lesdotor", "\u2A84": "gesdotol", "\u2A85": "lap", "\u2A86": "gap", "\u2A87": "lne", "\u2A88": "gne", "\u2A89": "lnap", "\u2A8A": "gnap", "\u2A8B": "lEg", "\u2A8C": "gEl", "\u2A8D": "lsime", "\u2A8E": "gsime", "\u2A8F": "lsimg", "\u2A90": "gsiml", "\u2A91": "lgE", "\u2A92": "glE", "\u2A93": "lesges", "\u2A94": "gesles", "\u2A95": "els", "\u2A96": "egs", "\u2A97": "elsdot", "\u2A98": "egsdot", "\u2A99": "el", "\u2A9A": "eg", "\u2A9D": "siml", "\u2A9E": "simg", "\u2A9F": "simlE", "\u2AA0": "simgE", "\u2AA1": "LessLess", "\u2AA1\u0338": "NotNestedLessLess", "\u2AA2": "GreaterGreater", "\u2AA2\u0338": "NotNestedGreaterGreater", "\u2AA4": "glj", "\u2AA5": "gla", "\u2AA6": "ltcc", "\u2AA7": "gtcc", "\u2AA8": "lescc", "\u2AA9": "gescc", "\u2AAA": "smt", "\u2AAB": "lat", "\u2AAC": "smte", "\u2AAC\uFE00": "smtes", "\u2AAD": "late", "\u2AAD\uFE00": "lates", "\u2AAE": "bumpE", "\u2AAF": "pre", "\u2AAF\u0338": "npre", "\u2AB0": "sce", "\u2AB0\u0338": "nsce", "\u2AB3": "prE", "\u2AB4": "scE", "\u2AB5": "prnE", "\u2AB6": "scnE", "\u2AB7": "prap", "\u2AB8": "scap", "\u2AB9": "prnap", "\u2ABA": "scnap", "\u2ABB": "Pr", "\u2ABC": "Sc", "\u2ABD": "subdot", "\u2ABE": "supdot", "\u2ABF": "subplus", "\u2AC0": "supplus", "\u2AC1": "submult", "\u2AC2": "supmult", "\u2AC3": "subedot", "\u2AC4": "supedot", "\u2AC5": "subE", "\u2AC5\u0338": "nsubE", "\u2AC6": "supE", "\u2AC6\u0338": "nsupE", "\u2AC7": "subsim", "\u2AC8": "supsim", "\u2ACB\uFE00": "vsubnE", "\u2ACB": "subnE", "\u2ACC\uFE00": "vsupnE", "\u2ACC": "supnE", "\u2ACF": "csub", "\u2AD0": "csup", "\u2AD1": "csube", "\u2AD2": "csupe", "\u2AD3": "subsup", "\u2AD4": "supsub", "\u2AD5": "subsub", "\u2AD6": "supsup", "\u2AD7": "suphsub", "\u2AD8": "supdsub", "\u2AD9": "forkv", "\u2ADA": "topfork", "\u2ADB": "mlcp", "\u2AE4": "Dashv", "\u2AE6": "Vdashl", "\u2AE7": "Barv", "\u2AE8": "vBar", "\u2AE9": "vBarv", "\u2AEB": "Vbar", "\u2AEC": "Not", "\u2AED": "bNot", "\u2AEE": "rnmid", "\u2AEF": "cirmid", "\u2AF0": "midcir", "\u2AF1": "topcir", "\u2AF2": "nhpar", "\u2AF3": "parsim", "\u2AFD": "parsl", "\u2AFD\u20E5": "nparsl", "\u266D": "flat", "\u266E": "natur", "\u266F": "sharp", "\xA4": "curren", "\xA2": "cent", "$": "dollar", "\xA3": "pound", "\xA5": "yen", "\u20AC": "euro", "\xB9": "sup1", "\xBD": "half", "\u2153": "frac13", "\xBC": "frac14", "\u2155": "frac15", "\u2159": "frac16", "\u215B": "frac18", "\xB2": "sup2", "\u2154": "frac23", "\u2156": "frac25", "\xB3": "sup3", "\xBE": "frac34", "\u2157": "frac35", "\u215C": "frac38", "\u2158": "frac45", "\u215A": "frac56", "\u215D": "frac58", "\u215E": "frac78", "\u{1D4B6}": "ascr", "\u{1D552}": "aopf", "\u{1D51E}": "afr", "\u{1D538}": "Aopf", "\u{1D504}": "Afr", "\u{1D49C}": "Ascr", "\xAA": "ordf", "\xE1": "aacute", "\xC1": "Aacute", "\xE0": "agrave", "\xC0": "Agrave", "\u0103": "abreve", "\u0102": "Abreve", "\xE2": "acirc", "\xC2": "Acirc", "\xE5": "aring", "\xC5": "angst", "\xE4": "auml", "\xC4": "Auml", "\xE3": "atilde", "\xC3": "Atilde", "\u0105": "aogon", "\u0104": "Aogon", "\u0101": "amacr", "\u0100": "Amacr", "\xE6": "aelig", "\xC6": "AElig", "\u{1D4B7}": "bscr", "\u{1D553}": "bopf", "\u{1D51F}": "bfr", "\u{1D539}": "Bopf", "\u212C": "Bscr", "\u{1D505}": "Bfr", "\u{1D520}": "cfr", "\u{1D4B8}": "cscr", "\u{1D554}": "copf", "\u212D": "Cfr", "\u{1D49E}": "Cscr", "\u2102": "Copf", "\u0107": "cacute", "\u0106": "Cacute", "\u0109": "ccirc", "\u0108": "Ccirc", "\u010D": "ccaron", "\u010C": "Ccaron", "\u010B": "cdot", "\u010A": "Cdot", "\xE7": "ccedil", "\xC7": "Ccedil", "\u2105": "incare", "\u{1D521}": "dfr", "\u2146": "dd", "\u{1D555}": "dopf", "\u{1D4B9}": "dscr", "\u{1D49F}": "Dscr", "\u{1D507}": "Dfr", "\u2145": "DD", "\u{1D53B}": "Dopf", "\u010F": "dcaron", "\u010E": "Dcaron", "\u0111": "dstrok", "\u0110": "Dstrok", "\xF0": "eth", "\xD0": "ETH", "\u2147": "ee", "\u212F": "escr", "\u{1D522}": "efr", "\u{1D556}": "eopf", "\u2130": "Escr", "\u{1D508}": "Efr", "\u{1D53C}": "Eopf", "\xE9": "eacute", "\xC9": "Eacute", "\xE8": "egrave", "\xC8": "Egrave", "\xEA": "ecirc", "\xCA": "Ecirc", "\u011B": "ecaron", "\u011A": "Ecaron", "\xEB": "euml", "\xCB": "Euml", "\u0117": "edot", "\u0116": "Edot", "\u0119": "eogon", "\u0118": "Eogon", "\u0113": "emacr", "\u0112": "Emacr", "\u{1D523}": "ffr", "\u{1D557}": "fopf", "\u{1D4BB}": "fscr", "\u{1D509}": "Ffr", "\u{1D53D}": "Fopf", "\u2131": "Fscr", "\uFB00": "fflig", "\uFB03": "ffilig", "\uFB04": "ffllig", "\uFB01": "filig", "fj": "fjlig", "\uFB02": "fllig", "\u0192": "fnof", "\u210A": "gscr", "\u{1D558}": "gopf", "\u{1D524}": "gfr", "\u{1D4A2}": "Gscr", "\u{1D53E}": "Gopf", "\u{1D50A}": "Gfr", "\u01F5": "gacute", "\u011F": "gbreve", "\u011E": "Gbreve", "\u011D": "gcirc", "\u011C": "Gcirc", "\u0121": "gdot", "\u0120": "Gdot", "\u0122": "Gcedil", "\u{1D525}": "hfr", "\u210E": "planckh", "\u{1D4BD}": "hscr", "\u{1D559}": "hopf", "\u210B": "Hscr", "\u210C": "Hfr", "\u210D": "Hopf", "\u0125": "hcirc", "\u0124": "Hcirc", "\u210F": "hbar", "\u0127": "hstrok", "\u0126": "Hstrok", "\u{1D55A}": "iopf", "\u{1D526}": "ifr", "\u{1D4BE}": "iscr", "\u2148": "ii", "\u{1D540}": "Iopf", "\u2110": "Iscr", "\u2111": "Im", "\xED": "iacute", "\xCD": "Iacute", "\xEC": "igrave", "\xCC": "Igrave", "\xEE": "icirc", "\xCE": "Icirc", "\xEF": "iuml", "\xCF": "Iuml", "\u0129": "itilde", "\u0128": "Itilde", "\u0130": "Idot", "\u012F": "iogon", "\u012E": "Iogon", "\u012B": "imacr", "\u012A": "Imacr", "\u0133": "ijlig", "\u0132": "IJlig", "\u0131": "imath", "\u{1D4BF}": "jscr", "\u{1D55B}": "jopf", "\u{1D527}": "jfr", "\u{1D4A5}": "Jscr", "\u{1D50D}": "Jfr", "\u{1D541}": "Jopf", "\u0135": "jcirc", "\u0134": "Jcirc", "\u0237": "jmath", "\u{1D55C}": "kopf", "\u{1D4C0}": "kscr", "\u{1D528}": "kfr", "\u{1D4A6}": "Kscr", "\u{1D542}": "Kopf", "\u{1D50E}": "Kfr", "\u0137": "kcedil", "\u0136": "Kcedil", "\u{1D529}": "lfr", "\u{1D4C1}": "lscr", "\u2113": "ell", "\u{1D55D}": "lopf", "\u2112": "Lscr", "\u{1D50F}": "Lfr", "\u{1D543}": "Lopf", "\u013A": "lacute", "\u0139": "Lacute", "\u013E": "lcaron", "\u013D": "Lcaron", "\u013C": "lcedil", "\u013B": "Lcedil", "\u0142": "lstrok", "\u0141": "Lstrok", "\u0140": "lmidot", "\u013F": "Lmidot", "\u{1D52A}": "mfr", "\u{1D55E}": "mopf", "\u{1D4C2}": "mscr", "\u{1D510}": "Mfr", "\u{1D544}": "Mopf", "\u2133": "Mscr", "\u{1D52B}": "nfr", "\u{1D55F}": "nopf", "\u{1D4C3}": "nscr", "\u2115": "Nopf", "\u{1D4A9}": "Nscr", "\u{1D511}": "Nfr", "\u0144": "nacute", "\u0143": "Nacute", "\u0148": "ncaron", "\u0147": "Ncaron", "\xF1": "ntilde", "\xD1": "Ntilde", "\u0146": "ncedil", "\u0145": "Ncedil", "\u2116": "numero", "\u014B": "eng", "\u014A": "ENG", "\u{1D560}": "oopf", "\u{1D52C}": "ofr", "\u2134": "oscr", "\u{1D4AA}": "Oscr", "\u{1D512}": "Ofr", "\u{1D546}": "Oopf", "\xBA": "ordm", "\xF3": "oacute", "\xD3": "Oacute", "\xF2": "ograve", "\xD2": "Ograve", "\xF4": "ocirc", "\xD4": "Ocirc", "\xF6": "ouml", "\xD6": "Ouml", "\u0151": "odblac", "\u0150": "Odblac", "\xF5": "otilde", "\xD5": "Otilde", "\xF8": "oslash", "\xD8": "Oslash", "\u014D": "omacr", "\u014C": "Omacr", "\u0153": "oelig", "\u0152": "OElig", "\u{1D52D}": "pfr", "\u{1D4C5}": "pscr", "\u{1D561}": "popf", "\u2119": "Popf", "\u{1D513}": "Pfr", "\u{1D4AB}": "Pscr", "\u{1D562}": "qopf", "\u{1D52E}": "qfr", "\u{1D4C6}": "qscr", "\u{1D4AC}": "Qscr", "\u{1D514}": "Qfr", "\u211A": "Qopf", "\u0138": "kgreen", "\u{1D52F}": "rfr", "\u{1D563}": "ropf", "\u{1D4C7}": "rscr", "\u211B": "Rscr", "\u211C": "Re", "\u211D": "Ropf", "\u0155": "racute", "\u0154": "Racute", "\u0159": "rcaron", "\u0158": "Rcaron", "\u0157": "rcedil", "\u0156": "Rcedil", "\u{1D564}": "sopf", "\u{1D4C8}": "sscr", "\u{1D530}": "sfr", "\u{1D54A}": "Sopf", "\u{1D516}": "Sfr", "\u{1D4AE}": "Sscr", "\u24C8": "oS", "\u015B": "sacute", "\u015A": "Sacute", "\u015D": "scirc", "\u015C": "Scirc", "\u0161": "scaron", "\u0160": "Scaron", "\u015F": "scedil", "\u015E": "Scedil", "\xDF": "szlig", "\u{1D531}": "tfr", "\u{1D4C9}": "tscr", "\u{1D565}": "topf", "\u{1D4AF}": "Tscr", "\u{1D517}": "Tfr", "\u{1D54B}": "Topf", "\u0165": "tcaron", "\u0164": "Tcaron", "\u0163": "tcedil", "\u0162": "Tcedil", "\u2122": "trade", "\u0167": "tstrok", "\u0166": "Tstrok", "\u{1D4CA}": "uscr", "\u{1D566}": "uopf", "\u{1D532}": "ufr", "\u{1D54C}": "Uopf", "\u{1D518}": "Ufr", "\u{1D4B0}": "Uscr", "\xFA": "uacute", "\xDA": "Uacute", "\xF9": "ugrave", "\xD9": "Ugrave", "\u016D": "ubreve", "\u016C": "Ubreve", "\xFB": "ucirc", "\xDB": "Ucirc", "\u016F": "uring", "\u016E": "Uring", "\xFC": "uuml", "\xDC": "Uuml", "\u0171": "udblac", "\u0170": "Udblac", "\u0169": "utilde", "\u0168": "Utilde", "\u0173": "uogon", "\u0172": "Uogon", "\u016B": "umacr", "\u016A": "Umacr", "\u{1D533}": "vfr", "\u{1D567}": "vopf", "\u{1D4CB}": "vscr", "\u{1D519}": "Vfr", "\u{1D54D}": "Vopf", "\u{1D4B1}": "Vscr", "\u{1D568}": "wopf", "\u{1D4CC}": "wscr", "\u{1D534}": "wfr", "\u{1D4B2}": "Wscr", "\u{1D54E}": "Wopf", "\u{1D51A}": "Wfr", "\u0175": "wcirc", "\u0174": "Wcirc", "\u{1D535}": "xfr", "\u{1D4CD}": "xscr", "\u{1D569}": "xopf", "\u{1D54F}": "Xopf", "\u{1D51B}": "Xfr", "\u{1D4B3}": "Xscr", "\u{1D536}": "yfr", "\u{1D4CE}": "yscr", "\u{1D56A}": "yopf", "\u{1D4B4}": "Yscr", "\u{1D51C}": "Yfr", "\u{1D550}": "Yopf", "\xFD": "yacute", "\xDD": "Yacute", "\u0177": "ycirc", "\u0176": "Ycirc", "\xFF": "yuml", "\u0178": "Yuml", "\u{1D4CF}": "zscr", "\u{1D537}": "zfr", "\u{1D56B}": "zopf", "\u2128": "Zfr", "\u2124": "Zopf", "\u{1D4B5}": "Zscr", "\u017A": "zacute", "\u0179": "Zacute", "\u017E": "zcaron", "\u017D": "Zcaron", "\u017C": "zdot", "\u017B": "Zdot", "\u01B5": "imped", "\xFE": "thorn", "\xDE": "THORN", "\u0149": "napos", "\u03B1": "alpha", "\u0391": "Alpha", "\u03B2": "beta", "\u0392": "Beta", "\u03B3": "gamma", "\u0393": "Gamma", "\u03B4": "delta", "\u0394": "Delta", "\u03B5": "epsi", "\u03F5": "epsiv", "\u0395": "Epsilon", "\u03DD": "gammad", "\u03DC": "Gammad", "\u03B6": "zeta", "\u0396": "Zeta", "\u03B7": "eta", "\u0397": "Eta", "\u03B8": "theta", "\u03D1": "thetav", "\u0398": "Theta", "\u03B9": "iota", "\u0399": "Iota", "\u03BA": "kappa", "\u03F0": "kappav", "\u039A": "Kappa", "\u03BB": "lambda", "\u039B": "Lambda", "\u03BC": "mu", "\xB5": "micro", "\u039C": "Mu", "\u03BD": "nu", "\u039D": "Nu", "\u03BE": "xi", "\u039E": "Xi", "\u03BF": "omicron", "\u039F": "Omicron", "\u03C0": "pi", "\u03D6": "piv", "\u03A0": "Pi", "\u03C1": "rho", "\u03F1": "rhov", "\u03A1": "Rho", "\u03C3": "sigma", "\u03A3": "Sigma", "\u03C2": "sigmaf", "\u03C4": "tau", "\u03A4": "Tau", "\u03C5": "upsi", "\u03A5": "Upsilon", "\u03D2": "Upsi", "\u03C6": "phi", "\u03D5": "phiv", "\u03A6": "Phi", "\u03C7": "chi", "\u03A7": "Chi", "\u03C8": "psi", "\u03A8": "Psi", "\u03C9": "omega", "\u03A9": "ohm", "\u0430": "acy", "\u0410": "Acy", "\u0431": "bcy", "\u0411": "Bcy", "\u0432": "vcy", "\u0412": "Vcy", "\u0433": "gcy", "\u0413": "Gcy", "\u0453": "gjcy", "\u0403": "GJcy", "\u0434": "dcy", "\u0414": "Dcy", "\u0452": "djcy", "\u0402": "DJcy", "\u0435": "iecy", "\u0415": "IEcy", "\u0451": "iocy", "\u0401": "IOcy", "\u0454": "jukcy", "\u0404": "Jukcy", "\u0436": "zhcy", "\u0416": "ZHcy", "\u0437": "zcy", "\u0417": "Zcy", "\u0455": "dscy", "\u0405": "DScy", "\u0438": "icy", "\u0418": "Icy", "\u0456": "iukcy", "\u0406": "Iukcy", "\u0457": "yicy", "\u0407": "YIcy", "\u0439": "jcy", "\u0419": "Jcy", "\u0458": "jsercy", "\u0408": "Jsercy", "\u043A": "kcy", "\u041A": "Kcy", "\u045C": "kjcy", "\u040C": "KJcy", "\u043B": "lcy", "\u041B": "Lcy", "\u0459": "ljcy", "\u0409": "LJcy", "\u043C": "mcy", "\u041C": "Mcy", "\u043D": "ncy", "\u041D": "Ncy", "\u045A": "njcy", "\u040A": "NJcy", "\u043E": "ocy", "\u041E": "Ocy", "\u043F": "pcy", "\u041F": "Pcy", "\u0440": "rcy", "\u0420": "Rcy", "\u0441": "scy", "\u0421": "Scy", "\u0442": "tcy", "\u0422": "Tcy", "\u045B": "tshcy", "\u040B": "TSHcy", "\u0443": "ucy", "\u0423": "Ucy", "\u045E": "ubrcy", "\u040E": "Ubrcy", "\u0444": "fcy", "\u0424": "Fcy", "\u0445": "khcy", "\u0425": "KHcy", "\u0446": "tscy", "\u0426": "TScy", "\u0447": "chcy", "\u0427": "CHcy", "\u045F": "dzcy", "\u040F": "DZcy", "\u0448": "shcy", "\u0428": "SHcy", "\u0449": "shchcy", "\u0429": "SHCHcy", "\u044A": "hardcy", "\u042A": "HARDcy", "\u044B": "ycy", "\u042B": "Ycy", "\u044C": "softcy", "\u042C": "SOFTcy", "\u044D": "ecy", "\u042D": "Ecy", "\u044E": "yucy", "\u042E": "YUcy", "\u044F": "yacy", "\u042F": "YAcy", "\u2135": "aleph", "\u2136": "beth", "\u2137": "gimel", "\u2138": "daleth" };
      var regexEscape = /["&'<>`]/g;
      var escapeMap = {
        '"': "&quot;",
        "&": "&amp;",
        "'": "&#x27;",
        "<": "&lt;",
        ">": "&gt;",
        "`": "&#x60;"
      };
      var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
      var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
      var decodeMap = { "aacute": "\xE1", "Aacute": "\xC1", "abreve": "\u0103", "Abreve": "\u0102", "ac": "\u223E", "acd": "\u223F", "acE": "\u223E\u0333", "acirc": "\xE2", "Acirc": "\xC2", "acute": "\xB4", "acy": "\u0430", "Acy": "\u0410", "aelig": "\xE6", "AElig": "\xC6", "af": "\u2061", "afr": "\u{1D51E}", "Afr": "\u{1D504}", "agrave": "\xE0", "Agrave": "\xC0", "alefsym": "\u2135", "aleph": "\u2135", "alpha": "\u03B1", "Alpha": "\u0391", "amacr": "\u0101", "Amacr": "\u0100", "amalg": "\u2A3F", "amp": "&", "AMP": "&", "and": "\u2227", "And": "\u2A53", "andand": "\u2A55", "andd": "\u2A5C", "andslope": "\u2A58", "andv": "\u2A5A", "ang": "\u2220", "ange": "\u29A4", "angle": "\u2220", "angmsd": "\u2221", "angmsdaa": "\u29A8", "angmsdab": "\u29A9", "angmsdac": "\u29AA", "angmsdad": "\u29AB", "angmsdae": "\u29AC", "angmsdaf": "\u29AD", "angmsdag": "\u29AE", "angmsdah": "\u29AF", "angrt": "\u221F", "angrtvb": "\u22BE", "angrtvbd": "\u299D", "angsph": "\u2222", "angst": "\xC5", "angzarr": "\u237C", "aogon": "\u0105", "Aogon": "\u0104", "aopf": "\u{1D552}", "Aopf": "\u{1D538}", "ap": "\u2248", "apacir": "\u2A6F", "ape": "\u224A", "apE": "\u2A70", "apid": "\u224B", "apos": "'", "ApplyFunction": "\u2061", "approx": "\u2248", "approxeq": "\u224A", "aring": "\xE5", "Aring": "\xC5", "ascr": "\u{1D4B6}", "Ascr": "\u{1D49C}", "Assign": "\u2254", "ast": "*", "asymp": "\u2248", "asympeq": "\u224D", "atilde": "\xE3", "Atilde": "\xC3", "auml": "\xE4", "Auml": "\xC4", "awconint": "\u2233", "awint": "\u2A11", "backcong": "\u224C", "backepsilon": "\u03F6", "backprime": "\u2035", "backsim": "\u223D", "backsimeq": "\u22CD", "Backslash": "\u2216", "Barv": "\u2AE7", "barvee": "\u22BD", "barwed": "\u2305", "Barwed": "\u2306", "barwedge": "\u2305", "bbrk": "\u23B5", "bbrktbrk": "\u23B6", "bcong": "\u224C", "bcy": "\u0431", "Bcy": "\u0411", "bdquo": "\u201E", "becaus": "\u2235", "because": "\u2235", "Because": "\u2235", "bemptyv": "\u29B0", "bepsi": "\u03F6", "bernou": "\u212C", "Bernoullis": "\u212C", "beta": "\u03B2", "Beta": "\u0392", "beth": "\u2136", "between": "\u226C", "bfr": "\u{1D51F}", "Bfr": "\u{1D505}", "bigcap": "\u22C2", "bigcirc": "\u25EF", "bigcup": "\u22C3", "bigodot": "\u2A00", "bigoplus": "\u2A01", "bigotimes": "\u2A02", "bigsqcup": "\u2A06", "bigstar": "\u2605", "bigtriangledown": "\u25BD", "bigtriangleup": "\u25B3", "biguplus": "\u2A04", "bigvee": "\u22C1", "bigwedge": "\u22C0", "bkarow": "\u290D", "blacklozenge": "\u29EB", "blacksquare": "\u25AA", "blacktriangle": "\u25B4", "blacktriangledown": "\u25BE", "blacktriangleleft": "\u25C2", "blacktriangleright": "\u25B8", "blank": "\u2423", "blk12": "\u2592", "blk14": "\u2591", "blk34": "\u2593", "block": "\u2588", "bne": "=\u20E5", "bnequiv": "\u2261\u20E5", "bnot": "\u2310", "bNot": "\u2AED", "bopf": "\u{1D553}", "Bopf": "\u{1D539}", "bot": "\u22A5", "bottom": "\u22A5", "bowtie": "\u22C8", "boxbox": "\u29C9", "boxdl": "\u2510", "boxdL": "\u2555", "boxDl": "\u2556", "boxDL": "\u2557", "boxdr": "\u250C", "boxdR": "\u2552", "boxDr": "\u2553", "boxDR": "\u2554", "boxh": "\u2500", "boxH": "\u2550", "boxhd": "\u252C", "boxhD": "\u2565", "boxHd": "\u2564", "boxHD": "\u2566", "boxhu": "\u2534", "boxhU": "\u2568", "boxHu": "\u2567", "boxHU": "\u2569", "boxminus": "\u229F", "boxplus": "\u229E", "boxtimes": "\u22A0", "boxul": "\u2518", "boxuL": "\u255B", "boxUl": "\u255C", "boxUL": "\u255D", "boxur": "\u2514", "boxuR": "\u2558", "boxUr": "\u2559", "boxUR": "\u255A", "boxv": "\u2502", "boxV": "\u2551", "boxvh": "\u253C", "boxvH": "\u256A", "boxVh": "\u256B", "boxVH": "\u256C", "boxvl": "\u2524", "boxvL": "\u2561", "boxVl": "\u2562", "boxVL": "\u2563", "boxvr": "\u251C", "boxvR": "\u255E", "boxVr": "\u255F", "boxVR": "\u2560", "bprime": "\u2035", "breve": "\u02D8", "Breve": "\u02D8", "brvbar": "\xA6", "bscr": "\u{1D4B7}", "Bscr": "\u212C", "bsemi": "\u204F", "bsim": "\u223D", "bsime": "\u22CD", "bsol": "\\", "bsolb": "\u29C5", "bsolhsub": "\u27C8", "bull": "\u2022", "bullet": "\u2022", "bump": "\u224E", "bumpe": "\u224F", "bumpE": "\u2AAE", "bumpeq": "\u224F", "Bumpeq": "\u224E", "cacute": "\u0107", "Cacute": "\u0106", "cap": "\u2229", "Cap": "\u22D2", "capand": "\u2A44", "capbrcup": "\u2A49", "capcap": "\u2A4B", "capcup": "\u2A47", "capdot": "\u2A40", "CapitalDifferentialD": "\u2145", "caps": "\u2229\uFE00", "caret": "\u2041", "caron": "\u02C7", "Cayleys": "\u212D", "ccaps": "\u2A4D", "ccaron": "\u010D", "Ccaron": "\u010C", "ccedil": "\xE7", "Ccedil": "\xC7", "ccirc": "\u0109", "Ccirc": "\u0108", "Cconint": "\u2230", "ccups": "\u2A4C", "ccupssm": "\u2A50", "cdot": "\u010B", "Cdot": "\u010A", "cedil": "\xB8", "Cedilla": "\xB8", "cemptyv": "\u29B2", "cent": "\xA2", "centerdot": "\xB7", "CenterDot": "\xB7", "cfr": "\u{1D520}", "Cfr": "\u212D", "chcy": "\u0447", "CHcy": "\u0427", "check": "\u2713", "checkmark": "\u2713", "chi": "\u03C7", "Chi": "\u03A7", "cir": "\u25CB", "circ": "\u02C6", "circeq": "\u2257", "circlearrowleft": "\u21BA", "circlearrowright": "\u21BB", "circledast": "\u229B", "circledcirc": "\u229A", "circleddash": "\u229D", "CircleDot": "\u2299", "circledR": "\xAE", "circledS": "\u24C8", "CircleMinus": "\u2296", "CirclePlus": "\u2295", "CircleTimes": "\u2297", "cire": "\u2257", "cirE": "\u29C3", "cirfnint": "\u2A10", "cirmid": "\u2AEF", "cirscir": "\u29C2", "ClockwiseContourIntegral": "\u2232", "CloseCurlyDoubleQuote": "\u201D", "CloseCurlyQuote": "\u2019", "clubs": "\u2663", "clubsuit": "\u2663", "colon": ":", "Colon": "\u2237", "colone": "\u2254", "Colone": "\u2A74", "coloneq": "\u2254", "comma": ",", "commat": "@", "comp": "\u2201", "compfn": "\u2218", "complement": "\u2201", "complexes": "\u2102", "cong": "\u2245", "congdot": "\u2A6D", "Congruent": "\u2261", "conint": "\u222E", "Conint": "\u222F", "ContourIntegral": "\u222E", "copf": "\u{1D554}", "Copf": "\u2102", "coprod": "\u2210", "Coproduct": "\u2210", "copy": "\xA9", "COPY": "\xA9", "copysr": "\u2117", "CounterClockwiseContourIntegral": "\u2233", "crarr": "\u21B5", "cross": "\u2717", "Cross": "\u2A2F", "cscr": "\u{1D4B8}", "Cscr": "\u{1D49E}", "csub": "\u2ACF", "csube": "\u2AD1", "csup": "\u2AD0", "csupe": "\u2AD2", "ctdot": "\u22EF", "cudarrl": "\u2938", "cudarrr": "\u2935", "cuepr": "\u22DE", "cuesc": "\u22DF", "cularr": "\u21B6", "cularrp": "\u293D", "cup": "\u222A", "Cup": "\u22D3", "cupbrcap": "\u2A48", "cupcap": "\u2A46", "CupCap": "\u224D", "cupcup": "\u2A4A", "cupdot": "\u228D", "cupor": "\u2A45", "cups": "\u222A\uFE00", "curarr": "\u21B7", "curarrm": "\u293C", "curlyeqprec": "\u22DE", "curlyeqsucc": "\u22DF", "curlyvee": "\u22CE", "curlywedge": "\u22CF", "curren": "\xA4", "curvearrowleft": "\u21B6", "curvearrowright": "\u21B7", "cuvee": "\u22CE", "cuwed": "\u22CF", "cwconint": "\u2232", "cwint": "\u2231", "cylcty": "\u232D", "dagger": "\u2020", "Dagger": "\u2021", "daleth": "\u2138", "darr": "\u2193", "dArr": "\u21D3", "Darr": "\u21A1", "dash": "\u2010", "dashv": "\u22A3", "Dashv": "\u2AE4", "dbkarow": "\u290F", "dblac": "\u02DD", "dcaron": "\u010F", "Dcaron": "\u010E", "dcy": "\u0434", "Dcy": "\u0414", "dd": "\u2146", "DD": "\u2145", "ddagger": "\u2021", "ddarr": "\u21CA", "DDotrahd": "\u2911", "ddotseq": "\u2A77", "deg": "\xB0", "Del": "\u2207", "delta": "\u03B4", "Delta": "\u0394", "demptyv": "\u29B1", "dfisht": "\u297F", "dfr": "\u{1D521}", "Dfr": "\u{1D507}", "dHar": "\u2965", "dharl": "\u21C3", "dharr": "\u21C2", "DiacriticalAcute": "\xB4", "DiacriticalDot": "\u02D9", "DiacriticalDoubleAcute": "\u02DD", "DiacriticalGrave": "`", "DiacriticalTilde": "\u02DC", "diam": "\u22C4", "diamond": "\u22C4", "Diamond": "\u22C4", "diamondsuit": "\u2666", "diams": "\u2666", "die": "\xA8", "DifferentialD": "\u2146", "digamma": "\u03DD", "disin": "\u22F2", "div": "\xF7", "divide": "\xF7", "divideontimes": "\u22C7", "divonx": "\u22C7", "djcy": "\u0452", "DJcy": "\u0402", "dlcorn": "\u231E", "dlcrop": "\u230D", "dollar": "$", "dopf": "\u{1D555}", "Dopf": "\u{1D53B}", "dot": "\u02D9", "Dot": "\xA8", "DotDot": "\u20DC", "doteq": "\u2250", "doteqdot": "\u2251", "DotEqual": "\u2250", "dotminus": "\u2238", "dotplus": "\u2214", "dotsquare": "\u22A1", "doublebarwedge": "\u2306", "DoubleContourIntegral": "\u222F", "DoubleDot": "\xA8", "DoubleDownArrow": "\u21D3", "DoubleLeftArrow": "\u21D0", "DoubleLeftRightArrow": "\u21D4", "DoubleLeftTee": "\u2AE4", "DoubleLongLeftArrow": "\u27F8", "DoubleLongLeftRightArrow": "\u27FA", "DoubleLongRightArrow": "\u27F9", "DoubleRightArrow": "\u21D2", "DoubleRightTee": "\u22A8", "DoubleUpArrow": "\u21D1", "DoubleUpDownArrow": "\u21D5", "DoubleVerticalBar": "\u2225", "downarrow": "\u2193", "Downarrow": "\u21D3", "DownArrow": "\u2193", "DownArrowBar": "\u2913", "DownArrowUpArrow": "\u21F5", "DownBreve": "\u0311", "downdownarrows": "\u21CA", "downharpoonleft": "\u21C3", "downharpoonright": "\u21C2", "DownLeftRightVector": "\u2950", "DownLeftTeeVector": "\u295E", "DownLeftVector": "\u21BD", "DownLeftVectorBar": "\u2956", "DownRightTeeVector": "\u295F", "DownRightVector": "\u21C1", "DownRightVectorBar": "\u2957", "DownTee": "\u22A4", "DownTeeArrow": "\u21A7", "drbkarow": "\u2910", "drcorn": "\u231F", "drcrop": "\u230C", "dscr": "\u{1D4B9}", "Dscr": "\u{1D49F}", "dscy": "\u0455", "DScy": "\u0405", "dsol": "\u29F6", "dstrok": "\u0111", "Dstrok": "\u0110", "dtdot": "\u22F1", "dtri": "\u25BF", "dtrif": "\u25BE", "duarr": "\u21F5", "duhar": "\u296F", "dwangle": "\u29A6", "dzcy": "\u045F", "DZcy": "\u040F", "dzigrarr": "\u27FF", "eacute": "\xE9", "Eacute": "\xC9", "easter": "\u2A6E", "ecaron": "\u011B", "Ecaron": "\u011A", "ecir": "\u2256", "ecirc": "\xEA", "Ecirc": "\xCA", "ecolon": "\u2255", "ecy": "\u044D", "Ecy": "\u042D", "eDDot": "\u2A77", "edot": "\u0117", "eDot": "\u2251", "Edot": "\u0116", "ee": "\u2147", "efDot": "\u2252", "efr": "\u{1D522}", "Efr": "\u{1D508}", "eg": "\u2A9A", "egrave": "\xE8", "Egrave": "\xC8", "egs": "\u2A96", "egsdot": "\u2A98", "el": "\u2A99", "Element": "\u2208", "elinters": "\u23E7", "ell": "\u2113", "els": "\u2A95", "elsdot": "\u2A97", "emacr": "\u0113", "Emacr": "\u0112", "empty": "\u2205", "emptyset": "\u2205", "EmptySmallSquare": "\u25FB", "emptyv": "\u2205", "EmptyVerySmallSquare": "\u25AB", "emsp": "\u2003", "emsp13": "\u2004", "emsp14": "\u2005", "eng": "\u014B", "ENG": "\u014A", "ensp": "\u2002", "eogon": "\u0119", "Eogon": "\u0118", "eopf": "\u{1D556}", "Eopf": "\u{1D53C}", "epar": "\u22D5", "eparsl": "\u29E3", "eplus": "\u2A71", "epsi": "\u03B5", "epsilon": "\u03B5", "Epsilon": "\u0395", "epsiv": "\u03F5", "eqcirc": "\u2256", "eqcolon": "\u2255", "eqsim": "\u2242", "eqslantgtr": "\u2A96", "eqslantless": "\u2A95", "Equal": "\u2A75", "equals": "=", "EqualTilde": "\u2242", "equest": "\u225F", "Equilibrium": "\u21CC", "equiv": "\u2261", "equivDD": "\u2A78", "eqvparsl": "\u29E5", "erarr": "\u2971", "erDot": "\u2253", "escr": "\u212F", "Escr": "\u2130", "esdot": "\u2250", "esim": "\u2242", "Esim": "\u2A73", "eta": "\u03B7", "Eta": "\u0397", "eth": "\xF0", "ETH": "\xD0", "euml": "\xEB", "Euml": "\xCB", "euro": "\u20AC", "excl": "!", "exist": "\u2203", "Exists": "\u2203", "expectation": "\u2130", "exponentiale": "\u2147", "ExponentialE": "\u2147", "fallingdotseq": "\u2252", "fcy": "\u0444", "Fcy": "\u0424", "female": "\u2640", "ffilig": "\uFB03", "fflig": "\uFB00", "ffllig": "\uFB04", "ffr": "\u{1D523}", "Ffr": "\u{1D509}", "filig": "\uFB01", "FilledSmallSquare": "\u25FC", "FilledVerySmallSquare": "\u25AA", "fjlig": "fj", "flat": "\u266D", "fllig": "\uFB02", "fltns": "\u25B1", "fnof": "\u0192", "fopf": "\u{1D557}", "Fopf": "\u{1D53D}", "forall": "\u2200", "ForAll": "\u2200", "fork": "\u22D4", "forkv": "\u2AD9", "Fouriertrf": "\u2131", "fpartint": "\u2A0D", "frac12": "\xBD", "frac13": "\u2153", "frac14": "\xBC", "frac15": "\u2155", "frac16": "\u2159", "frac18": "\u215B", "frac23": "\u2154", "frac25": "\u2156", "frac34": "\xBE", "frac35": "\u2157", "frac38": "\u215C", "frac45": "\u2158", "frac56": "\u215A", "frac58": "\u215D", "frac78": "\u215E", "frasl": "\u2044", "frown": "\u2322", "fscr": "\u{1D4BB}", "Fscr": "\u2131", "gacute": "\u01F5", "gamma": "\u03B3", "Gamma": "\u0393", "gammad": "\u03DD", "Gammad": "\u03DC", "gap": "\u2A86", "gbreve": "\u011F", "Gbreve": "\u011E", "Gcedil": "\u0122", "gcirc": "\u011D", "Gcirc": "\u011C", "gcy": "\u0433", "Gcy": "\u0413", "gdot": "\u0121", "Gdot": "\u0120", "ge": "\u2265", "gE": "\u2267", "gel": "\u22DB", "gEl": "\u2A8C", "geq": "\u2265", "geqq": "\u2267", "geqslant": "\u2A7E", "ges": "\u2A7E", "gescc": "\u2AA9", "gesdot": "\u2A80", "gesdoto": "\u2A82", "gesdotol": "\u2A84", "gesl": "\u22DB\uFE00", "gesles": "\u2A94", "gfr": "\u{1D524}", "Gfr": "\u{1D50A}", "gg": "\u226B", "Gg": "\u22D9", "ggg": "\u22D9", "gimel": "\u2137", "gjcy": "\u0453", "GJcy": "\u0403", "gl": "\u2277", "gla": "\u2AA5", "glE": "\u2A92", "glj": "\u2AA4", "gnap": "\u2A8A", "gnapprox": "\u2A8A", "gne": "\u2A88", "gnE": "\u2269", "gneq": "\u2A88", "gneqq": "\u2269", "gnsim": "\u22E7", "gopf": "\u{1D558}", "Gopf": "\u{1D53E}", "grave": "`", "GreaterEqual": "\u2265", "GreaterEqualLess": "\u22DB", "GreaterFullEqual": "\u2267", "GreaterGreater": "\u2AA2", "GreaterLess": "\u2277", "GreaterSlantEqual": "\u2A7E", "GreaterTilde": "\u2273", "gscr": "\u210A", "Gscr": "\u{1D4A2}", "gsim": "\u2273", "gsime": "\u2A8E", "gsiml": "\u2A90", "gt": ">", "Gt": "\u226B", "GT": ">", "gtcc": "\u2AA7", "gtcir": "\u2A7A", "gtdot": "\u22D7", "gtlPar": "\u2995", "gtquest": "\u2A7C", "gtrapprox": "\u2A86", "gtrarr": "\u2978", "gtrdot": "\u22D7", "gtreqless": "\u22DB", "gtreqqless": "\u2A8C", "gtrless": "\u2277", "gtrsim": "\u2273", "gvertneqq": "\u2269\uFE00", "gvnE": "\u2269\uFE00", "Hacek": "\u02C7", "hairsp": "\u200A", "half": "\xBD", "hamilt": "\u210B", "hardcy": "\u044A", "HARDcy": "\u042A", "harr": "\u2194", "hArr": "\u21D4", "harrcir": "\u2948", "harrw": "\u21AD", "Hat": "^", "hbar": "\u210F", "hcirc": "\u0125", "Hcirc": "\u0124", "hearts": "\u2665", "heartsuit": "\u2665", "hellip": "\u2026", "hercon": "\u22B9", "hfr": "\u{1D525}", "Hfr": "\u210C", "HilbertSpace": "\u210B", "hksearow": "\u2925", "hkswarow": "\u2926", "hoarr": "\u21FF", "homtht": "\u223B", "hookleftarrow": "\u21A9", "hookrightarrow": "\u21AA", "hopf": "\u{1D559}", "Hopf": "\u210D", "horbar": "\u2015", "HorizontalLine": "\u2500", "hscr": "\u{1D4BD}", "Hscr": "\u210B", "hslash": "\u210F", "hstrok": "\u0127", "Hstrok": "\u0126", "HumpDownHump": "\u224E", "HumpEqual": "\u224F", "hybull": "\u2043", "hyphen": "\u2010", "iacute": "\xED", "Iacute": "\xCD", "ic": "\u2063", "icirc": "\xEE", "Icirc": "\xCE", "icy": "\u0438", "Icy": "\u0418", "Idot": "\u0130", "iecy": "\u0435", "IEcy": "\u0415", "iexcl": "\xA1", "iff": "\u21D4", "ifr": "\u{1D526}", "Ifr": "\u2111", "igrave": "\xEC", "Igrave": "\xCC", "ii": "\u2148", "iiiint": "\u2A0C", "iiint": "\u222D", "iinfin": "\u29DC", "iiota": "\u2129", "ijlig": "\u0133", "IJlig": "\u0132", "Im": "\u2111", "imacr": "\u012B", "Imacr": "\u012A", "image": "\u2111", "ImaginaryI": "\u2148", "imagline": "\u2110", "imagpart": "\u2111", "imath": "\u0131", "imof": "\u22B7", "imped": "\u01B5", "Implies": "\u21D2", "in": "\u2208", "incare": "\u2105", "infin": "\u221E", "infintie": "\u29DD", "inodot": "\u0131", "int": "\u222B", "Int": "\u222C", "intcal": "\u22BA", "integers": "\u2124", "Integral": "\u222B", "intercal": "\u22BA", "Intersection": "\u22C2", "intlarhk": "\u2A17", "intprod": "\u2A3C", "InvisibleComma": "\u2063", "InvisibleTimes": "\u2062", "iocy": "\u0451", "IOcy": "\u0401", "iogon": "\u012F", "Iogon": "\u012E", "iopf": "\u{1D55A}", "Iopf": "\u{1D540}", "iota": "\u03B9", "Iota": "\u0399", "iprod": "\u2A3C", "iquest": "\xBF", "iscr": "\u{1D4BE}", "Iscr": "\u2110", "isin": "\u2208", "isindot": "\u22F5", "isinE": "\u22F9", "isins": "\u22F4", "isinsv": "\u22F3", "isinv": "\u2208", "it": "\u2062", "itilde": "\u0129", "Itilde": "\u0128", "iukcy": "\u0456", "Iukcy": "\u0406", "iuml": "\xEF", "Iuml": "\xCF", "jcirc": "\u0135", "Jcirc": "\u0134", "jcy": "\u0439", "Jcy": "\u0419", "jfr": "\u{1D527}", "Jfr": "\u{1D50D}", "jmath": "\u0237", "jopf": "\u{1D55B}", "Jopf": "\u{1D541}", "jscr": "\u{1D4BF}", "Jscr": "\u{1D4A5}", "jsercy": "\u0458", "Jsercy": "\u0408", "jukcy": "\u0454", "Jukcy": "\u0404", "kappa": "\u03BA", "Kappa": "\u039A", "kappav": "\u03F0", "kcedil": "\u0137", "Kcedil": "\u0136", "kcy": "\u043A", "Kcy": "\u041A", "kfr": "\u{1D528}", "Kfr": "\u{1D50E}", "kgreen": "\u0138", "khcy": "\u0445", "KHcy": "\u0425", "kjcy": "\u045C", "KJcy": "\u040C", "kopf": "\u{1D55C}", "Kopf": "\u{1D542}", "kscr": "\u{1D4C0}", "Kscr": "\u{1D4A6}", "lAarr": "\u21DA", "lacute": "\u013A", "Lacute": "\u0139", "laemptyv": "\u29B4", "lagran": "\u2112", "lambda": "\u03BB", "Lambda": "\u039B", "lang": "\u27E8", "Lang": "\u27EA", "langd": "\u2991", "langle": "\u27E8", "lap": "\u2A85", "Laplacetrf": "\u2112", "laquo": "\xAB", "larr": "\u2190", "lArr": "\u21D0", "Larr": "\u219E", "larrb": "\u21E4", "larrbfs": "\u291F", "larrfs": "\u291D", "larrhk": "\u21A9", "larrlp": "\u21AB", "larrpl": "\u2939", "larrsim": "\u2973", "larrtl": "\u21A2", "lat": "\u2AAB", "latail": "\u2919", "lAtail": "\u291B", "late": "\u2AAD", "lates": "\u2AAD\uFE00", "lbarr": "\u290C", "lBarr": "\u290E", "lbbrk": "\u2772", "lbrace": "{", "lbrack": "[", "lbrke": "\u298B", "lbrksld": "\u298F", "lbrkslu": "\u298D", "lcaron": "\u013E", "Lcaron": "\u013D", "lcedil": "\u013C", "Lcedil": "\u013B", "lceil": "\u2308", "lcub": "{", "lcy": "\u043B", "Lcy": "\u041B", "ldca": "\u2936", "ldquo": "\u201C", "ldquor": "\u201E", "ldrdhar": "\u2967", "ldrushar": "\u294B", "ldsh": "\u21B2", "le": "\u2264", "lE": "\u2266", "LeftAngleBracket": "\u27E8", "leftarrow": "\u2190", "Leftarrow": "\u21D0", "LeftArrow": "\u2190", "LeftArrowBar": "\u21E4", "LeftArrowRightArrow": "\u21C6", "leftarrowtail": "\u21A2", "LeftCeiling": "\u2308", "LeftDoubleBracket": "\u27E6", "LeftDownTeeVector": "\u2961", "LeftDownVector": "\u21C3", "LeftDownVectorBar": "\u2959", "LeftFloor": "\u230A", "leftharpoondown": "\u21BD", "leftharpoonup": "\u21BC", "leftleftarrows": "\u21C7", "leftrightarrow": "\u2194", "Leftrightarrow": "\u21D4", "LeftRightArrow": "\u2194", "leftrightarrows": "\u21C6", "leftrightharpoons": "\u21CB", "leftrightsquigarrow": "\u21AD", "LeftRightVector": "\u294E", "LeftTee": "\u22A3", "LeftTeeArrow": "\u21A4", "LeftTeeVector": "\u295A", "leftthreetimes": "\u22CB", "LeftTriangle": "\u22B2", "LeftTriangleBar": "\u29CF", "LeftTriangleEqual": "\u22B4", "LeftUpDownVector": "\u2951", "LeftUpTeeVector": "\u2960", "LeftUpVector": "\u21BF", "LeftUpVectorBar": "\u2958", "LeftVector": "\u21BC", "LeftVectorBar": "\u2952", "leg": "\u22DA", "lEg": "\u2A8B", "leq": "\u2264", "leqq": "\u2266", "leqslant": "\u2A7D", "les": "\u2A7D", "lescc": "\u2AA8", "lesdot": "\u2A7F", "lesdoto": "\u2A81", "lesdotor": "\u2A83", "lesg": "\u22DA\uFE00", "lesges": "\u2A93", "lessapprox": "\u2A85", "lessdot": "\u22D6", "lesseqgtr": "\u22DA", "lesseqqgtr": "\u2A8B", "LessEqualGreater": "\u22DA", "LessFullEqual": "\u2266", "LessGreater": "\u2276", "lessgtr": "\u2276", "LessLess": "\u2AA1", "lesssim": "\u2272", "LessSlantEqual": "\u2A7D", "LessTilde": "\u2272", "lfisht": "\u297C", "lfloor": "\u230A", "lfr": "\u{1D529}", "Lfr": "\u{1D50F}", "lg": "\u2276", "lgE": "\u2A91", "lHar": "\u2962", "lhard": "\u21BD", "lharu": "\u21BC", "lharul": "\u296A", "lhblk": "\u2584", "ljcy": "\u0459", "LJcy": "\u0409", "ll": "\u226A", "Ll": "\u22D8", "llarr": "\u21C7", "llcorner": "\u231E", "Lleftarrow": "\u21DA", "llhard": "\u296B", "lltri": "\u25FA", "lmidot": "\u0140", "Lmidot": "\u013F", "lmoust": "\u23B0", "lmoustache": "\u23B0", "lnap": "\u2A89", "lnapprox": "\u2A89", "lne": "\u2A87", "lnE": "\u2268", "lneq": "\u2A87", "lneqq": "\u2268", "lnsim": "\u22E6", "loang": "\u27EC", "loarr": "\u21FD", "lobrk": "\u27E6", "longleftarrow": "\u27F5", "Longleftarrow": "\u27F8", "LongLeftArrow": "\u27F5", "longleftrightarrow": "\u27F7", "Longleftrightarrow": "\u27FA", "LongLeftRightArrow": "\u27F7", "longmapsto": "\u27FC", "longrightarrow": "\u27F6", "Longrightarrow": "\u27F9", "LongRightArrow": "\u27F6", "looparrowleft": "\u21AB", "looparrowright": "\u21AC", "lopar": "\u2985", "lopf": "\u{1D55D}", "Lopf": "\u{1D543}", "loplus": "\u2A2D", "lotimes": "\u2A34", "lowast": "\u2217", "lowbar": "_", "LowerLeftArrow": "\u2199", "LowerRightArrow": "\u2198", "loz": "\u25CA", "lozenge": "\u25CA", "lozf": "\u29EB", "lpar": "(", "lparlt": "\u2993", "lrarr": "\u21C6", "lrcorner": "\u231F", "lrhar": "\u21CB", "lrhard": "\u296D", "lrm": "\u200E", "lrtri": "\u22BF", "lsaquo": "\u2039", "lscr": "\u{1D4C1}", "Lscr": "\u2112", "lsh": "\u21B0", "Lsh": "\u21B0", "lsim": "\u2272", "lsime": "\u2A8D", "lsimg": "\u2A8F", "lsqb": "[", "lsquo": "\u2018", "lsquor": "\u201A", "lstrok": "\u0142", "Lstrok": "\u0141", "lt": "<", "Lt": "\u226A", "LT": "<", "ltcc": "\u2AA6", "ltcir": "\u2A79", "ltdot": "\u22D6", "lthree": "\u22CB", "ltimes": "\u22C9", "ltlarr": "\u2976", "ltquest": "\u2A7B", "ltri": "\u25C3", "ltrie": "\u22B4", "ltrif": "\u25C2", "ltrPar": "\u2996", "lurdshar": "\u294A", "luruhar": "\u2966", "lvertneqq": "\u2268\uFE00", "lvnE": "\u2268\uFE00", "macr": "\xAF", "male": "\u2642", "malt": "\u2720", "maltese": "\u2720", "map": "\u21A6", "Map": "\u2905", "mapsto": "\u21A6", "mapstodown": "\u21A7", "mapstoleft": "\u21A4", "mapstoup": "\u21A5", "marker": "\u25AE", "mcomma": "\u2A29", "mcy": "\u043C", "Mcy": "\u041C", "mdash": "\u2014", "mDDot": "\u223A", "measuredangle": "\u2221", "MediumSpace": "\u205F", "Mellintrf": "\u2133", "mfr": "\u{1D52A}", "Mfr": "\u{1D510}", "mho": "\u2127", "micro": "\xB5", "mid": "\u2223", "midast": "*", "midcir": "\u2AF0", "middot": "\xB7", "minus": "\u2212", "minusb": "\u229F", "minusd": "\u2238", "minusdu": "\u2A2A", "MinusPlus": "\u2213", "mlcp": "\u2ADB", "mldr": "\u2026", "mnplus": "\u2213", "models": "\u22A7", "mopf": "\u{1D55E}", "Mopf": "\u{1D544}", "mp": "\u2213", "mscr": "\u{1D4C2}", "Mscr": "\u2133", "mstpos": "\u223E", "mu": "\u03BC", "Mu": "\u039C", "multimap": "\u22B8", "mumap": "\u22B8", "nabla": "\u2207", "nacute": "\u0144", "Nacute": "\u0143", "nang": "\u2220\u20D2", "nap": "\u2249", "napE": "\u2A70\u0338", "napid": "\u224B\u0338", "napos": "\u0149", "napprox": "\u2249", "natur": "\u266E", "natural": "\u266E", "naturals": "\u2115", "nbsp": "\xA0", "nbump": "\u224E\u0338", "nbumpe": "\u224F\u0338", "ncap": "\u2A43", "ncaron": "\u0148", "Ncaron": "\u0147", "ncedil": "\u0146", "Ncedil": "\u0145", "ncong": "\u2247", "ncongdot": "\u2A6D\u0338", "ncup": "\u2A42", "ncy": "\u043D", "Ncy": "\u041D", "ndash": "\u2013", "ne": "\u2260", "nearhk": "\u2924", "nearr": "\u2197", "neArr": "\u21D7", "nearrow": "\u2197", "nedot": "\u2250\u0338", "NegativeMediumSpace": "\u200B", "NegativeThickSpace": "\u200B", "NegativeThinSpace": "\u200B", "NegativeVeryThinSpace": "\u200B", "nequiv": "\u2262", "nesear": "\u2928", "nesim": "\u2242\u0338", "NestedGreaterGreater": "\u226B", "NestedLessLess": "\u226A", "NewLine": "\n", "nexist": "\u2204", "nexists": "\u2204", "nfr": "\u{1D52B}", "Nfr": "\u{1D511}", "nge": "\u2271", "ngE": "\u2267\u0338", "ngeq": "\u2271", "ngeqq": "\u2267\u0338", "ngeqslant": "\u2A7E\u0338", "nges": "\u2A7E\u0338", "nGg": "\u22D9\u0338", "ngsim": "\u2275", "ngt": "\u226F", "nGt": "\u226B\u20D2", "ngtr": "\u226F", "nGtv": "\u226B\u0338", "nharr": "\u21AE", "nhArr": "\u21CE", "nhpar": "\u2AF2", "ni": "\u220B", "nis": "\u22FC", "nisd": "\u22FA", "niv": "\u220B", "njcy": "\u045A", "NJcy": "\u040A", "nlarr": "\u219A", "nlArr": "\u21CD", "nldr": "\u2025", "nle": "\u2270", "nlE": "\u2266\u0338", "nleftarrow": "\u219A", "nLeftarrow": "\u21CD", "nleftrightarrow": "\u21AE", "nLeftrightarrow": "\u21CE", "nleq": "\u2270", "nleqq": "\u2266\u0338", "nleqslant": "\u2A7D\u0338", "nles": "\u2A7D\u0338", "nless": "\u226E", "nLl": "\u22D8\u0338", "nlsim": "\u2274", "nlt": "\u226E", "nLt": "\u226A\u20D2", "nltri": "\u22EA", "nltrie": "\u22EC", "nLtv": "\u226A\u0338", "nmid": "\u2224", "NoBreak": "\u2060", "NonBreakingSpace": "\xA0", "nopf": "\u{1D55F}", "Nopf": "\u2115", "not": "\xAC", "Not": "\u2AEC", "NotCongruent": "\u2262", "NotCupCap": "\u226D", "NotDoubleVerticalBar": "\u2226", "NotElement": "\u2209", "NotEqual": "\u2260", "NotEqualTilde": "\u2242\u0338", "NotExists": "\u2204", "NotGreater": "\u226F", "NotGreaterEqual": "\u2271", "NotGreaterFullEqual": "\u2267\u0338", "NotGreaterGreater": "\u226B\u0338", "NotGreaterLess": "\u2279", "NotGreaterSlantEqual": "\u2A7E\u0338", "NotGreaterTilde": "\u2275", "NotHumpDownHump": "\u224E\u0338", "NotHumpEqual": "\u224F\u0338", "notin": "\u2209", "notindot": "\u22F5\u0338", "notinE": "\u22F9\u0338", "notinva": "\u2209", "notinvb": "\u22F7", "notinvc": "\u22F6", "NotLeftTriangle": "\u22EA", "NotLeftTriangleBar": "\u29CF\u0338", "NotLeftTriangleEqual": "\u22EC", "NotLess": "\u226E", "NotLessEqual": "\u2270", "NotLessGreater": "\u2278", "NotLessLess": "\u226A\u0338", "NotLessSlantEqual": "\u2A7D\u0338", "NotLessTilde": "\u2274", "NotNestedGreaterGreater": "\u2AA2\u0338", "NotNestedLessLess": "\u2AA1\u0338", "notni": "\u220C", "notniva": "\u220C", "notnivb": "\u22FE", "notnivc": "\u22FD", "NotPrecedes": "\u2280", "NotPrecedesEqual": "\u2AAF\u0338", "NotPrecedesSlantEqual": "\u22E0", "NotReverseElement": "\u220C", "NotRightTriangle": "\u22EB", "NotRightTriangleBar": "\u29D0\u0338", "NotRightTriangleEqual": "\u22ED", "NotSquareSubset": "\u228F\u0338", "NotSquareSubsetEqual": "\u22E2", "NotSquareSuperset": "\u2290\u0338", "NotSquareSupersetEqual": "\u22E3", "NotSubset": "\u2282\u20D2", "NotSubsetEqual": "\u2288", "NotSucceeds": "\u2281", "NotSucceedsEqual": "\u2AB0\u0338", "NotSucceedsSlantEqual": "\u22E1", "NotSucceedsTilde": "\u227F\u0338", "NotSuperset": "\u2283\u20D2", "NotSupersetEqual": "\u2289", "NotTilde": "\u2241", "NotTildeEqual": "\u2244", "NotTildeFullEqual": "\u2247", "NotTildeTilde": "\u2249", "NotVerticalBar": "\u2224", "npar": "\u2226", "nparallel": "\u2226", "nparsl": "\u2AFD\u20E5", "npart": "\u2202\u0338", "npolint": "\u2A14", "npr": "\u2280", "nprcue": "\u22E0", "npre": "\u2AAF\u0338", "nprec": "\u2280", "npreceq": "\u2AAF\u0338", "nrarr": "\u219B", "nrArr": "\u21CF", "nrarrc": "\u2933\u0338", "nrarrw": "\u219D\u0338", "nrightarrow": "\u219B", "nRightarrow": "\u21CF", "nrtri": "\u22EB", "nrtrie": "\u22ED", "nsc": "\u2281", "nsccue": "\u22E1", "nsce": "\u2AB0\u0338", "nscr": "\u{1D4C3}", "Nscr": "\u{1D4A9}", "nshortmid": "\u2224", "nshortparallel": "\u2226", "nsim": "\u2241", "nsime": "\u2244", "nsimeq": "\u2244", "nsmid": "\u2224", "nspar": "\u2226", "nsqsube": "\u22E2", "nsqsupe": "\u22E3", "nsub": "\u2284", "nsube": "\u2288", "nsubE": "\u2AC5\u0338", "nsubset": "\u2282\u20D2", "nsubseteq": "\u2288", "nsubseteqq": "\u2AC5\u0338", "nsucc": "\u2281", "nsucceq": "\u2AB0\u0338", "nsup": "\u2285", "nsupe": "\u2289", "nsupE": "\u2AC6\u0338", "nsupset": "\u2283\u20D2", "nsupseteq": "\u2289", "nsupseteqq": "\u2AC6\u0338", "ntgl": "\u2279", "ntilde": "\xF1", "Ntilde": "\xD1", "ntlg": "\u2278", "ntriangleleft": "\u22EA", "ntrianglelefteq": "\u22EC", "ntriangleright": "\u22EB", "ntrianglerighteq": "\u22ED", "nu": "\u03BD", "Nu": "\u039D", "num": "#", "numero": "\u2116", "numsp": "\u2007", "nvap": "\u224D\u20D2", "nvdash": "\u22AC", "nvDash": "\u22AD", "nVdash": "\u22AE", "nVDash": "\u22AF", "nvge": "\u2265\u20D2", "nvgt": ">\u20D2", "nvHarr": "\u2904", "nvinfin": "\u29DE", "nvlArr": "\u2902", "nvle": "\u2264\u20D2", "nvlt": "<\u20D2", "nvltrie": "\u22B4\u20D2", "nvrArr": "\u2903", "nvrtrie": "\u22B5\u20D2", "nvsim": "\u223C\u20D2", "nwarhk": "\u2923", "nwarr": "\u2196", "nwArr": "\u21D6", "nwarrow": "\u2196", "nwnear": "\u2927", "oacute": "\xF3", "Oacute": "\xD3", "oast": "\u229B", "ocir": "\u229A", "ocirc": "\xF4", "Ocirc": "\xD4", "ocy": "\u043E", "Ocy": "\u041E", "odash": "\u229D", "odblac": "\u0151", "Odblac": "\u0150", "odiv": "\u2A38", "odot": "\u2299", "odsold": "\u29BC", "oelig": "\u0153", "OElig": "\u0152", "ofcir": "\u29BF", "ofr": "\u{1D52C}", "Ofr": "\u{1D512}", "ogon": "\u02DB", "ograve": "\xF2", "Ograve": "\xD2", "ogt": "\u29C1", "ohbar": "\u29B5", "ohm": "\u03A9", "oint": "\u222E", "olarr": "\u21BA", "olcir": "\u29BE", "olcross": "\u29BB", "oline": "\u203E", "olt": "\u29C0", "omacr": "\u014D", "Omacr": "\u014C", "omega": "\u03C9", "Omega": "\u03A9", "omicron": "\u03BF", "Omicron": "\u039F", "omid": "\u29B6", "ominus": "\u2296", "oopf": "\u{1D560}", "Oopf": "\u{1D546}", "opar": "\u29B7", "OpenCurlyDoubleQuote": "\u201C", "OpenCurlyQuote": "\u2018", "operp": "\u29B9", "oplus": "\u2295", "or": "\u2228", "Or": "\u2A54", "orarr": "\u21BB", "ord": "\u2A5D", "order": "\u2134", "orderof": "\u2134", "ordf": "\xAA", "ordm": "\xBA", "origof": "\u22B6", "oror": "\u2A56", "orslope": "\u2A57", "orv": "\u2A5B", "oS": "\u24C8", "oscr": "\u2134", "Oscr": "\u{1D4AA}", "oslash": "\xF8", "Oslash": "\xD8", "osol": "\u2298", "otilde": "\xF5", "Otilde": "\xD5", "otimes": "\u2297", "Otimes": "\u2A37", "otimesas": "\u2A36", "ouml": "\xF6", "Ouml": "\xD6", "ovbar": "\u233D", "OverBar": "\u203E", "OverBrace": "\u23DE", "OverBracket": "\u23B4", "OverParenthesis": "\u23DC", "par": "\u2225", "para": "\xB6", "parallel": "\u2225", "parsim": "\u2AF3", "parsl": "\u2AFD", "part": "\u2202", "PartialD": "\u2202", "pcy": "\u043F", "Pcy": "\u041F", "percnt": "%", "period": ".", "permil": "\u2030", "perp": "\u22A5", "pertenk": "\u2031", "pfr": "\u{1D52D}", "Pfr": "\u{1D513}", "phi": "\u03C6", "Phi": "\u03A6", "phiv": "\u03D5", "phmmat": "\u2133", "phone": "\u260E", "pi": "\u03C0", "Pi": "\u03A0", "pitchfork": "\u22D4", "piv": "\u03D6", "planck": "\u210F", "planckh": "\u210E", "plankv": "\u210F", "plus": "+", "plusacir": "\u2A23", "plusb": "\u229E", "pluscir": "\u2A22", "plusdo": "\u2214", "plusdu": "\u2A25", "pluse": "\u2A72", "PlusMinus": "\xB1", "plusmn": "\xB1", "plussim": "\u2A26", "plustwo": "\u2A27", "pm": "\xB1", "Poincareplane": "\u210C", "pointint": "\u2A15", "popf": "\u{1D561}", "Popf": "\u2119", "pound": "\xA3", "pr": "\u227A", "Pr": "\u2ABB", "prap": "\u2AB7", "prcue": "\u227C", "pre": "\u2AAF", "prE": "\u2AB3", "prec": "\u227A", "precapprox": "\u2AB7", "preccurlyeq": "\u227C", "Precedes": "\u227A", "PrecedesEqual": "\u2AAF", "PrecedesSlantEqual": "\u227C", "PrecedesTilde": "\u227E", "preceq": "\u2AAF", "precnapprox": "\u2AB9", "precneqq": "\u2AB5", "precnsim": "\u22E8", "precsim": "\u227E", "prime": "\u2032", "Prime": "\u2033", "primes": "\u2119", "prnap": "\u2AB9", "prnE": "\u2AB5", "prnsim": "\u22E8", "prod": "\u220F", "Product": "\u220F", "profalar": "\u232E", "profline": "\u2312", "profsurf": "\u2313", "prop": "\u221D", "Proportion": "\u2237", "Proportional": "\u221D", "propto": "\u221D", "prsim": "\u227E", "prurel": "\u22B0", "pscr": "\u{1D4C5}", "Pscr": "\u{1D4AB}", "psi": "\u03C8", "Psi": "\u03A8", "puncsp": "\u2008", "qfr": "\u{1D52E}", "Qfr": "\u{1D514}", "qint": "\u2A0C", "qopf": "\u{1D562}", "Qopf": "\u211A", "qprime": "\u2057", "qscr": "\u{1D4C6}", "Qscr": "\u{1D4AC}", "quaternions": "\u210D", "quatint": "\u2A16", "quest": "?", "questeq": "\u225F", "quot": '"', "QUOT": '"', "rAarr": "\u21DB", "race": "\u223D\u0331", "racute": "\u0155", "Racute": "\u0154", "radic": "\u221A", "raemptyv": "\u29B3", "rang": "\u27E9", "Rang": "\u27EB", "rangd": "\u2992", "range": "\u29A5", "rangle": "\u27E9", "raquo": "\xBB", "rarr": "\u2192", "rArr": "\u21D2", "Rarr": "\u21A0", "rarrap": "\u2975", "rarrb": "\u21E5", "rarrbfs": "\u2920", "rarrc": "\u2933", "rarrfs": "\u291E", "rarrhk": "\u21AA", "rarrlp": "\u21AC", "rarrpl": "\u2945", "rarrsim": "\u2974", "rarrtl": "\u21A3", "Rarrtl": "\u2916", "rarrw": "\u219D", "ratail": "\u291A", "rAtail": "\u291C", "ratio": "\u2236", "rationals": "\u211A", "rbarr": "\u290D", "rBarr": "\u290F", "RBarr": "\u2910", "rbbrk": "\u2773", "rbrace": "}", "rbrack": "]", "rbrke": "\u298C", "rbrksld": "\u298E", "rbrkslu": "\u2990", "rcaron": "\u0159", "Rcaron": "\u0158", "rcedil": "\u0157", "Rcedil": "\u0156", "rceil": "\u2309", "rcub": "}", "rcy": "\u0440", "Rcy": "\u0420", "rdca": "\u2937", "rdldhar": "\u2969", "rdquo": "\u201D", "rdquor": "\u201D", "rdsh": "\u21B3", "Re": "\u211C", "real": "\u211C", "realine": "\u211B", "realpart": "\u211C", "reals": "\u211D", "rect": "\u25AD", "reg": "\xAE", "REG": "\xAE", "ReverseElement": "\u220B", "ReverseEquilibrium": "\u21CB", "ReverseUpEquilibrium": "\u296F", "rfisht": "\u297D", "rfloor": "\u230B", "rfr": "\u{1D52F}", "Rfr": "\u211C", "rHar": "\u2964", "rhard": "\u21C1", "rharu": "\u21C0", "rharul": "\u296C", "rho": "\u03C1", "Rho": "\u03A1", "rhov": "\u03F1", "RightAngleBracket": "\u27E9", "rightarrow": "\u2192", "Rightarrow": "\u21D2", "RightArrow": "\u2192", "RightArrowBar": "\u21E5", "RightArrowLeftArrow": "\u21C4", "rightarrowtail": "\u21A3", "RightCeiling": "\u2309", "RightDoubleBracket": "\u27E7", "RightDownTeeVector": "\u295D", "RightDownVector": "\u21C2", "RightDownVectorBar": "\u2955", "RightFloor": "\u230B", "rightharpoondown": "\u21C1", "rightharpoonup": "\u21C0", "rightleftarrows": "\u21C4", "rightleftharpoons": "\u21CC", "rightrightarrows": "\u21C9", "rightsquigarrow": "\u219D", "RightTee": "\u22A2", "RightTeeArrow": "\u21A6", "RightTeeVector": "\u295B", "rightthreetimes": "\u22CC", "RightTriangle": "\u22B3", "RightTriangleBar": "\u29D0", "RightTriangleEqual": "\u22B5", "RightUpDownVector": "\u294F", "RightUpTeeVector": "\u295C", "RightUpVector": "\u21BE", "RightUpVectorBar": "\u2954", "RightVector": "\u21C0", "RightVectorBar": "\u2953", "ring": "\u02DA", "risingdotseq": "\u2253", "rlarr": "\u21C4", "rlhar": "\u21CC", "rlm": "\u200F", "rmoust": "\u23B1", "rmoustache": "\u23B1", "rnmid": "\u2AEE", "roang": "\u27ED", "roarr": "\u21FE", "robrk": "\u27E7", "ropar": "\u2986", "ropf": "\u{1D563}", "Ropf": "\u211D", "roplus": "\u2A2E", "rotimes": "\u2A35", "RoundImplies": "\u2970", "rpar": ")", "rpargt": "\u2994", "rppolint": "\u2A12", "rrarr": "\u21C9", "Rrightarrow": "\u21DB", "rsaquo": "\u203A", "rscr": "\u{1D4C7}", "Rscr": "\u211B", "rsh": "\u21B1", "Rsh": "\u21B1", "rsqb": "]", "rsquo": "\u2019", "rsquor": "\u2019", "rthree": "\u22CC", "rtimes": "\u22CA", "rtri": "\u25B9", "rtrie": "\u22B5", "rtrif": "\u25B8", "rtriltri": "\u29CE", "RuleDelayed": "\u29F4", "ruluhar": "\u2968", "rx": "\u211E", "sacute": "\u015B", "Sacute": "\u015A", "sbquo": "\u201A", "sc": "\u227B", "Sc": "\u2ABC", "scap": "\u2AB8", "scaron": "\u0161", "Scaron": "\u0160", "sccue": "\u227D", "sce": "\u2AB0", "scE": "\u2AB4", "scedil": "\u015F", "Scedil": "\u015E", "scirc": "\u015D", "Scirc": "\u015C", "scnap": "\u2ABA", "scnE": "\u2AB6", "scnsim": "\u22E9", "scpolint": "\u2A13", "scsim": "\u227F", "scy": "\u0441", "Scy": "\u0421", "sdot": "\u22C5", "sdotb": "\u22A1", "sdote": "\u2A66", "searhk": "\u2925", "searr": "\u2198", "seArr": "\u21D8", "searrow": "\u2198", "sect": "\xA7", "semi": ";", "seswar": "\u2929", "setminus": "\u2216", "setmn": "\u2216", "sext": "\u2736", "sfr": "\u{1D530}", "Sfr": "\u{1D516}", "sfrown": "\u2322", "sharp": "\u266F", "shchcy": "\u0449", "SHCHcy": "\u0429", "shcy": "\u0448", "SHcy": "\u0428", "ShortDownArrow": "\u2193", "ShortLeftArrow": "\u2190", "shortmid": "\u2223", "shortparallel": "\u2225", "ShortRightArrow": "\u2192", "ShortUpArrow": "\u2191", "shy": "\xAD", "sigma": "\u03C3", "Sigma": "\u03A3", "sigmaf": "\u03C2", "sigmav": "\u03C2", "sim": "\u223C", "simdot": "\u2A6A", "sime": "\u2243", "simeq": "\u2243", "simg": "\u2A9E", "simgE": "\u2AA0", "siml": "\u2A9D", "simlE": "\u2A9F", "simne": "\u2246", "simplus": "\u2A24", "simrarr": "\u2972", "slarr": "\u2190", "SmallCircle": "\u2218", "smallsetminus": "\u2216", "smashp": "\u2A33", "smeparsl": "\u29E4", "smid": "\u2223", "smile": "\u2323", "smt": "\u2AAA", "smte": "\u2AAC", "smtes": "\u2AAC\uFE00", "softcy": "\u044C", "SOFTcy": "\u042C", "sol": "/", "solb": "\u29C4", "solbar": "\u233F", "sopf": "\u{1D564}", "Sopf": "\u{1D54A}", "spades": "\u2660", "spadesuit": "\u2660", "spar": "\u2225", "sqcap": "\u2293", "sqcaps": "\u2293\uFE00", "sqcup": "\u2294", "sqcups": "\u2294\uFE00", "Sqrt": "\u221A", "sqsub": "\u228F", "sqsube": "\u2291", "sqsubset": "\u228F", "sqsubseteq": "\u2291", "sqsup": "\u2290", "sqsupe": "\u2292", "sqsupset": "\u2290", "sqsupseteq": "\u2292", "squ": "\u25A1", "square": "\u25A1", "Square": "\u25A1", "SquareIntersection": "\u2293", "SquareSubset": "\u228F", "SquareSubsetEqual": "\u2291", "SquareSuperset": "\u2290", "SquareSupersetEqual": "\u2292", "SquareUnion": "\u2294", "squarf": "\u25AA", "squf": "\u25AA", "srarr": "\u2192", "sscr": "\u{1D4C8}", "Sscr": "\u{1D4AE}", "ssetmn": "\u2216", "ssmile": "\u2323", "sstarf": "\u22C6", "star": "\u2606", "Star": "\u22C6", "starf": "\u2605", "straightepsilon": "\u03F5", "straightphi": "\u03D5", "strns": "\xAF", "sub": "\u2282", "Sub": "\u22D0", "subdot": "\u2ABD", "sube": "\u2286", "subE": "\u2AC5", "subedot": "\u2AC3", "submult": "\u2AC1", "subne": "\u228A", "subnE": "\u2ACB", "subplus": "\u2ABF", "subrarr": "\u2979", "subset": "\u2282", "Subset": "\u22D0", "subseteq": "\u2286", "subseteqq": "\u2AC5", "SubsetEqual": "\u2286", "subsetneq": "\u228A", "subsetneqq": "\u2ACB", "subsim": "\u2AC7", "subsub": "\u2AD5", "subsup": "\u2AD3", "succ": "\u227B", "succapprox": "\u2AB8", "succcurlyeq": "\u227D", "Succeeds": "\u227B", "SucceedsEqual": "\u2AB0", "SucceedsSlantEqual": "\u227D", "SucceedsTilde": "\u227F", "succeq": "\u2AB0", "succnapprox": "\u2ABA", "succneqq": "\u2AB6", "succnsim": "\u22E9", "succsim": "\u227F", "SuchThat": "\u220B", "sum": "\u2211", "Sum": "\u2211", "sung": "\u266A", "sup": "\u2283", "Sup": "\u22D1", "sup1": "\xB9", "sup2": "\xB2", "sup3": "\xB3", "supdot": "\u2ABE", "supdsub": "\u2AD8", "supe": "\u2287", "supE": "\u2AC6", "supedot": "\u2AC4", "Superset": "\u2283", "SupersetEqual": "\u2287", "suphsol": "\u27C9", "suphsub": "\u2AD7", "suplarr": "\u297B", "supmult": "\u2AC2", "supne": "\u228B", "supnE": "\u2ACC", "supplus": "\u2AC0", "supset": "\u2283", "Supset": "\u22D1", "supseteq": "\u2287", "supseteqq": "\u2AC6", "supsetneq": "\u228B", "supsetneqq": "\u2ACC", "supsim": "\u2AC8", "supsub": "\u2AD4", "supsup": "\u2AD6", "swarhk": "\u2926", "swarr": "\u2199", "swArr": "\u21D9", "swarrow": "\u2199", "swnwar": "\u292A", "szlig": "\xDF", "Tab": "	", "target": "\u2316", "tau": "\u03C4", "Tau": "\u03A4", "tbrk": "\u23B4", "tcaron": "\u0165", "Tcaron": "\u0164", "tcedil": "\u0163", "Tcedil": "\u0162", "tcy": "\u0442", "Tcy": "\u0422", "tdot": "\u20DB", "telrec": "\u2315", "tfr": "\u{1D531}", "Tfr": "\u{1D517}", "there4": "\u2234", "therefore": "\u2234", "Therefore": "\u2234", "theta": "\u03B8", "Theta": "\u0398", "thetasym": "\u03D1", "thetav": "\u03D1", "thickapprox": "\u2248", "thicksim": "\u223C", "ThickSpace": "\u205F\u200A", "thinsp": "\u2009", "ThinSpace": "\u2009", "thkap": "\u2248", "thksim": "\u223C", "thorn": "\xFE", "THORN": "\xDE", "tilde": "\u02DC", "Tilde": "\u223C", "TildeEqual": "\u2243", "TildeFullEqual": "\u2245", "TildeTilde": "\u2248", "times": "\xD7", "timesb": "\u22A0", "timesbar": "\u2A31", "timesd": "\u2A30", "tint": "\u222D", "toea": "\u2928", "top": "\u22A4", "topbot": "\u2336", "topcir": "\u2AF1", "topf": "\u{1D565}", "Topf": "\u{1D54B}", "topfork": "\u2ADA", "tosa": "\u2929", "tprime": "\u2034", "trade": "\u2122", "TRADE": "\u2122", "triangle": "\u25B5", "triangledown": "\u25BF", "triangleleft": "\u25C3", "trianglelefteq": "\u22B4", "triangleq": "\u225C", "triangleright": "\u25B9", "trianglerighteq": "\u22B5", "tridot": "\u25EC", "trie": "\u225C", "triminus": "\u2A3A", "TripleDot": "\u20DB", "triplus": "\u2A39", "trisb": "\u29CD", "tritime": "\u2A3B", "trpezium": "\u23E2", "tscr": "\u{1D4C9}", "Tscr": "\u{1D4AF}", "tscy": "\u0446", "TScy": "\u0426", "tshcy": "\u045B", "TSHcy": "\u040B", "tstrok": "\u0167", "Tstrok": "\u0166", "twixt": "\u226C", "twoheadleftarrow": "\u219E", "twoheadrightarrow": "\u21A0", "uacute": "\xFA", "Uacute": "\xDA", "uarr": "\u2191", "uArr": "\u21D1", "Uarr": "\u219F", "Uarrocir": "\u2949", "ubrcy": "\u045E", "Ubrcy": "\u040E", "ubreve": "\u016D", "Ubreve": "\u016C", "ucirc": "\xFB", "Ucirc": "\xDB", "ucy": "\u0443", "Ucy": "\u0423", "udarr": "\u21C5", "udblac": "\u0171", "Udblac": "\u0170", "udhar": "\u296E", "ufisht": "\u297E", "ufr": "\u{1D532}", "Ufr": "\u{1D518}", "ugrave": "\xF9", "Ugrave": "\xD9", "uHar": "\u2963", "uharl": "\u21BF", "uharr": "\u21BE", "uhblk": "\u2580", "ulcorn": "\u231C", "ulcorner": "\u231C", "ulcrop": "\u230F", "ultri": "\u25F8", "umacr": "\u016B", "Umacr": "\u016A", "uml": "\xA8", "UnderBar": "_", "UnderBrace": "\u23DF", "UnderBracket": "\u23B5", "UnderParenthesis": "\u23DD", "Union": "\u22C3", "UnionPlus": "\u228E", "uogon": "\u0173", "Uogon": "\u0172", "uopf": "\u{1D566}", "Uopf": "\u{1D54C}", "uparrow": "\u2191", "Uparrow": "\u21D1", "UpArrow": "\u2191", "UpArrowBar": "\u2912", "UpArrowDownArrow": "\u21C5", "updownarrow": "\u2195", "Updownarrow": "\u21D5", "UpDownArrow": "\u2195", "UpEquilibrium": "\u296E", "upharpoonleft": "\u21BF", "upharpoonright": "\u21BE", "uplus": "\u228E", "UpperLeftArrow": "\u2196", "UpperRightArrow": "\u2197", "upsi": "\u03C5", "Upsi": "\u03D2", "upsih": "\u03D2", "upsilon": "\u03C5", "Upsilon": "\u03A5", "UpTee": "\u22A5", "UpTeeArrow": "\u21A5", "upuparrows": "\u21C8", "urcorn": "\u231D", "urcorner": "\u231D", "urcrop": "\u230E", "uring": "\u016F", "Uring": "\u016E", "urtri": "\u25F9", "uscr": "\u{1D4CA}", "Uscr": "\u{1D4B0}", "utdot": "\u22F0", "utilde": "\u0169", "Utilde": "\u0168", "utri": "\u25B5", "utrif": "\u25B4", "uuarr": "\u21C8", "uuml": "\xFC", "Uuml": "\xDC", "uwangle": "\u29A7", "vangrt": "\u299C", "varepsilon": "\u03F5", "varkappa": "\u03F0", "varnothing": "\u2205", "varphi": "\u03D5", "varpi": "\u03D6", "varpropto": "\u221D", "varr": "\u2195", "vArr": "\u21D5", "varrho": "\u03F1", "varsigma": "\u03C2", "varsubsetneq": "\u228A\uFE00", "varsubsetneqq": "\u2ACB\uFE00", "varsupsetneq": "\u228B\uFE00", "varsupsetneqq": "\u2ACC\uFE00", "vartheta": "\u03D1", "vartriangleleft": "\u22B2", "vartriangleright": "\u22B3", "vBar": "\u2AE8", "Vbar": "\u2AEB", "vBarv": "\u2AE9", "vcy": "\u0432", "Vcy": "\u0412", "vdash": "\u22A2", "vDash": "\u22A8", "Vdash": "\u22A9", "VDash": "\u22AB", "Vdashl": "\u2AE6", "vee": "\u2228", "Vee": "\u22C1", "veebar": "\u22BB", "veeeq": "\u225A", "vellip": "\u22EE", "verbar": "|", "Verbar": "\u2016", "vert": "|", "Vert": "\u2016", "VerticalBar": "\u2223", "VerticalLine": "|", "VerticalSeparator": "\u2758", "VerticalTilde": "\u2240", "VeryThinSpace": "\u200A", "vfr": "\u{1D533}", "Vfr": "\u{1D519}", "vltri": "\u22B2", "vnsub": "\u2282\u20D2", "vnsup": "\u2283\u20D2", "vopf": "\u{1D567}", "Vopf": "\u{1D54D}", "vprop": "\u221D", "vrtri": "\u22B3", "vscr": "\u{1D4CB}", "Vscr": "\u{1D4B1}", "vsubne": "\u228A\uFE00", "vsubnE": "\u2ACB\uFE00", "vsupne": "\u228B\uFE00", "vsupnE": "\u2ACC\uFE00", "Vvdash": "\u22AA", "vzigzag": "\u299A", "wcirc": "\u0175", "Wcirc": "\u0174", "wedbar": "\u2A5F", "wedge": "\u2227", "Wedge": "\u22C0", "wedgeq": "\u2259", "weierp": "\u2118", "wfr": "\u{1D534}", "Wfr": "\u{1D51A}", "wopf": "\u{1D568}", "Wopf": "\u{1D54E}", "wp": "\u2118", "wr": "\u2240", "wreath": "\u2240", "wscr": "\u{1D4CC}", "Wscr": "\u{1D4B2}", "xcap": "\u22C2", "xcirc": "\u25EF", "xcup": "\u22C3", "xdtri": "\u25BD", "xfr": "\u{1D535}", "Xfr": "\u{1D51B}", "xharr": "\u27F7", "xhArr": "\u27FA", "xi": "\u03BE", "Xi": "\u039E", "xlarr": "\u27F5", "xlArr": "\u27F8", "xmap": "\u27FC", "xnis": "\u22FB", "xodot": "\u2A00", "xopf": "\u{1D569}", "Xopf": "\u{1D54F}", "xoplus": "\u2A01", "xotime": "\u2A02", "xrarr": "\u27F6", "xrArr": "\u27F9", "xscr": "\u{1D4CD}", "Xscr": "\u{1D4B3}", "xsqcup": "\u2A06", "xuplus": "\u2A04", "xutri": "\u25B3", "xvee": "\u22C1", "xwedge": "\u22C0", "yacute": "\xFD", "Yacute": "\xDD", "yacy": "\u044F", "YAcy": "\u042F", "ycirc": "\u0177", "Ycirc": "\u0176", "ycy": "\u044B", "Ycy": "\u042B", "yen": "\xA5", "yfr": "\u{1D536}", "Yfr": "\u{1D51C}", "yicy": "\u0457", "YIcy": "\u0407", "yopf": "\u{1D56A}", "Yopf": "\u{1D550}", "yscr": "\u{1D4CE}", "Yscr": "\u{1D4B4}", "yucy": "\u044E", "YUcy": "\u042E", "yuml": "\xFF", "Yuml": "\u0178", "zacute": "\u017A", "Zacute": "\u0179", "zcaron": "\u017E", "Zcaron": "\u017D", "zcy": "\u0437", "Zcy": "\u0417", "zdot": "\u017C", "Zdot": "\u017B", "zeetrf": "\u2128", "ZeroWidthSpace": "\u200B", "zeta": "\u03B6", "Zeta": "\u0396", "zfr": "\u{1D537}", "Zfr": "\u2128", "zhcy": "\u0436", "ZHcy": "\u0416", "zigrarr": "\u21DD", "zopf": "\u{1D56B}", "Zopf": "\u2124", "zscr": "\u{1D4CF}", "Zscr": "\u{1D4B5}", "zwj": "\u200D", "zwnj": "\u200C" };
      var decodeMapLegacy = { "aacute": "\xE1", "Aacute": "\xC1", "acirc": "\xE2", "Acirc": "\xC2", "acute": "\xB4", "aelig": "\xE6", "AElig": "\xC6", "agrave": "\xE0", "Agrave": "\xC0", "amp": "&", "AMP": "&", "aring": "\xE5", "Aring": "\xC5", "atilde": "\xE3", "Atilde": "\xC3", "auml": "\xE4", "Auml": "\xC4", "brvbar": "\xA6", "ccedil": "\xE7", "Ccedil": "\xC7", "cedil": "\xB8", "cent": "\xA2", "copy": "\xA9", "COPY": "\xA9", "curren": "\xA4", "deg": "\xB0", "divide": "\xF7", "eacute": "\xE9", "Eacute": "\xC9", "ecirc": "\xEA", "Ecirc": "\xCA", "egrave": "\xE8", "Egrave": "\xC8", "eth": "\xF0", "ETH": "\xD0", "euml": "\xEB", "Euml": "\xCB", "frac12": "\xBD", "frac14": "\xBC", "frac34": "\xBE", "gt": ">", "GT": ">", "iacute": "\xED", "Iacute": "\xCD", "icirc": "\xEE", "Icirc": "\xCE", "iexcl": "\xA1", "igrave": "\xEC", "Igrave": "\xCC", "iquest": "\xBF", "iuml": "\xEF", "Iuml": "\xCF", "laquo": "\xAB", "lt": "<", "LT": "<", "macr": "\xAF", "micro": "\xB5", "middot": "\xB7", "nbsp": "\xA0", "not": "\xAC", "ntilde": "\xF1", "Ntilde": "\xD1", "oacute": "\xF3", "Oacute": "\xD3", "ocirc": "\xF4", "Ocirc": "\xD4", "ograve": "\xF2", "Ograve": "\xD2", "ordf": "\xAA", "ordm": "\xBA", "oslash": "\xF8", "Oslash": "\xD8", "otilde": "\xF5", "Otilde": "\xD5", "ouml": "\xF6", "Ouml": "\xD6", "para": "\xB6", "plusmn": "\xB1", "pound": "\xA3", "quot": '"', "QUOT": '"', "raquo": "\xBB", "reg": "\xAE", "REG": "\xAE", "sect": "\xA7", "shy": "\xAD", "sup1": "\xB9", "sup2": "\xB2", "sup3": "\xB3", "szlig": "\xDF", "thorn": "\xFE", "THORN": "\xDE", "times": "\xD7", "uacute": "\xFA", "Uacute": "\xDA", "ucirc": "\xFB", "Ucirc": "\xDB", "ugrave": "\xF9", "Ugrave": "\xD9", "uml": "\xA8", "uuml": "\xFC", "Uuml": "\xDC", "yacute": "\xFD", "Yacute": "\xDD", "yen": "\xA5", "yuml": "\xFF" };
      var decodeMapNumeric = { "0": "\uFFFD", "128": "\u20AC", "130": "\u201A", "131": "\u0192", "132": "\u201E", "133": "\u2026", "134": "\u2020", "135": "\u2021", "136": "\u02C6", "137": "\u2030", "138": "\u0160", "139": "\u2039", "140": "\u0152", "142": "\u017D", "145": "\u2018", "146": "\u2019", "147": "\u201C", "148": "\u201D", "149": "\u2022", "150": "\u2013", "151": "\u2014", "152": "\u02DC", "153": "\u2122", "154": "\u0161", "155": "\u203A", "156": "\u0153", "158": "\u017E", "159": "\u0178" };
      var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65e3, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];
      var stringFromCharCode = String.fromCharCode;
      var object = {};
      var hasOwnProperty = object.hasOwnProperty;
      var has = function(object2, propertyName) {
        return hasOwnProperty.call(object2, propertyName);
      };
      var contains = function(array, value) {
        var index = -1;
        var length = array.length;
        while (++index < length) {
          if (array[index] == value) {
            return true;
          }
        }
        return false;
      };
      var merge = function(options, defaults) {
        if (!options) {
          return defaults;
        }
        var result = {};
        var key3;
        for (key3 in defaults) {
          result[key3] = has(options, key3) ? options[key3] : defaults[key3];
        }
        return result;
      };
      var codePointToSymbol = function(codePoint, strict) {
        var output = "";
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
          if (strict) {
            parseError("character reference outside the permissible Unicode range");
          }
          return "\uFFFD";
        }
        if (has(decodeMapNumeric, codePoint)) {
          if (strict) {
            parseError("disallowed character reference");
          }
          return decodeMapNumeric[codePoint];
        }
        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
          parseError("disallowed character reference");
        }
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        output += stringFromCharCode(codePoint);
        return output;
      };
      var hexEscape = function(codePoint) {
        return "&#x" + codePoint.toString(16).toUpperCase() + ";";
      };
      var decEscape = function(codePoint) {
        return "&#" + codePoint + ";";
      };
      var parseError = function(message) {
        throw Error("Parse error: " + message);
      };
      var encode2 = function(string, options) {
        options = merge(options, encode2.options);
        var strict = options.strict;
        if (strict && regexInvalidRawCodePoint.test(string)) {
          parseError("forbidden code point");
        }
        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
        var escapeBmpSymbol = function(symbol) {
          return escapeCodePoint(symbol.charCodeAt(0));
        };
        if (encodeEverything) {
          string = string.replace(regexAsciiWhitelist, function(symbol) {
            if (useNamedReferences && has(encodeMap, symbol)) {
              return "&" + encodeMap[symbol] + ";";
            }
            return escapeBmpSymbol(symbol);
          });
          if (useNamedReferences) {
            string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;");
          }
          if (useNamedReferences) {
            string = string.replace(regexEncodeNonAscii, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
        } else if (useNamedReferences) {
          if (!allowUnsafeSymbols) {
            string = string.replace(regexEscape, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
          string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;");
          string = string.replace(regexEncodeNonAscii, function(string2) {
            return "&" + encodeMap[string2] + ";";
          });
        } else if (!allowUnsafeSymbols) {
          string = string.replace(regexEscape, escapeBmpSymbol);
        }
        return string.replace(regexAstralSymbols, function($0) {
          var high = $0.charCodeAt(0);
          var low = $0.charCodeAt(1);
          var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
          return escapeCodePoint(codePoint);
        }).replace(regexBmpWhitelist, escapeBmpSymbol);
      };
      encode2.options = {
        "allowUnsafeSymbols": false,
        "encodeEverything": false,
        "strict": false,
        "useNamedReferences": false,
        "decimal": false
      };
      var decode2 = function(html, options) {
        options = merge(options, decode2.options);
        var strict = options.strict;
        if (strict && regexInvalidEntity.test(html)) {
          parseError("malformed character reference");
        }
        return html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
          var codePoint;
          var semicolon;
          var decDigits;
          var hexDigits;
          var reference;
          var next;
          if ($1) {
            reference = $1;
            return decodeMap[reference];
          }
          if ($2) {
            reference = $2;
            next = $3;
            if (next && options.isAttributeValue) {
              if (strict && next == "=") {
                parseError("`&` did not start a character reference");
              }
              return $0;
            } else {
              if (strict) {
                parseError("named character reference was not terminated by a semicolon");
              }
              return decodeMapLegacy[reference] + (next || "");
            }
          }
          if ($4) {
            decDigits = $4;
            semicolon = $5;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(decDigits, 10);
            return codePointToSymbol(codePoint, strict);
          }
          if ($6) {
            hexDigits = $6;
            semicolon = $7;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(hexDigits, 16);
            return codePointToSymbol(codePoint, strict);
          }
          if (strict) {
            parseError("named character reference was not terminated by a semicolon");
          }
          return $0;
        });
      };
      decode2.options = {
        "isAttributeValue": false,
        "strict": false
      };
      var escape2 = function(string) {
        return string.replace(regexEscape, function($0) {
          return escapeMap[$0];
        });
      };
      var he = {
        "version": "1.2.0",
        "encode": encode2,
        "decode": decode2,
        "escape": escape2,
        "unescape": decode2
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define(function() {
          return he;
        });
      } else if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
          freeModule.exports = he;
        } else {
          for (var key2 in he) {
            has(he, key2) && (freeExports[key2] = he[key2]);
          }
        }
      } else {
        root.he = he;
      }
    })(exports);
  }
});

// node_modules/entities/lib/maps/decode.json
var require_decode = __commonJS({
  "node_modules/entities/lib/maps/decode.json"(exports, module2) {
    module2.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
  }
});

// node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS({
  "node_modules/entities/lib/decode_codepoint.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var decode_json_1 = __importDefault(require_decode());
    var fromCodePoint = String.fromCodePoint || function(codePoint) {
      var output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    };
    function decodeCodePoint(codePoint) {
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return "\uFFFD";
      }
      if (codePoint in decode_json_1.default) {
        codePoint = decode_json_1.default[codePoint];
      }
      return fromCodePoint(codePoint);
    }
    exports.default = decodeCodePoint;
  }
});

// node_modules/entities/lib/maps/entities.json
var require_entities = __commonJS({
  "node_modules/entities/lib/maps/entities.json"(exports, module2) {
    module2.exports = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", amp: "&", AMP: "&", andand: "\u2A55", And: "\u2A53", and: "\u2227", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angmsd: "\u2221", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", apacir: "\u2A6F", ap: "\u2248", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxHd: "\u2564", boxhD: "\u2565", boxHD: "\u2566", boxhu: "\u2534", boxHu: "\u2567", boxhU: "\u2568", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsolb: "\u29C5", bsol: "\\", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", cap: "\u2229", Cap: "\u22D2", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cir: "\u25CB", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cup: "\u222A", Cup: "\u22D3", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", Darr: "\u21A1", dArr: "\u21D3", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", ddagger: "\u2021", ddarr: "\u21CA", DD: "\u2145", dd: "\u2146", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrowBar: "\u2913", downarrow: "\u2193", DownArrow: "\u2193", Downarrow: "\u21D3", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVectorBar: "\u2956", DownLeftVector: "\u21BD", DownRightTeeVector: "\u295F", DownRightVectorBar: "\u2957", DownRightVector: "\u21C1", DownTeeArrow: "\u21A7", DownTee: "\u22A4", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", Ecirc: "\xCA", ecirc: "\xEA", ecir: "\u2256", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", edot: "\u0117", eDot: "\u2251", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", ge: "\u2265", gE: "\u2267", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", gescc: "\u2AA9", ges: "\u2A7E", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gla: "\u2AA5", gl: "\u2277", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gt: ">", GT: ">", Gt: "\u226B", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", harrcir: "\u2948", harr: "\u2194", hArr: "\u21D4", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\u210B", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", Im: "\u2111", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", incare: "\u2105", in: "\u2208", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", intcal: "\u22BA", int: "\u222B", Int: "\u222C", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larrb: "\u21E4", larrbfs: "\u291F", larr: "\u2190", Larr: "\u219E", lArr: "\u21D0", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", latail: "\u2919", lAtail: "\u291B", lat: "\u2AAB", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", LeftArrowBar: "\u21E4", leftarrow: "\u2190", LeftArrow: "\u2190", Leftarrow: "\u21D0", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVectorBar: "\u2959", LeftDownVector: "\u21C3", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTeeArrow: "\u21A4", LeftTee: "\u22A3", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangleBar: "\u29CF", LeftTriangle: "\u22B2", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVectorBar: "\u2958", LeftUpVector: "\u21BF", LeftVectorBar: "\u2952", LeftVector: "\u21BC", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", lescc: "\u2AA8", les: "\u2A7D", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", llarr: "\u21C7", ll: "\u226A", Ll: "\u22D8", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoustache: "\u23B0", lmoust: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftrightarrow: "\u27F7", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longmapsto: "\u27FC", longrightarrow: "\u27F6", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", lt: "<", LT: "<", Lt: "\u226A", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", midast: "*", midcir: "\u2AF0", mid: "\u2223", middot: "\xB7", minusb: "\u229F", minus: "\u2212", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natural: "\u266E", naturals: "\u2115", natur: "\u266E", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", ne: "\u2260", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangle: "\u22EB", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", nparallel: "\u2226", npar: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", nprec: "\u2280", npreceq: "\u2AAF\u0338", npre: "\u2AAF\u0338", nrarrc: "\u2933\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", Ocirc: "\xD4", ocirc: "\xF4", ocir: "\u229A", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", orarr: "\u21BB", Or: "\u2A54", or: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", otimesas: "\u2A36", Otimes: "\u2A37", otimes: "\u2297", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", para: "\xB6", parallel: "\u2225", par: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plus: "+", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", prap: "\u2AB7", Pr: "\u2ABB", pr: "\u227A", prcue: "\u227C", precapprox: "\u2AB7", prec: "\u227A", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", pre: "\u2AAF", prE: "\u2AB3", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportional: "\u221D", Proportion: "\u2237", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarr: "\u2192", Rarr: "\u21A0", rArr: "\u21D2", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", Re: "\u211C", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrowBar: "\u21E5", rightarrow: "\u2192", RightArrow: "\u2192", Rightarrow: "\u21D2", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVectorBar: "\u2955", RightDownVector: "\u21C2", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTeeArrow: "\u21A6", RightTee: "\u22A2", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangleBar: "\u29D0", RightTriangle: "\u22B3", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVectorBar: "\u2954", RightUpVector: "\u21BE", RightVectorBar: "\u2953", RightVector: "\u21C0", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoustache: "\u23B1", rmoust: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", Sc: "\u2ABC", sc: "\u227B", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdotb: "\u22A1", sdot: "\u22C5", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", solbar: "\u233F", solb: "\u29C4", sol: "/", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squ: "\u25A1", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succapprox: "\u2AB8", succ: "\u227B", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", Sup: "\u22D1", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", timesbar: "\u2A31", timesb: "\u22A0", times: "\xD7", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", topbot: "\u2336", topcir: "\u2AF1", top: "\u22A4", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", uarr: "\u2191", Uarr: "\u219F", uArr: "\u21D1", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrowBar: "\u2912", uparrow: "\u2191", UpArrow: "\u2191", Uparrow: "\u21D1", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", UpDownArrow: "\u2195", Updownarrow: "\u21D5", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTeeArrow: "\u21A5", UpTee: "\u22A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", veebar: "\u22BB", vee: "\u2228", Vee: "\u22C1", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xharr: "\u27F7", xhArr: "\u27FA", Xi: "\u039E", xi: "\u03BE", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", yuml: "\xFF", Yuml: "\u0178", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", zfr: "\u{1D537}", Zfr: "\u2128", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
  }
});

// node_modules/entities/lib/maps/legacy.json
var require_legacy = __commonJS({
  "node_modules/entities/lib/maps/legacy.json"(exports, module2) {
    module2.exports = { Aacute: "\xC1", aacute: "\xE1", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", AElig: "\xC6", aelig: "\xE6", Agrave: "\xC0", agrave: "\xE0", amp: "&", AMP: "&", Aring: "\xC5", aring: "\xE5", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", brvbar: "\xA6", Ccedil: "\xC7", ccedil: "\xE7", cedil: "\xB8", cent: "\xA2", copy: "\xA9", COPY: "\xA9", curren: "\xA4", deg: "\xB0", divide: "\xF7", Eacute: "\xC9", eacute: "\xE9", Ecirc: "\xCA", ecirc: "\xEA", Egrave: "\xC8", egrave: "\xE8", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", gt: ">", GT: ">", Iacute: "\xCD", iacute: "\xED", Icirc: "\xCE", icirc: "\xEE", iexcl: "\xA1", Igrave: "\xCC", igrave: "\xEC", iquest: "\xBF", Iuml: "\xCF", iuml: "\xEF", laquo: "\xAB", lt: "<", LT: "<", macr: "\xAF", micro: "\xB5", middot: "\xB7", nbsp: "\xA0", not: "\xAC", Ntilde: "\xD1", ntilde: "\xF1", Oacute: "\xD3", oacute: "\xF3", Ocirc: "\xD4", ocirc: "\xF4", Ograve: "\xD2", ograve: "\xF2", ordf: "\xAA", ordm: "\xBA", Oslash: "\xD8", oslash: "\xF8", Otilde: "\xD5", otilde: "\xF5", Ouml: "\xD6", ouml: "\xF6", para: "\xB6", plusmn: "\xB1", pound: "\xA3", quot: '"', QUOT: '"', raquo: "\xBB", reg: "\xAE", REG: "\xAE", sect: "\xA7", shy: "\xAD", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", szlig: "\xDF", THORN: "\xDE", thorn: "\xFE", times: "\xD7", Uacute: "\xDA", uacute: "\xFA", Ucirc: "\xDB", ucirc: "\xFB", Ugrave: "\xD9", ugrave: "\xF9", uml: "\xA8", Uuml: "\xDC", uuml: "\xFC", Yacute: "\xDD", yacute: "\xFD", yen: "\xA5", yuml: "\xFF" };
  }
});

// node_modules/entities/lib/maps/xml.json
var require_xml2 = __commonJS({
  "node_modules/entities/lib/maps/xml.json"(exports, module2) {
    module2.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
  }
});

// node_modules/htmlparser2/lib/Tokenizer.js
var require_Tokenizer = __commonJS({
  "node_modules/htmlparser2/lib/Tokenizer.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var decode_codepoint_1 = __importDefault(require_decode_codepoint());
    var entities_json_1 = __importDefault(require_entities());
    var legacy_json_1 = __importDefault(require_legacy());
    var xml_json_1 = __importDefault(require_xml2());
    function whitespace(c) {
      return c === " " || c === "\n" || c === "	" || c === "\f" || c === "\r";
    }
    function isASCIIAlpha(c) {
      return c >= "a" && c <= "z" || c >= "A" && c <= "Z";
    }
    function ifElseState(upper, SUCCESS, FAILURE) {
      var lower2 = upper.toLowerCase();
      if (upper === lower2) {
        return function(t2, c) {
          if (c === lower2) {
            t2._state = SUCCESS;
          } else {
            t2._state = FAILURE;
            t2._index--;
          }
        };
      }
      return function(t2, c) {
        if (c === lower2 || c === upper) {
          t2._state = SUCCESS;
        } else {
          t2._state = FAILURE;
          t2._index--;
        }
      };
    }
    function consumeSpecialNameChar(upper, NEXT_STATE) {
      var lower2 = upper.toLowerCase();
      return function(t2, c) {
        if (c === lower2 || c === upper) {
          t2._state = NEXT_STATE;
        } else {
          t2._state = 3;
          t2._index--;
        }
      };
    }
    var stateBeforeCdata1 = ifElseState("C", 24, 16);
    var stateBeforeCdata2 = ifElseState("D", 25, 16);
    var stateBeforeCdata3 = ifElseState("A", 26, 16);
    var stateBeforeCdata4 = ifElseState("T", 27, 16);
    var stateBeforeCdata5 = ifElseState("A", 28, 16);
    var stateBeforeScript1 = consumeSpecialNameChar("R", 35);
    var stateBeforeScript2 = consumeSpecialNameChar("I", 36);
    var stateBeforeScript3 = consumeSpecialNameChar("P", 37);
    var stateBeforeScript4 = consumeSpecialNameChar("T", 38);
    var stateAfterScript1 = ifElseState("R", 40, 1);
    var stateAfterScript2 = ifElseState("I", 41, 1);
    var stateAfterScript3 = ifElseState("P", 42, 1);
    var stateAfterScript4 = ifElseState("T", 43, 1);
    var stateBeforeStyle1 = consumeSpecialNameChar("Y", 45);
    var stateBeforeStyle2 = consumeSpecialNameChar("L", 46);
    var stateBeforeStyle3 = consumeSpecialNameChar("E", 47);
    var stateAfterStyle1 = ifElseState("Y", 49, 1);
    var stateAfterStyle2 = ifElseState("L", 50, 1);
    var stateAfterStyle3 = ifElseState("E", 51, 1);
    var stateBeforeSpecialT = consumeSpecialNameChar("I", 54);
    var stateBeforeTitle1 = consumeSpecialNameChar("T", 55);
    var stateBeforeTitle2 = consumeSpecialNameChar("L", 56);
    var stateBeforeTitle3 = consumeSpecialNameChar("E", 57);
    var stateAfterSpecialTEnd = ifElseState("I", 58, 1);
    var stateAfterTitle1 = ifElseState("T", 59, 1);
    var stateAfterTitle2 = ifElseState("L", 60, 1);
    var stateAfterTitle3 = ifElseState("E", 61, 1);
    var stateBeforeEntity = ifElseState("#", 63, 64);
    var stateBeforeNumericEntity = ifElseState("X", 66, 65);
    var Tokenizer = function() {
      function Tokenizer2(options, cbs) {
        var _a4;
        this._state = 1;
        this.buffer = "";
        this.sectionStart = 0;
        this._index = 0;
        this.bufferOffset = 0;
        this.baseState = 1;
        this.special = 1;
        this.running = true;
        this.ended = false;
        this.cbs = cbs;
        this.xmlMode = !!(options === null || options === void 0 ? void 0 : options.xmlMode);
        this.decodeEntities = (_a4 = options === null || options === void 0 ? void 0 : options.decodeEntities) !== null && _a4 !== void 0 ? _a4 : true;
      }
      Tokenizer2.prototype.reset = function() {
        this._state = 1;
        this.buffer = "";
        this.sectionStart = 0;
        this._index = 0;
        this.bufferOffset = 0;
        this.baseState = 1;
        this.special = 1;
        this.running = true;
        this.ended = false;
      };
      Tokenizer2.prototype.write = function(chunk) {
        if (this.ended)
          this.cbs.onerror(Error(".write() after done!"));
        this.buffer += chunk;
        this.parse();
      };
      Tokenizer2.prototype.end = function(chunk) {
        if (this.ended)
          this.cbs.onerror(Error(".end() after done!"));
        if (chunk)
          this.write(chunk);
        this.ended = true;
        if (this.running)
          this.finish();
      };
      Tokenizer2.prototype.pause = function() {
        this.running = false;
      };
      Tokenizer2.prototype.resume = function() {
        this.running = true;
        if (this._index < this.buffer.length) {
          this.parse();
        }
        if (this.ended) {
          this.finish();
        }
      };
      Tokenizer2.prototype.getAbsoluteIndex = function() {
        return this.bufferOffset + this._index;
      };
      Tokenizer2.prototype.stateText = function(c) {
        if (c === "<") {
          if (this._index > this.sectionStart) {
            this.cbs.ontext(this.getSection());
          }
          this._state = 2;
          this.sectionStart = this._index;
        } else if (this.decodeEntities && c === "&" && (this.special === 1 || this.special === 4)) {
          if (this._index > this.sectionStart) {
            this.cbs.ontext(this.getSection());
          }
          this.baseState = 1;
          this._state = 62;
          this.sectionStart = this._index;
        }
      };
      Tokenizer2.prototype.isTagStartChar = function(c) {
        return isASCIIAlpha(c) || this.xmlMode && !whitespace(c) && c !== "/" && c !== ">";
      };
      Tokenizer2.prototype.stateBeforeTagName = function(c) {
        if (c === "/") {
          this._state = 5;
        } else if (c === "<") {
          this.cbs.ontext(this.getSection());
          this.sectionStart = this._index;
        } else if (c === ">" || this.special !== 1 || whitespace(c)) {
          this._state = 1;
        } else if (c === "!") {
          this._state = 15;
          this.sectionStart = this._index + 1;
        } else if (c === "?") {
          this._state = 17;
          this.sectionStart = this._index + 1;
        } else if (!this.isTagStartChar(c)) {
          this._state = 1;
        } else {
          this._state = !this.xmlMode && (c === "s" || c === "S") ? 32 : !this.xmlMode && (c === "t" || c === "T") ? 52 : 3;
          this.sectionStart = this._index;
        }
      };
      Tokenizer2.prototype.stateInTagName = function(c) {
        if (c === "/" || c === ">" || whitespace(c)) {
          this.emitToken("onopentagname");
          this._state = 8;
          this._index--;
        }
      };
      Tokenizer2.prototype.stateBeforeClosingTagName = function(c) {
        if (whitespace(c)) {
        } else if (c === ">") {
          this._state = 1;
        } else if (this.special !== 1) {
          if (this.special !== 4 && (c === "s" || c === "S")) {
            this._state = 33;
          } else if (this.special === 4 && (c === "t" || c === "T")) {
            this._state = 53;
          } else {
            this._state = 1;
            this._index--;
          }
        } else if (!this.isTagStartChar(c)) {
          this._state = 20;
          this.sectionStart = this._index;
        } else {
          this._state = 6;
          this.sectionStart = this._index;
        }
      };
      Tokenizer2.prototype.stateInClosingTagName = function(c) {
        if (c === ">" || whitespace(c)) {
          this.emitToken("onclosetag");
          this._state = 7;
          this._index--;
        }
      };
      Tokenizer2.prototype.stateAfterClosingTagName = function(c) {
        if (c === ">") {
          this._state = 1;
          this.sectionStart = this._index + 1;
        }
      };
      Tokenizer2.prototype.stateBeforeAttributeName = function(c) {
        if (c === ">") {
          this.cbs.onopentagend();
          this._state = 1;
          this.sectionStart = this._index + 1;
        } else if (c === "/") {
          this._state = 4;
        } else if (!whitespace(c)) {
          this._state = 9;
          this.sectionStart = this._index;
        }
      };
      Tokenizer2.prototype.stateInSelfClosingTag = function(c) {
        if (c === ">") {
          this.cbs.onselfclosingtag();
          this._state = 1;
          this.sectionStart = this._index + 1;
          this.special = 1;
        } else if (!whitespace(c)) {
          this._state = 8;
          this._index--;
        }
      };
      Tokenizer2.prototype.stateInAttributeName = function(c) {
        if (c === "=" || c === "/" || c === ">" || whitespace(c)) {
          this.cbs.onattribname(this.getSection());
          this.sectionStart = -1;
          this._state = 10;
          this._index--;
        }
      };
      Tokenizer2.prototype.stateAfterAttributeName = function(c) {
        if (c === "=") {
          this._state = 11;
        } else if (c === "/" || c === ">") {
          this.cbs.onattribend(void 0);
          this._state = 8;
          this._index--;
        } else if (!whitespace(c)) {
          this.cbs.onattribend(void 0);
          this._state = 9;
          this.sectionStart = this._index;
        }
      };
      Tokenizer2.prototype.stateBeforeAttributeValue = function(c) {
        if (c === '"') {
          this._state = 12;
          this.sectionStart = this._index + 1;
        } else if (c === "'") {
          this._state = 13;
          this.sectionStart = this._index + 1;
        } else if (!whitespace(c)) {
          this._state = 14;
          this.sectionStart = this._index;
          this._index--;
        }
      };
      Tokenizer2.prototype.handleInAttributeValue = function(c, quote) {
        if (c === quote) {
          this.emitToken("onattribdata");
          this.cbs.onattribend(quote);
          this._state = 8;
        } else if (this.decodeEntities && c === "&") {
          this.emitToken("onattribdata");
          this.baseState = this._state;
          this._state = 62;
          this.sectionStart = this._index;
        }
      };
      Tokenizer2.prototype.stateInAttributeValueDoubleQuotes = function(c) {
        this.handleInAttributeValue(c, '"');
      };
      Tokenizer2.prototype.stateInAttributeValueSingleQuotes = function(c) {
        this.handleInAttributeValue(c, "'");
      };
      Tokenizer2.prototype.stateInAttributeValueNoQuotes = function(c) {
        if (whitespace(c) || c === ">") {
          this.emitToken("onattribdata");
          this.cbs.onattribend(null);
          this._state = 8;
          this._index--;
        } else if (this.decodeEntities && c === "&") {
          this.emitToken("onattribdata");
          this.baseState = this._state;
          this._state = 62;
          this.sectionStart = this._index;
        }
      };
      Tokenizer2.prototype.stateBeforeDeclaration = function(c) {
        this._state = c === "[" ? 23 : c === "-" ? 18 : 16;
      };
      Tokenizer2.prototype.stateInDeclaration = function(c) {
        if (c === ">") {
          this.cbs.ondeclaration(this.getSection());
          this._state = 1;
          this.sectionStart = this._index + 1;
        }
      };
      Tokenizer2.prototype.stateInProcessingInstruction = function(c) {
        if (c === ">") {
          this.cbs.onprocessinginstruction(this.getSection());
          this._state = 1;
          this.sectionStart = this._index + 1;
        }
      };
      Tokenizer2.prototype.stateBeforeComment = function(c) {
        if (c === "-") {
          this._state = 19;
          this.sectionStart = this._index + 1;
        } else {
          this._state = 16;
        }
      };
      Tokenizer2.prototype.stateInComment = function(c) {
        if (c === "-")
          this._state = 21;
      };
      Tokenizer2.prototype.stateInSpecialComment = function(c) {
        if (c === ">") {
          this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index));
          this._state = 1;
          this.sectionStart = this._index + 1;
        }
      };
      Tokenizer2.prototype.stateAfterComment1 = function(c) {
        if (c === "-") {
          this._state = 22;
        } else {
          this._state = 19;
        }
      };
      Tokenizer2.prototype.stateAfterComment2 = function(c) {
        if (c === ">") {
          this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index - 2));
          this._state = 1;
          this.sectionStart = this._index + 1;
        } else if (c !== "-") {
          this._state = 19;
        }
      };
      Tokenizer2.prototype.stateBeforeCdata6 = function(c) {
        if (c === "[") {
          this._state = 29;
          this.sectionStart = this._index + 1;
        } else {
          this._state = 16;
          this._index--;
        }
      };
      Tokenizer2.prototype.stateInCdata = function(c) {
        if (c === "]")
          this._state = 30;
      };
      Tokenizer2.prototype.stateAfterCdata1 = function(c) {
        if (c === "]")
          this._state = 31;
        else
          this._state = 29;
      };
      Tokenizer2.prototype.stateAfterCdata2 = function(c) {
        if (c === ">") {
          this.cbs.oncdata(this.buffer.substring(this.sectionStart, this._index - 2));
          this._state = 1;
          this.sectionStart = this._index + 1;
        } else if (c !== "]") {
          this._state = 29;
        }
      };
      Tokenizer2.prototype.stateBeforeSpecialS = function(c) {
        if (c === "c" || c === "C") {
          this._state = 34;
        } else if (c === "t" || c === "T") {
          this._state = 44;
        } else {
          this._state = 3;
          this._index--;
        }
      };
      Tokenizer2.prototype.stateBeforeSpecialSEnd = function(c) {
        if (this.special === 2 && (c === "c" || c === "C")) {
          this._state = 39;
        } else if (this.special === 3 && (c === "t" || c === "T")) {
          this._state = 48;
        } else
          this._state = 1;
      };
      Tokenizer2.prototype.stateBeforeSpecialLast = function(c, special) {
        if (c === "/" || c === ">" || whitespace(c)) {
          this.special = special;
        }
        this._state = 3;
        this._index--;
      };
      Tokenizer2.prototype.stateAfterSpecialLast = function(c, sectionStartOffset) {
        if (c === ">" || whitespace(c)) {
          this.special = 1;
          this._state = 6;
          this.sectionStart = this._index - sectionStartOffset;
          this._index--;
        } else
          this._state = 1;
      };
      Tokenizer2.prototype.parseFixedEntity = function(map) {
        if (map === void 0) {
          map = this.xmlMode ? xml_json_1.default : entities_json_1.default;
        }
        if (this.sectionStart + 1 < this._index) {
          var entity = this.buffer.substring(this.sectionStart + 1, this._index);
          if (Object.prototype.hasOwnProperty.call(map, entity)) {
            this.emitPartial(map[entity]);
            this.sectionStart = this._index + 1;
          }
        }
      };
      Tokenizer2.prototype.parseLegacyEntity = function() {
        var start = this.sectionStart + 1;
        var limit = Math.min(this._index - start, 6);
        while (limit >= 2) {
          var entity = this.buffer.substr(start, limit);
          if (Object.prototype.hasOwnProperty.call(legacy_json_1.default, entity)) {
            this.emitPartial(legacy_json_1.default[entity]);
            this.sectionStart += limit + 1;
            return;
          }
          limit--;
        }
      };
      Tokenizer2.prototype.stateInNamedEntity = function(c) {
        if (c === ";") {
          this.parseFixedEntity();
          if (this.baseState === 1 && this.sectionStart + 1 < this._index && !this.xmlMode) {
            this.parseLegacyEntity();
          }
          this._state = this.baseState;
        } else if ((c < "0" || c > "9") && !isASCIIAlpha(c)) {
          if (this.xmlMode || this.sectionStart + 1 === this._index) {
          } else if (this.baseState !== 1) {
            if (c !== "=") {
              this.parseFixedEntity(legacy_json_1.default);
            }
          } else {
            this.parseLegacyEntity();
          }
          this._state = this.baseState;
          this._index--;
        }
      };
      Tokenizer2.prototype.decodeNumericEntity = function(offset2, base2, strict) {
        var sectionStart = this.sectionStart + offset2;
        if (sectionStart !== this._index) {
          var entity = this.buffer.substring(sectionStart, this._index);
          var parsed = parseInt(entity, base2);
          this.emitPartial(decode_codepoint_1.default(parsed));
          this.sectionStart = strict ? this._index + 1 : this._index;
        }
        this._state = this.baseState;
      };
      Tokenizer2.prototype.stateInNumericEntity = function(c) {
        if (c === ";") {
          this.decodeNumericEntity(2, 10, true);
        } else if (c < "0" || c > "9") {
          if (!this.xmlMode) {
            this.decodeNumericEntity(2, 10, false);
          } else {
            this._state = this.baseState;
          }
          this._index--;
        }
      };
      Tokenizer2.prototype.stateInHexEntity = function(c) {
        if (c === ";") {
          this.decodeNumericEntity(3, 16, true);
        } else if ((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")) {
          if (!this.xmlMode) {
            this.decodeNumericEntity(3, 16, false);
          } else {
            this._state = this.baseState;
          }
          this._index--;
        }
      };
      Tokenizer2.prototype.cleanup = function() {
        if (this.sectionStart < 0) {
          this.buffer = "";
          this.bufferOffset += this._index;
          this._index = 0;
        } else if (this.running) {
          if (this._state === 1) {
            if (this.sectionStart !== this._index) {
              this.cbs.ontext(this.buffer.substr(this.sectionStart));
            }
            this.buffer = "";
            this.bufferOffset += this._index;
            this._index = 0;
          } else if (this.sectionStart === this._index) {
            this.buffer = "";
            this.bufferOffset += this._index;
            this._index = 0;
          } else {
            this.buffer = this.buffer.substr(this.sectionStart);
            this._index -= this.sectionStart;
            this.bufferOffset += this.sectionStart;
          }
          this.sectionStart = 0;
        }
      };
      Tokenizer2.prototype.parse = function() {
        while (this._index < this.buffer.length && this.running) {
          var c = this.buffer.charAt(this._index);
          if (this._state === 1) {
            this.stateText(c);
          } else if (this._state === 12) {
            this.stateInAttributeValueDoubleQuotes(c);
          } else if (this._state === 9) {
            this.stateInAttributeName(c);
          } else if (this._state === 19) {
            this.stateInComment(c);
          } else if (this._state === 20) {
            this.stateInSpecialComment(c);
          } else if (this._state === 8) {
            this.stateBeforeAttributeName(c);
          } else if (this._state === 3) {
            this.stateInTagName(c);
          } else if (this._state === 6) {
            this.stateInClosingTagName(c);
          } else if (this._state === 2) {
            this.stateBeforeTagName(c);
          } else if (this._state === 10) {
            this.stateAfterAttributeName(c);
          } else if (this._state === 13) {
            this.stateInAttributeValueSingleQuotes(c);
          } else if (this._state === 11) {
            this.stateBeforeAttributeValue(c);
          } else if (this._state === 5) {
            this.stateBeforeClosingTagName(c);
          } else if (this._state === 7) {
            this.stateAfterClosingTagName(c);
          } else if (this._state === 32) {
            this.stateBeforeSpecialS(c);
          } else if (this._state === 21) {
            this.stateAfterComment1(c);
          } else if (this._state === 14) {
            this.stateInAttributeValueNoQuotes(c);
          } else if (this._state === 4) {
            this.stateInSelfClosingTag(c);
          } else if (this._state === 16) {
            this.stateInDeclaration(c);
          } else if (this._state === 15) {
            this.stateBeforeDeclaration(c);
          } else if (this._state === 22) {
            this.stateAfterComment2(c);
          } else if (this._state === 18) {
            this.stateBeforeComment(c);
          } else if (this._state === 33) {
            this.stateBeforeSpecialSEnd(c);
          } else if (this._state === 53) {
            stateAfterSpecialTEnd(this, c);
          } else if (this._state === 39) {
            stateAfterScript1(this, c);
          } else if (this._state === 40) {
            stateAfterScript2(this, c);
          } else if (this._state === 41) {
            stateAfterScript3(this, c);
          } else if (this._state === 34) {
            stateBeforeScript1(this, c);
          } else if (this._state === 35) {
            stateBeforeScript2(this, c);
          } else if (this._state === 36) {
            stateBeforeScript3(this, c);
          } else if (this._state === 37) {
            stateBeforeScript4(this, c);
          } else if (this._state === 38) {
            this.stateBeforeSpecialLast(c, 2);
          } else if (this._state === 42) {
            stateAfterScript4(this, c);
          } else if (this._state === 43) {
            this.stateAfterSpecialLast(c, 6);
          } else if (this._state === 44) {
            stateBeforeStyle1(this, c);
          } else if (this._state === 29) {
            this.stateInCdata(c);
          } else if (this._state === 45) {
            stateBeforeStyle2(this, c);
          } else if (this._state === 46) {
            stateBeforeStyle3(this, c);
          } else if (this._state === 47) {
            this.stateBeforeSpecialLast(c, 3);
          } else if (this._state === 48) {
            stateAfterStyle1(this, c);
          } else if (this._state === 49) {
            stateAfterStyle2(this, c);
          } else if (this._state === 50) {
            stateAfterStyle3(this, c);
          } else if (this._state === 51) {
            this.stateAfterSpecialLast(c, 5);
          } else if (this._state === 52) {
            stateBeforeSpecialT(this, c);
          } else if (this._state === 54) {
            stateBeforeTitle1(this, c);
          } else if (this._state === 55) {
            stateBeforeTitle2(this, c);
          } else if (this._state === 56) {
            stateBeforeTitle3(this, c);
          } else if (this._state === 57) {
            this.stateBeforeSpecialLast(c, 4);
          } else if (this._state === 58) {
            stateAfterTitle1(this, c);
          } else if (this._state === 59) {
            stateAfterTitle2(this, c);
          } else if (this._state === 60) {
            stateAfterTitle3(this, c);
          } else if (this._state === 61) {
            this.stateAfterSpecialLast(c, 5);
          } else if (this._state === 17) {
            this.stateInProcessingInstruction(c);
          } else if (this._state === 64) {
            this.stateInNamedEntity(c);
          } else if (this._state === 23) {
            stateBeforeCdata1(this, c);
          } else if (this._state === 62) {
            stateBeforeEntity(this, c);
          } else if (this._state === 24) {
            stateBeforeCdata2(this, c);
          } else if (this._state === 25) {
            stateBeforeCdata3(this, c);
          } else if (this._state === 30) {
            this.stateAfterCdata1(c);
          } else if (this._state === 31) {
            this.stateAfterCdata2(c);
          } else if (this._state === 26) {
            stateBeforeCdata4(this, c);
          } else if (this._state === 27) {
            stateBeforeCdata5(this, c);
          } else if (this._state === 28) {
            this.stateBeforeCdata6(c);
          } else if (this._state === 66) {
            this.stateInHexEntity(c);
          } else if (this._state === 65) {
            this.stateInNumericEntity(c);
          } else if (this._state === 63) {
            stateBeforeNumericEntity(this, c);
          } else {
            this.cbs.onerror(Error("unknown _state"), this._state);
          }
          this._index++;
        }
        this.cleanup();
      };
      Tokenizer2.prototype.finish = function() {
        if (this.sectionStart < this._index) {
          this.handleTrailingData();
        }
        this.cbs.onend();
      };
      Tokenizer2.prototype.handleTrailingData = function() {
        var data = this.buffer.substr(this.sectionStart);
        if (this._state === 29 || this._state === 30 || this._state === 31) {
          this.cbs.oncdata(data);
        } else if (this._state === 19 || this._state === 21 || this._state === 22) {
          this.cbs.oncomment(data);
        } else if (this._state === 64 && !this.xmlMode) {
          this.parseLegacyEntity();
          if (this.sectionStart < this._index) {
            this._state = this.baseState;
            this.handleTrailingData();
          }
        } else if (this._state === 65 && !this.xmlMode) {
          this.decodeNumericEntity(2, 10, false);
          if (this.sectionStart < this._index) {
            this._state = this.baseState;
            this.handleTrailingData();
          }
        } else if (this._state === 66 && !this.xmlMode) {
          this.decodeNumericEntity(3, 16, false);
          if (this.sectionStart < this._index) {
            this._state = this.baseState;
            this.handleTrailingData();
          }
        } else if (this._state !== 3 && this._state !== 8 && this._state !== 11 && this._state !== 10 && this._state !== 9 && this._state !== 13 && this._state !== 12 && this._state !== 14 && this._state !== 6) {
          this.cbs.ontext(data);
        }
      };
      Tokenizer2.prototype.getSection = function() {
        return this.buffer.substring(this.sectionStart, this._index);
      };
      Tokenizer2.prototype.emitToken = function(name) {
        this.cbs[name](this.getSection());
        this.sectionStart = -1;
      };
      Tokenizer2.prototype.emitPartial = function(value) {
        if (this.baseState !== 1) {
          this.cbs.onattribdata(value);
        } else {
          this.cbs.ontext(value);
        }
      };
      return Tokenizer2;
    }();
    exports.default = Tokenizer;
  }
});

// node_modules/htmlparser2/lib/Parser.js
var require_Parser = __commonJS({
  "node_modules/htmlparser2/lib/Parser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Parser = void 0;
    var Tokenizer_1 = __importDefault(require_Tokenizer());
    var formTags = /* @__PURE__ */ new Set([
      "input",
      "option",
      "optgroup",
      "select",
      "button",
      "datalist",
      "textarea"
    ]);
    var pTag = /* @__PURE__ */ new Set(["p"]);
    var openImpliesClose = {
      tr: /* @__PURE__ */ new Set(["tr", "th", "td"]),
      th: /* @__PURE__ */ new Set(["th"]),
      td: /* @__PURE__ */ new Set(["thead", "th", "td"]),
      body: /* @__PURE__ */ new Set(["head", "link", "script"]),
      li: /* @__PURE__ */ new Set(["li"]),
      p: pTag,
      h1: pTag,
      h2: pTag,
      h3: pTag,
      h4: pTag,
      h5: pTag,
      h6: pTag,
      select: formTags,
      input: formTags,
      output: formTags,
      button: formTags,
      datalist: formTags,
      textarea: formTags,
      option: /* @__PURE__ */ new Set(["option"]),
      optgroup: /* @__PURE__ */ new Set(["optgroup", "option"]),
      dd: /* @__PURE__ */ new Set(["dt", "dd"]),
      dt: /* @__PURE__ */ new Set(["dt", "dd"]),
      address: pTag,
      article: pTag,
      aside: pTag,
      blockquote: pTag,
      details: pTag,
      div: pTag,
      dl: pTag,
      fieldset: pTag,
      figcaption: pTag,
      figure: pTag,
      footer: pTag,
      form: pTag,
      header: pTag,
      hr: pTag,
      main: pTag,
      nav: pTag,
      ol: pTag,
      pre: pTag,
      section: pTag,
      table: pTag,
      ul: pTag,
      rt: /* @__PURE__ */ new Set(["rt", "rp"]),
      rp: /* @__PURE__ */ new Set(["rt", "rp"]),
      tbody: /* @__PURE__ */ new Set(["thead", "tbody"]),
      tfoot: /* @__PURE__ */ new Set(["thead", "tbody"])
    };
    var voidElements = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
    var htmlIntegrationElements = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title"
    ]);
    var reNameEnd = /\s|\//;
    var Parser = function() {
      function Parser2(cbs, options) {
        if (options === void 0) {
          options = {};
        }
        var _a4, _b, _c, _d2, _e;
        this.startIndex = 0;
        this.endIndex = null;
        this.tagname = "";
        this.attribname = "";
        this.attribvalue = "";
        this.attribs = null;
        this.stack = [];
        this.foreignContext = [];
        this.options = options;
        this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
        this.lowerCaseTagNames = (_a4 = options.lowerCaseTags) !== null && _a4 !== void 0 ? _a4 : !options.xmlMode;
        this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
        this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_1.default)(this.options, this);
        (_e = (_d2 = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d2, this);
      }
      Parser2.prototype.updatePosition = function(initialOffset) {
        if (this.endIndex === null) {
          if (this.tokenizer.sectionStart <= initialOffset) {
            this.startIndex = 0;
          } else {
            this.startIndex = this.tokenizer.sectionStart - initialOffset;
          }
        } else {
          this.startIndex = this.endIndex + 1;
        }
        this.endIndex = this.tokenizer.getAbsoluteIndex();
      };
      Parser2.prototype.ontext = function(data) {
        var _a4, _b;
        this.updatePosition(1);
        this.endIndex--;
        (_b = (_a4 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a4, data);
      };
      Parser2.prototype.onopentagname = function(name) {
        var _a4, _b;
        if (this.lowerCaseTagNames) {
          name = name.toLowerCase();
        }
        this.tagname = name;
        if (!this.options.xmlMode && Object.prototype.hasOwnProperty.call(openImpliesClose, name)) {
          var el = void 0;
          while (this.stack.length > 0 && openImpliesClose[name].has(el = this.stack[this.stack.length - 1])) {
            this.onclosetag(el);
          }
        }
        if (this.options.xmlMode || !voidElements.has(name)) {
          this.stack.push(name);
          if (foreignContextElements.has(name)) {
            this.foreignContext.push(true);
          } else if (htmlIntegrationElements.has(name)) {
            this.foreignContext.push(false);
          }
        }
        (_b = (_a4 = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a4, name);
        if (this.cbs.onopentag)
          this.attribs = {};
      };
      Parser2.prototype.onopentagend = function() {
        var _a4, _b;
        this.updatePosition(1);
        if (this.attribs) {
          (_b = (_a4 = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a4, this.tagname, this.attribs);
          this.attribs = null;
        }
        if (!this.options.xmlMode && this.cbs.onclosetag && voidElements.has(this.tagname)) {
          this.cbs.onclosetag(this.tagname);
        }
        this.tagname = "";
      };
      Parser2.prototype.onclosetag = function(name) {
        this.updatePosition(1);
        if (this.lowerCaseTagNames) {
          name = name.toLowerCase();
        }
        if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
          this.foreignContext.pop();
        }
        if (this.stack.length && (this.options.xmlMode || !voidElements.has(name))) {
          var pos = this.stack.lastIndexOf(name);
          if (pos !== -1) {
            if (this.cbs.onclosetag) {
              pos = this.stack.length - pos;
              while (pos--) {
                this.cbs.onclosetag(this.stack.pop());
              }
            } else
              this.stack.length = pos;
          } else if (name === "p" && !this.options.xmlMode) {
            this.onopentagname(name);
            this.closeCurrentTag();
          }
        } else if (!this.options.xmlMode && (name === "br" || name === "p")) {
          this.onopentagname(name);
          this.closeCurrentTag();
        }
      };
      Parser2.prototype.onselfclosingtag = function() {
        if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
          this.closeCurrentTag();
        } else {
          this.onopentagend();
        }
      };
      Parser2.prototype.closeCurrentTag = function() {
        var _a4, _b;
        var name = this.tagname;
        this.onopentagend();
        if (this.stack[this.stack.length - 1] === name) {
          (_b = (_a4 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a4, name);
          this.stack.pop();
        }
      };
      Parser2.prototype.onattribname = function(name) {
        if (this.lowerCaseAttributeNames) {
          name = name.toLowerCase();
        }
        this.attribname = name;
      };
      Parser2.prototype.onattribdata = function(value) {
        this.attribvalue += value;
      };
      Parser2.prototype.onattribend = function(quote) {
        var _a4, _b;
        (_b = (_a4 = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a4, this.attribname, this.attribvalue, quote);
        if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
          this.attribs[this.attribname] = this.attribvalue;
        }
        this.attribname = "";
        this.attribvalue = "";
      };
      Parser2.prototype.getInstructionName = function(value) {
        var idx = value.search(reNameEnd);
        var name = idx < 0 ? value : value.substr(0, idx);
        if (this.lowerCaseTagNames) {
          name = name.toLowerCase();
        }
        return name;
      };
      Parser2.prototype.ondeclaration = function(value) {
        if (this.cbs.onprocessinginstruction) {
          var name_1 = this.getInstructionName(value);
          this.cbs.onprocessinginstruction("!" + name_1, "!" + value);
        }
      };
      Parser2.prototype.onprocessinginstruction = function(value) {
        if (this.cbs.onprocessinginstruction) {
          var name_2 = this.getInstructionName(value);
          this.cbs.onprocessinginstruction("?" + name_2, "?" + value);
        }
      };
      Parser2.prototype.oncomment = function(value) {
        var _a4, _b, _c, _d2;
        this.updatePosition(4);
        (_b = (_a4 = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a4, value);
        (_d2 = (_c = this.cbs).oncommentend) === null || _d2 === void 0 ? void 0 : _d2.call(_c);
      };
      Parser2.prototype.oncdata = function(value) {
        var _a4, _b, _c, _d2, _e, _f;
        this.updatePosition(1);
        if (this.options.xmlMode || this.options.recognizeCDATA) {
          (_b = (_a4 = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a4);
          (_d2 = (_c = this.cbs).ontext) === null || _d2 === void 0 ? void 0 : _d2.call(_c, value);
          (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
        } else {
          this.oncomment("[CDATA[" + value + "]]");
        }
      };
      Parser2.prototype.onerror = function(err) {
        var _a4, _b;
        (_b = (_a4 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a4, err);
      };
      Parser2.prototype.onend = function() {
        var _a4, _b;
        if (this.cbs.onclosetag) {
          for (var i2 = this.stack.length; i2 > 0; this.cbs.onclosetag(this.stack[--i2]))
            ;
        }
        (_b = (_a4 = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a4);
      };
      Parser2.prototype.reset = function() {
        var _a4, _b, _c, _d2;
        (_b = (_a4 = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a4);
        this.tokenizer.reset();
        this.tagname = "";
        this.attribname = "";
        this.attribs = null;
        this.stack = [];
        (_d2 = (_c = this.cbs).onparserinit) === null || _d2 === void 0 ? void 0 : _d2.call(_c, this);
      };
      Parser2.prototype.parseComplete = function(data) {
        this.reset();
        this.end(data);
      };
      Parser2.prototype.write = function(chunk) {
        this.tokenizer.write(chunk);
      };
      Parser2.prototype.end = function(chunk) {
        this.tokenizer.end(chunk);
      };
      Parser2.prototype.pause = function() {
        this.tokenizer.pause();
      };
      Parser2.prototype.resume = function() {
        this.tokenizer.resume();
      };
      Parser2.prototype.parseChunk = function(chunk) {
        this.write(chunk);
      };
      Parser2.prototype.done = function(chunk) {
        this.end(chunk);
      };
      return Parser2;
    }();
    exports.Parser = Parser;
  }
});

// node_modules/entities/lib/decode.js
var require_decode2 = __commonJS({
  "node_modules/entities/lib/decode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
    var entities_json_1 = __importDefault(require_entities());
    var legacy_json_1 = __importDefault(require_legacy());
    var xml_json_1 = __importDefault(require_xml2());
    var decode_codepoint_1 = __importDefault(require_decode_codepoint());
    var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
    exports.decodeXML = getStrictDecoder(xml_json_1.default);
    exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
    function getStrictDecoder(map) {
      var replace = getReplacer(map);
      return function(str) {
        return String(str).replace(strictEntityRe, replace);
      };
    }
    var sorter = function(a, b) {
      return a < b ? 1 : -1;
    };
    exports.decodeHTML = function() {
      var legacy = Object.keys(legacy_json_1.default).sort(sorter);
      var keys = Object.keys(entities_json_1.default).sort(sorter);
      for (var i2 = 0, j = 0; i2 < keys.length; i2++) {
        if (legacy[j] === keys[i2]) {
          keys[i2] += ";?";
          j++;
        } else {
          keys[i2] += ";";
        }
      }
      var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
      var replace = getReplacer(entities_json_1.default);
      function replacer(str) {
        if (str.substr(-1) !== ";")
          str += ";";
        return replace(str);
      }
      return function(str) {
        return String(str).replace(re, replacer);
      };
    }();
    function getReplacer(map) {
      return function replace(str) {
        if (str.charAt(1) === "#") {
          var secondChar = str.charAt(2);
          if (secondChar === "X" || secondChar === "x") {
            return decode_codepoint_1.default(parseInt(str.substr(3), 16));
          }
          return decode_codepoint_1.default(parseInt(str.substr(2), 10));
        }
        return map[str.slice(1, -1)] || str;
      };
    }
  }
});

// node_modules/entities/lib/encode.js
var require_encode = __commonJS({
  "node_modules/entities/lib/encode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;
    var xml_json_1 = __importDefault(require_xml2());
    var inverseXML = getInverseObj(xml_json_1.default);
    var xmlReplacer = getInverseReplacer(inverseXML);
    exports.encodeXML = getASCIIEncoder(inverseXML);
    var entities_json_1 = __importDefault(require_entities());
    var inverseHTML = getInverseObj(entities_json_1.default);
    var htmlReplacer = getInverseReplacer(inverseHTML);
    exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
    exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
    function getInverseObj(obj) {
      return Object.keys(obj).sort().reduce(function(inverse, name) {
        inverse[obj[name]] = "&" + name + ";";
        return inverse;
      }, {});
    }
    function getInverseReplacer(inverse) {
      var single = [];
      var multiple = [];
      for (var _i = 0, _a4 = Object.keys(inverse); _i < _a4.length; _i++) {
        var k = _a4[_i];
        if (k.length === 1) {
          single.push("\\" + k);
        } else {
          multiple.push(k);
        }
      }
      single.sort();
      for (var start = 0; start < single.length - 1; start++) {
        var end = start;
        while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
          end += 1;
        }
        var count = 1 + end - start;
        if (count < 3)
          continue;
        single.splice(start, count, single[start] + "-" + single[end]);
      }
      multiple.unshift("[" + single.join("") + "]");
      return new RegExp(multiple.join("|"), "g");
    }
    var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
    var getCodePoint = String.prototype.codePointAt != null ? function(str) {
      return str.codePointAt(0);
    } : function(c) {
      return (c.charCodeAt(0) - 55296) * 1024 + c.charCodeAt(1) - 56320 + 65536;
    };
    function singleCharReplacer(c) {
      return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0)).toString(16).toUpperCase() + ";";
    }
    function getInverse(inverse, re) {
      return function(data) {
        return data.replace(re, function(name) {
          return inverse[name];
        }).replace(reNonASCII, singleCharReplacer);
      };
    }
    var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
    function escape2(data) {
      return data.replace(reEscapeChars, singleCharReplacer);
    }
    exports.escape = escape2;
    function escapeUTF8(data) {
      return data.replace(xmlReplacer, singleCharReplacer);
    }
    exports.escapeUTF8 = escapeUTF8;
    function getASCIIEncoder(obj) {
      return function(data) {
        return data.replace(reEscapeChars, function(c) {
          return obj[c] || singleCharReplacer(c);
        });
      };
    }
  }
});

// node_modules/entities/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/entities/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
    var decode_1 = require_decode2();
    var encode_1 = require_encode();
    function decode2(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
    }
    exports.decode = decode2;
    function decodeStrict(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
    }
    exports.decodeStrict = decodeStrict;
    function encode2(data, level) {
      return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
    }
    exports.encode = encode2;
    var encode_2 = require_encode();
    Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
      return encode_2.encodeXML;
    } });
    Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function() {
      return encode_2.encodeNonAsciiHTML;
    } });
    Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
      return encode_2.escape;
    } });
    Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function() {
      return encode_2.escapeUTF8;
    } });
    Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    var decode_2 = require_decode2();
    Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
      return decode_2.decodeXML;
    } });
    Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
      return decode_2.decodeXML;
    } });
  }
});

// node_modules/dom-serializer/lib/foreignNames.js
var require_foreignNames = __commonJS({
  "node_modules/dom-serializer/lib/foreignNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attributeNames = exports.elementNames = void 0;
    exports.elementNames = /* @__PURE__ */ new Map([
      ["altglyph", "altGlyph"],
      ["altglyphdef", "altGlyphDef"],
      ["altglyphitem", "altGlyphItem"],
      ["animatecolor", "animateColor"],
      ["animatemotion", "animateMotion"],
      ["animatetransform", "animateTransform"],
      ["clippath", "clipPath"],
      ["feblend", "feBlend"],
      ["fecolormatrix", "feColorMatrix"],
      ["fecomponenttransfer", "feComponentTransfer"],
      ["fecomposite", "feComposite"],
      ["feconvolvematrix", "feConvolveMatrix"],
      ["fediffuselighting", "feDiffuseLighting"],
      ["fedisplacementmap", "feDisplacementMap"],
      ["fedistantlight", "feDistantLight"],
      ["fedropshadow", "feDropShadow"],
      ["feflood", "feFlood"],
      ["fefunca", "feFuncA"],
      ["fefuncb", "feFuncB"],
      ["fefuncg", "feFuncG"],
      ["fefuncr", "feFuncR"],
      ["fegaussianblur", "feGaussianBlur"],
      ["feimage", "feImage"],
      ["femerge", "feMerge"],
      ["femergenode", "feMergeNode"],
      ["femorphology", "feMorphology"],
      ["feoffset", "feOffset"],
      ["fepointlight", "fePointLight"],
      ["fespecularlighting", "feSpecularLighting"],
      ["fespotlight", "feSpotLight"],
      ["fetile", "feTile"],
      ["feturbulence", "feTurbulence"],
      ["foreignobject", "foreignObject"],
      ["glyphref", "glyphRef"],
      ["lineargradient", "linearGradient"],
      ["radialgradient", "radialGradient"],
      ["textpath", "textPath"]
    ]);
    exports.attributeNames = /* @__PURE__ */ new Map([
      ["definitionurl", "definitionURL"],
      ["attributename", "attributeName"],
      ["attributetype", "attributeType"],
      ["basefrequency", "baseFrequency"],
      ["baseprofile", "baseProfile"],
      ["calcmode", "calcMode"],
      ["clippathunits", "clipPathUnits"],
      ["diffuseconstant", "diffuseConstant"],
      ["edgemode", "edgeMode"],
      ["filterunits", "filterUnits"],
      ["glyphref", "glyphRef"],
      ["gradienttransform", "gradientTransform"],
      ["gradientunits", "gradientUnits"],
      ["kernelmatrix", "kernelMatrix"],
      ["kernelunitlength", "kernelUnitLength"],
      ["keypoints", "keyPoints"],
      ["keysplines", "keySplines"],
      ["keytimes", "keyTimes"],
      ["lengthadjust", "lengthAdjust"],
      ["limitingconeangle", "limitingConeAngle"],
      ["markerheight", "markerHeight"],
      ["markerunits", "markerUnits"],
      ["markerwidth", "markerWidth"],
      ["maskcontentunits", "maskContentUnits"],
      ["maskunits", "maskUnits"],
      ["numoctaves", "numOctaves"],
      ["pathlength", "pathLength"],
      ["patterncontentunits", "patternContentUnits"],
      ["patterntransform", "patternTransform"],
      ["patternunits", "patternUnits"],
      ["pointsatx", "pointsAtX"],
      ["pointsaty", "pointsAtY"],
      ["pointsatz", "pointsAtZ"],
      ["preservealpha", "preserveAlpha"],
      ["preserveaspectratio", "preserveAspectRatio"],
      ["primitiveunits", "primitiveUnits"],
      ["refx", "refX"],
      ["refy", "refY"],
      ["repeatcount", "repeatCount"],
      ["repeatdur", "repeatDur"],
      ["requiredextensions", "requiredExtensions"],
      ["requiredfeatures", "requiredFeatures"],
      ["specularconstant", "specularConstant"],
      ["specularexponent", "specularExponent"],
      ["spreadmethod", "spreadMethod"],
      ["startoffset", "startOffset"],
      ["stddeviation", "stdDeviation"],
      ["stitchtiles", "stitchTiles"],
      ["surfacescale", "surfaceScale"],
      ["systemlanguage", "systemLanguage"],
      ["tablevalues", "tableValues"],
      ["targetx", "targetX"],
      ["targety", "targetY"],
      ["textlength", "textLength"],
      ["viewbox", "viewBox"],
      ["viewtarget", "viewTarget"],
      ["xchannelselector", "xChannelSelector"],
      ["ychannelselector", "yChannelSelector"],
      ["zoomandpan", "zoomAndPan"]
    ]);
  }
});

// node_modules/dom-serializer/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/dom-serializer/lib/index.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s3, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s3 = arguments[i2];
          for (var p in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p))
              t2[p] = s3[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m2[k];
      } });
    } : function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ElementType = __importStar(require_lib2());
    var entities_1 = require_lib4();
    var foreignNames_1 = require_foreignNames();
    var unencodedElements = /* @__PURE__ */ new Set([
      "style",
      "script",
      "xmp",
      "iframe",
      "noembed",
      "noframes",
      "plaintext",
      "noscript"
    ]);
    function formatAttributes(attributes, opts) {
      if (!attributes)
        return;
      return Object.keys(attributes).map(function(key2) {
        var _a4, _b;
        var value = (_a4 = attributes[key2]) !== null && _a4 !== void 0 ? _a4 : "";
        if (opts.xmlMode === "foreign") {
          key2 = (_b = foreignNames_1.attributeNames.get(key2)) !== null && _b !== void 0 ? _b : key2;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
          return key2;
        }
        return key2 + '="' + (opts.decodeEntities !== false ? entities_1.encodeXML(value) : value.replace(/"/g, "&quot;")) + '"';
      }).join(" ");
    }
    var singleTag = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    function render(node, options) {
      if (options === void 0) {
        options = {};
      }
      var nodes = "length" in node ? node : [node];
      var output = "";
      for (var i2 = 0; i2 < nodes.length; i2++) {
        output += renderNode(nodes[i2], options);
      }
      return output;
    }
    exports.default = render;
    function renderNode(node, options) {
      switch (node.type) {
        case ElementType.Root:
          return render(node.children, options);
        case ElementType.Directive:
        case ElementType.Doctype:
          return renderDirective(node);
        case ElementType.Comment:
          return renderComment(node);
        case ElementType.CDATA:
          return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
          return renderTag(node, options);
        case ElementType.Text:
          return renderText(node, options);
      }
    }
    var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title"
    ]);
    var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
    function renderTag(elem, opts) {
      var _a4;
      if (opts.xmlMode === "foreign") {
        elem.name = (_a4 = foreignNames_1.elementNames.get(elem.name)) !== null && _a4 !== void 0 ? _a4 : elem.name;
        if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
          opts = __assign(__assign({}, opts), { xmlMode: false });
        }
      }
      if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
      }
      var tag = "<" + elem.name;
      var attribs = formatAttributes(elem.attribs, opts);
      if (attribs) {
        tag += " " + attribs;
      }
      if (elem.children.length === 0 && (opts.xmlMode ? opts.selfClosingTags !== false : opts.selfClosingTags && singleTag.has(elem.name))) {
        if (!opts.xmlMode)
          tag += " ";
        tag += "/>";
      } else {
        tag += ">";
        if (elem.children.length > 0) {
          tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
          tag += "</" + elem.name + ">";
        }
      }
      return tag;
    }
    function renderDirective(elem) {
      return "<" + elem.data + ">";
    }
    function renderText(elem, opts) {
      var data = elem.data || "";
      if (opts.decodeEntities !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
        data = entities_1.encodeXML(data);
      }
      return data;
    }
    function renderCdata(elem) {
      return "<![CDATA[" + elem.children[0].data + "]]>";
    }
    function renderComment(elem) {
      return "<!--" + elem.data + "-->";
    }
  }
});

// node_modules/domutils/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/domutils/lib/stringify.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;
    var domhandler_1 = require_lib3();
    var dom_serializer_1 = __importDefault(require_lib5());
    var domelementtype_1 = require_lib2();
    function getOuterHTML(node, options) {
      return (0, dom_serializer_1.default)(node, options);
    }
    exports.getOuterHTML = getOuterHTML;
    function getInnerHTML(node, options) {
      return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node2) {
        return getOuterHTML(node2, options);
      }).join("") : "";
    }
    exports.getInnerHTML = getInnerHTML;
    function getText(node) {
      if (Array.isArray(node))
        return node.map(getText).join("");
      if ((0, domhandler_1.isTag)(node))
        return node.name === "br" ? "\n" : getText(node.children);
      if ((0, domhandler_1.isCDATA)(node))
        return getText(node.children);
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.getText = getText;
    function textContent(node) {
      if (Array.isArray(node))
        return node.map(textContent).join("");
      if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
        return textContent(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.textContent = textContent;
    function innerText(node) {
      if (Array.isArray(node))
        return node.map(innerText).join("");
      if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
        return innerText(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.innerText = innerText;
  }
});

// node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS({
  "node_modules/domutils/lib/traversal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;
    var domhandler_1 = require_lib3();
    var emptyArray = [];
    function getChildren(elem) {
      var _a4;
      return (_a4 = elem.children) !== null && _a4 !== void 0 ? _a4 : emptyArray;
    }
    exports.getChildren = getChildren;
    function getParent(elem) {
      return elem.parent || null;
    }
    exports.getParent = getParent;
    function getSiblings(elem) {
      var _a4, _b;
      var parent = getParent(elem);
      if (parent != null)
        return getChildren(parent);
      var siblings = [elem];
      var prev = elem.prev, next = elem.next;
      while (prev != null) {
        siblings.unshift(prev);
        _a4 = prev, prev = _a4.prev;
      }
      while (next != null) {
        siblings.push(next);
        _b = next, next = _b.next;
      }
      return siblings;
    }
    exports.getSiblings = getSiblings;
    function getAttributeValue(elem, name) {
      var _a4;
      return (_a4 = elem.attribs) === null || _a4 === void 0 ? void 0 : _a4[name];
    }
    exports.getAttributeValue = getAttributeValue;
    function hasAttrib(elem, name) {
      return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
    }
    exports.hasAttrib = hasAttrib;
    function getName2(elem) {
      return elem.name;
    }
    exports.getName = getName2;
    function nextElementSibling(elem) {
      var _a4;
      var next = elem.next;
      while (next !== null && !(0, domhandler_1.isTag)(next))
        _a4 = next, next = _a4.next;
      return next;
    }
    exports.nextElementSibling = nextElementSibling;
    function prevElementSibling(elem) {
      var _a4;
      var prev = elem.prev;
      while (prev !== null && !(0, domhandler_1.isTag)(prev))
        _a4 = prev, prev = _a4.prev;
      return prev;
    }
    exports.prevElementSibling = prevElementSibling;
  }
});

// node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS({
  "node_modules/domutils/lib/manipulation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;
    function removeElement(elem) {
      if (elem.prev)
        elem.prev.next = elem.next;
      if (elem.next)
        elem.next.prev = elem.prev;
      if (elem.parent) {
        var childs = elem.parent.children;
        childs.splice(childs.lastIndexOf(elem), 1);
      }
    }
    exports.removeElement = removeElement;
    function replaceElement(elem, replacement) {
      var prev = replacement.prev = elem.prev;
      if (prev) {
        prev.next = replacement;
      }
      var next = replacement.next = elem.next;
      if (next) {
        next.prev = replacement;
      }
      var parent = replacement.parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
      }
    }
    exports.replaceElement = replaceElement;
    function appendChild(elem, child) {
      removeElement(child);
      child.next = null;
      child.parent = elem;
      if (elem.children.push(child) > 1) {
        var sibling = elem.children[elem.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
      } else {
        child.prev = null;
      }
    }
    exports.appendChild = appendChild;
    function append(elem, next) {
      removeElement(next);
      var parent = elem.parent;
      var currNext = elem.next;
      next.next = currNext;
      next.prev = elem;
      elem.next = next;
      next.parent = parent;
      if (currNext) {
        currNext.prev = next;
        if (parent) {
          var childs = parent.children;
          childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
      } else if (parent) {
        parent.children.push(next);
      }
    }
    exports.append = append;
    function prependChild(elem, child) {
      removeElement(child);
      child.parent = elem;
      child.prev = null;
      if (elem.children.unshift(child) !== 1) {
        var sibling = elem.children[1];
        sibling.prev = child;
        child.next = sibling;
      } else {
        child.next = null;
      }
    }
    exports.prependChild = prependChild;
    function prepend(elem, prev) {
      removeElement(prev);
      var parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
      }
      if (elem.prev) {
        elem.prev.next = prev;
      }
      prev.parent = parent;
      prev.prev = elem.prev;
      prev.next = elem;
      elem.prev = prev;
    }
    exports.prepend = prepend;
  }
});

// node_modules/domutils/lib/querying.js
var require_querying = __commonJS({
  "node_modules/domutils/lib/querying.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;
    var domhandler_1 = require_lib3();
    function filter(test, node, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      if (!Array.isArray(node))
        node = [node];
      return find(test, node, recurse, limit);
    }
    exports.filter = filter;
    function find(test, nodes, recurse, limit) {
      var result = [];
      for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var elem = nodes_1[_i];
        if (test(elem)) {
          result.push(elem);
          if (--limit <= 0)
            break;
        }
        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
          var children = find(test, elem.children, recurse, limit);
          result.push.apply(result, children);
          limit -= children.length;
          if (limit <= 0)
            break;
        }
      }
      return result;
    }
    exports.find = find;
    function findOneChild(test, nodes) {
      return nodes.find(test);
    }
    exports.findOneChild = findOneChild;
    function findOne(test, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      var elem = null;
      for (var i2 = 0; i2 < nodes.length && !elem; i2++) {
        var checked = nodes[i2];
        if (!(0, domhandler_1.isTag)(checked)) {
          continue;
        } else if (test(checked)) {
          elem = checked;
        } else if (recurse && checked.children.length > 0) {
          elem = findOne(test, checked.children);
        }
      }
      return elem;
    }
    exports.findOne = findOne;
    function existsOne(test, nodes) {
      return nodes.some(function(checked) {
        return (0, domhandler_1.isTag)(checked) && (test(checked) || checked.children.length > 0 && existsOne(test, checked.children));
      });
    }
    exports.existsOne = existsOne;
    function findAll(test, nodes) {
      var _a4;
      var result = [];
      var stack = nodes.filter(domhandler_1.isTag);
      var elem;
      while (elem = stack.shift()) {
        var children = (_a4 = elem.children) === null || _a4 === void 0 ? void 0 : _a4.filter(domhandler_1.isTag);
        if (children && children.length > 0) {
          stack.unshift.apply(stack, children);
        }
        if (test(elem))
          result.push(elem);
      }
      return result;
    }
    exports.findAll = findAll;
  }
});

// node_modules/domutils/lib/legacy.js
var require_legacy2 = __commonJS({
  "node_modules/domutils/lib/legacy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;
    var domhandler_1 = require_lib3();
    var querying_1 = require_querying();
    var Checks = {
      tag_name: function(name) {
        if (typeof name === "function") {
          return function(elem) {
            return (0, domhandler_1.isTag)(elem) && name(elem.name);
          };
        } else if (name === "*") {
          return domhandler_1.isTag;
        }
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && elem.name === name;
        };
      },
      tag_type: function(type) {
        if (typeof type === "function") {
          return function(elem) {
            return type(elem.type);
          };
        }
        return function(elem) {
          return elem.type === type;
        };
      },
      tag_contains: function(data) {
        if (typeof data === "function") {
          return function(elem) {
            return (0, domhandler_1.isText)(elem) && data(elem.data);
          };
        }
        return function(elem) {
          return (0, domhandler_1.isText)(elem) && elem.data === data;
        };
      }
    };
    function getAttribCheck(attrib, value) {
      if (typeof value === "function") {
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
        };
      }
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
      };
    }
    function combineFuncs(a, b) {
      return function(elem) {
        return a(elem) || b(elem);
      };
    }
    function compileTest(options) {
      var funcs = Object.keys(options).map(function(key2) {
        var value = options[key2];
        return Object.prototype.hasOwnProperty.call(Checks, key2) ? Checks[key2](value) : getAttribCheck(key2, value);
      });
      return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
    }
    function testElement(options, node) {
      var test = compileTest(options);
      return test ? test(node) : true;
    }
    exports.testElement = testElement;
    function getElements(options, nodes, recurse, limit) {
      if (limit === void 0) {
        limit = Infinity;
      }
      var test = compileTest(options);
      return test ? (0, querying_1.filter)(test, nodes, recurse, limit) : [];
    }
    exports.getElements = getElements;
    function getElementById(id, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (!Array.isArray(nodes))
        nodes = [nodes];
      return (0, querying_1.findOne)(getAttribCheck("id", id), nodes, recurse);
    }
    exports.getElementById = getElementById;
    function getElementsByTagName(tagName, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_1.filter)(Checks.tag_name(tagName), nodes, recurse, limit);
    }
    exports.getElementsByTagName = getElementsByTagName;
    function getElementsByTagType(type, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_1.filter)(Checks.tag_type(type), nodes, recurse, limit);
    }
    exports.getElementsByTagType = getElementsByTagType;
  }
});

// node_modules/domutils/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/domutils/lib/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uniqueSort = exports.compareDocumentPosition = exports.removeSubsets = void 0;
    var domhandler_1 = require_lib3();
    function removeSubsets(nodes) {
      var idx = nodes.length;
      while (--idx >= 0) {
        var node = nodes[idx];
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
          nodes.splice(idx, 1);
          continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
          if (nodes.includes(ancestor)) {
            nodes.splice(idx, 1);
            break;
          }
        }
      }
      return nodes;
    }
    exports.removeSubsets = removeSubsets;
    function compareDocumentPosition(nodeA, nodeB) {
      var aParents = [];
      var bParents = [];
      if (nodeA === nodeB) {
        return 0;
      }
      var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
      while (current) {
        aParents.unshift(current);
        current = current.parent;
      }
      current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
      while (current) {
        bParents.unshift(current);
        current = current.parent;
      }
      var maxIdx = Math.min(aParents.length, bParents.length);
      var idx = 0;
      while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
      }
      if (idx === 0) {
        return 1;
      }
      var sharedParent = aParents[idx - 1];
      var siblings = sharedParent.children;
      var aSibling = aParents[idx];
      var bSibling = bParents[idx];
      if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
          return 4 | 16;
        }
        return 4;
      }
      if (sharedParent === nodeA) {
        return 2 | 8;
      }
      return 2;
    }
    exports.compareDocumentPosition = compareDocumentPosition;
    function uniqueSort(nodes) {
      nodes = nodes.filter(function(node, i2, arr) {
        return !arr.includes(node, i2 + 1);
      });
      nodes.sort(function(a, b) {
        var relative = compareDocumentPosition(a, b);
        if (relative & 2) {
          return -1;
        } else if (relative & 4) {
          return 1;
        }
        return 0;
      });
      return nodes;
    }
    exports.uniqueSort = uniqueSort;
  }
});

// node_modules/domutils/lib/feeds.js
var require_feeds = __commonJS({
  "node_modules/domutils/lib/feeds.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFeed = void 0;
    var stringify_1 = require_stringify();
    var legacy_1 = require_legacy2();
    function getFeed(doc) {
      var feedRoot = getOneElement(isValidFeed, doc);
      return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
    }
    exports.getFeed = getFeed;
    function getAtomFeed(feedRoot) {
      var _a4;
      var childs = feedRoot.children;
      var feed = {
        type: "atom",
        items: (0, legacy_1.getElementsByTagName)("entry", childs).map(function(item) {
          var _a5;
          var children = item.children;
          var entry11 = { media: getMediaElements(children) };
          addConditionally(entry11, "id", "id", children);
          addConditionally(entry11, "title", "title", children);
          var href2 = (_a5 = getOneElement("link", children)) === null || _a5 === void 0 ? void 0 : _a5.attribs.href;
          if (href2) {
            entry11.link = href2;
          }
          var description = fetch3("summary", children) || fetch3("content", children);
          if (description) {
            entry11.description = description;
          }
          var pubDate = fetch3("updated", children);
          if (pubDate) {
            entry11.pubDate = new Date(pubDate);
          }
          return entry11;
        })
      };
      addConditionally(feed, "id", "id", childs);
      addConditionally(feed, "title", "title", childs);
      var href = (_a4 = getOneElement("link", childs)) === null || _a4 === void 0 ? void 0 : _a4.attribs.href;
      if (href) {
        feed.link = href;
      }
      addConditionally(feed, "description", "subtitle", childs);
      var updated2 = fetch3("updated", childs);
      if (updated2) {
        feed.updated = new Date(updated2);
      }
      addConditionally(feed, "author", "email", childs, true);
      return feed;
    }
    function getRssFeed(feedRoot) {
      var _a4, _b;
      var childs = (_b = (_a4 = getOneElement("channel", feedRoot.children)) === null || _a4 === void 0 ? void 0 : _a4.children) !== null && _b !== void 0 ? _b : [];
      var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
          var children = item.children;
          var entry11 = { media: getMediaElements(children) };
          addConditionally(entry11, "id", "guid", children);
          addConditionally(entry11, "title", "title", children);
          addConditionally(entry11, "link", "link", children);
          addConditionally(entry11, "description", "description", children);
          var pubDate = fetch3("pubDate", children);
          if (pubDate)
            entry11.pubDate = new Date(pubDate);
          return entry11;
        })
      };
      addConditionally(feed, "title", "title", childs);
      addConditionally(feed, "link", "link", childs);
      addConditionally(feed, "description", "description", childs);
      var updated2 = fetch3("lastBuildDate", childs);
      if (updated2) {
        feed.updated = new Date(updated2);
      }
      addConditionally(feed, "author", "managingEditor", childs, true);
      return feed;
    }
    var MEDIA_KEYS_STRING = ["url", "type", "lang"];
    var MEDIA_KEYS_INT = [
      "fileSize",
      "bitrate",
      "framerate",
      "samplingrate",
      "channels",
      "duration",
      "height",
      "width"
    ];
    function getMediaElements(where) {
      return (0, legacy_1.getElementsByTagName)("media:content", where).map(function(elem) {
        var attribs = elem.attribs;
        var media = {
          medium: attribs.medium,
          isDefault: !!attribs.isDefault
        };
        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
          var attrib = MEDIA_KEYS_STRING_1[_i];
          if (attribs[attrib]) {
            media[attrib] = attribs[attrib];
          }
        }
        for (var _a4 = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a4 < MEDIA_KEYS_INT_1.length; _a4++) {
          var attrib = MEDIA_KEYS_INT_1[_a4];
          if (attribs[attrib]) {
            media[attrib] = parseInt(attribs[attrib], 10);
          }
        }
        if (attribs.expression) {
          media.expression = attribs.expression;
        }
        return media;
      });
    }
    function getOneElement(tagName, node) {
      return (0, legacy_1.getElementsByTagName)(tagName, node, true, 1)[0];
    }
    function fetch3(tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      return (0, stringify_1.textContent)((0, legacy_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
    }
    function addConditionally(obj, prop, tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      var val = fetch3(tagName, where, recurse);
      if (val)
        obj[prop] = val;
    }
    function isValidFeed(value) {
      return value === "rss" || value === "feed" || value === "rdf:RDF";
    }
  }
});

// node_modules/domutils/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/domutils/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m2[k];
      } });
    } : function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m2[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p in m2)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m2, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
    __exportStar(require_stringify(), exports);
    __exportStar(require_traversal(), exports);
    __exportStar(require_manipulation(), exports);
    __exportStar(require_querying(), exports);
    __exportStar(require_legacy2(), exports);
    __exportStar(require_helpers(), exports);
    __exportStar(require_feeds(), exports);
    var domhandler_1 = require_lib3();
    Object.defineProperty(exports, "isTag", { enumerable: true, get: function() {
      return domhandler_1.isTag;
    } });
    Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function() {
      return domhandler_1.isCDATA;
    } });
    Object.defineProperty(exports, "isText", { enumerable: true, get: function() {
      return domhandler_1.isText;
    } });
    Object.defineProperty(exports, "isComment", { enumerable: true, get: function() {
      return domhandler_1.isComment;
    } });
    Object.defineProperty(exports, "isDocument", { enumerable: true, get: function() {
      return domhandler_1.isDocument;
    } });
    Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function() {
      return domhandler_1.hasChildren;
    } });
  }
});

// node_modules/htmlparser2/lib/FeedHandler.js
var require_FeedHandler = __commonJS({
  "node_modules/htmlparser2/lib/FeedHandler.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m2[k];
      } });
    } : function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseFeed = exports.FeedHandler = void 0;
    var domhandler_1 = __importDefault(require_lib3());
    var DomUtils = __importStar(require_lib6());
    var Parser_1 = require_Parser();
    var FeedItemMediaMedium;
    (function(FeedItemMediaMedium2) {
      FeedItemMediaMedium2[FeedItemMediaMedium2["image"] = 0] = "image";
      FeedItemMediaMedium2[FeedItemMediaMedium2["audio"] = 1] = "audio";
      FeedItemMediaMedium2[FeedItemMediaMedium2["video"] = 2] = "video";
      FeedItemMediaMedium2[FeedItemMediaMedium2["document"] = 3] = "document";
      FeedItemMediaMedium2[FeedItemMediaMedium2["executable"] = 4] = "executable";
    })(FeedItemMediaMedium || (FeedItemMediaMedium = {}));
    var FeedItemMediaExpression;
    (function(FeedItemMediaExpression2) {
      FeedItemMediaExpression2[FeedItemMediaExpression2["sample"] = 0] = "sample";
      FeedItemMediaExpression2[FeedItemMediaExpression2["full"] = 1] = "full";
      FeedItemMediaExpression2[FeedItemMediaExpression2["nonstop"] = 2] = "nonstop";
    })(FeedItemMediaExpression || (FeedItemMediaExpression = {}));
    var FeedHandler = function(_super) {
      __extends(FeedHandler2, _super);
      function FeedHandler2(callback, options) {
        var _this = this;
        if (typeof callback === "object") {
          callback = void 0;
          options = callback;
        }
        _this = _super.call(this, callback, options) || this;
        return _this;
      }
      FeedHandler2.prototype.onend = function() {
        var _a4, _b;
        var feedRoot = getOneElement(isValidFeed, this.dom);
        if (!feedRoot) {
          this.handleCallback(new Error("couldn't find root of feed"));
          return;
        }
        var feed = {};
        if (feedRoot.name === "feed") {
          var childs = feedRoot.children;
          feed.type = "atom";
          addConditionally(feed, "id", "id", childs);
          addConditionally(feed, "title", "title", childs);
          var href = getAttribute("href", getOneElement("link", childs));
          if (href) {
            feed.link = href;
          }
          addConditionally(feed, "description", "subtitle", childs);
          var updated2 = fetch3("updated", childs);
          if (updated2) {
            feed.updated = new Date(updated2);
          }
          addConditionally(feed, "author", "email", childs, true);
          feed.items = getElements("entry", childs).map(function(item) {
            var entry11 = {};
            var children = item.children;
            addConditionally(entry11, "id", "id", children);
            addConditionally(entry11, "title", "title", children);
            var href2 = getAttribute("href", getOneElement("link", children));
            if (href2) {
              entry11.link = href2;
            }
            var description = fetch3("summary", children) || fetch3("content", children);
            if (description) {
              entry11.description = description;
            }
            var pubDate = fetch3("updated", children);
            if (pubDate) {
              entry11.pubDate = new Date(pubDate);
            }
            entry11.media = getMediaElements(children);
            return entry11;
          });
        } else {
          var childs = (_b = (_a4 = getOneElement("channel", feedRoot.children)) === null || _a4 === void 0 ? void 0 : _a4.children) !== null && _b !== void 0 ? _b : [];
          feed.type = feedRoot.name.substr(0, 3);
          feed.id = "";
          addConditionally(feed, "title", "title", childs);
          addConditionally(feed, "link", "link", childs);
          addConditionally(feed, "description", "description", childs);
          var updated2 = fetch3("lastBuildDate", childs);
          if (updated2) {
            feed.updated = new Date(updated2);
          }
          addConditionally(feed, "author", "managingEditor", childs, true);
          feed.items = getElements("item", feedRoot.children).map(function(item) {
            var entry11 = {};
            var children = item.children;
            addConditionally(entry11, "id", "guid", children);
            addConditionally(entry11, "title", "title", children);
            addConditionally(entry11, "link", "link", children);
            addConditionally(entry11, "description", "description", children);
            var pubDate = fetch3("pubDate", children);
            if (pubDate)
              entry11.pubDate = new Date(pubDate);
            entry11.media = getMediaElements(children);
            return entry11;
          });
        }
        this.feed = feed;
        this.handleCallback(null);
      };
      return FeedHandler2;
    }(domhandler_1.default);
    exports.FeedHandler = FeedHandler;
    function getMediaElements(where) {
      return getElements("media:content", where).map(function(elem) {
        var media = {
          medium: elem.attribs.medium,
          isDefault: !!elem.attribs.isDefault
        };
        if (elem.attribs.url) {
          media.url = elem.attribs.url;
        }
        if (elem.attribs.fileSize) {
          media.fileSize = parseInt(elem.attribs.fileSize, 10);
        }
        if (elem.attribs.type) {
          media.type = elem.attribs.type;
        }
        if (elem.attribs.expression) {
          media.expression = elem.attribs.expression;
        }
        if (elem.attribs.bitrate) {
          media.bitrate = parseInt(elem.attribs.bitrate, 10);
        }
        if (elem.attribs.framerate) {
          media.framerate = parseInt(elem.attribs.framerate, 10);
        }
        if (elem.attribs.samplingrate) {
          media.samplingrate = parseInt(elem.attribs.samplingrate, 10);
        }
        if (elem.attribs.channels) {
          media.channels = parseInt(elem.attribs.channels, 10);
        }
        if (elem.attribs.duration) {
          media.duration = parseInt(elem.attribs.duration, 10);
        }
        if (elem.attribs.height) {
          media.height = parseInt(elem.attribs.height, 10);
        }
        if (elem.attribs.width) {
          media.width = parseInt(elem.attribs.width, 10);
        }
        if (elem.attribs.lang) {
          media.lang = elem.attribs.lang;
        }
        return media;
      });
    }
    function getElements(tagName, where) {
      return DomUtils.getElementsByTagName(tagName, where, true);
    }
    function getOneElement(tagName, node) {
      return DomUtils.getElementsByTagName(tagName, node, true, 1)[0];
    }
    function fetch3(tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      return DomUtils.getText(DomUtils.getElementsByTagName(tagName, where, recurse, 1)).trim();
    }
    function getAttribute(name, elem) {
      if (!elem) {
        return null;
      }
      var attribs = elem.attribs;
      return attribs[name];
    }
    function addConditionally(obj, prop, what, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      var tmp = fetch3(what, where, recurse);
      if (tmp)
        obj[prop] = tmp;
    }
    function isValidFeed(value) {
      return value === "rss" || value === "feed" || value === "rdf:RDF";
    }
    function parseFeed(feed, options) {
      if (options === void 0) {
        options = { xmlMode: true };
      }
      var handler = new FeedHandler(options);
      new Parser_1.Parser(handler, options).end(feed);
      return handler.feed;
    }
    exports.parseFeed = parseFeed;
  }
});

// node_modules/htmlparser2/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/htmlparser2/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m2[k];
      } });
    } : function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p in m2)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m2, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RssHandler = exports.DefaultHandler = exports.DomUtils = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.parseDOM = exports.parseDocument = exports.DomHandler = exports.Parser = void 0;
    var Parser_1 = require_Parser();
    Object.defineProperty(exports, "Parser", { enumerable: true, get: function() {
      return Parser_1.Parser;
    } });
    var domhandler_1 = require_lib3();
    Object.defineProperty(exports, "DomHandler", { enumerable: true, get: function() {
      return domhandler_1.DomHandler;
    } });
    Object.defineProperty(exports, "DefaultHandler", { enumerable: true, get: function() {
      return domhandler_1.DomHandler;
    } });
    function parseDocument(data, options) {
      var handler = new domhandler_1.DomHandler(void 0, options);
      new Parser_1.Parser(handler, options).end(data);
      return handler.root;
    }
    exports.parseDocument = parseDocument;
    function parseDOM(data, options) {
      return parseDocument(data, options).children;
    }
    exports.parseDOM = parseDOM;
    function createDomStream(cb, options, elementCb) {
      var handler = new domhandler_1.DomHandler(cb, options, elementCb);
      return new Parser_1.Parser(handler, options);
    }
    exports.createDomStream = createDomStream;
    var Tokenizer_1 = require_Tokenizer();
    Object.defineProperty(exports, "Tokenizer", { enumerable: true, get: function() {
      return __importDefault(Tokenizer_1).default;
    } });
    var ElementType = __importStar(require_lib2());
    exports.ElementType = ElementType;
    __exportStar(require_FeedHandler(), exports);
    exports.DomUtils = __importStar(require_lib6());
    var FeedHandler_1 = require_FeedHandler();
    Object.defineProperty(exports, "RssHandler", { enumerable: true, get: function() {
      return FeedHandler_1.FeedHandler;
    } });
  }
});

// node_modules/html-to-text/lib/helper.js
var require_helper = __commonJS({
  "node_modules/html-to-text/lib/helper.js"(exports, module2) {
    var merge = require_cjs();
    function splitClassesAndIds(selectors) {
      const classes = [];
      const ids = [];
      for (const selector of selectors) {
        if (selector.startsWith(".")) {
          classes.push(selector.substring(1));
        } else if (selector.startsWith("#")) {
          ids.push(selector.substring(1));
        }
      }
      return { classes, ids };
    }
    function limitedDepthRecursive(n, f3, g = () => void 0) {
      if (n === void 0) {
        const f1 = function(...args) {
          return f3(f1, ...args);
        };
        return f1;
      }
      if (n >= 0) {
        return function(...args) {
          return f3(limitedDepthRecursive(n - 1, f3, g), ...args);
        };
      }
      return g;
    }
    function numberToLetterSequence(num, baseChar = "a", base2 = 26) {
      const digits = [];
      do {
        num -= 1;
        digits.push(num % base2);
        num = num / base2 >> 0;
      } while (num > 0);
      const baseCode = baseChar.charCodeAt(0);
      return digits.reverse().map((n) => String.fromCharCode(baseCode + n)).join("");
    }
    var I = ["I", "X", "C", "M"];
    var V = ["V", "L", "D"];
    function numberToRoman(num) {
      return [...num + ""].map((n) => +n).reverse().map((v, i2) => v % 5 < 4 ? (v < 5 ? "" : V[i2]) + I[i2].repeat(v % 5) : I[i2] + (v < 5 ? V[i2] : I[i2 + 1])).reverse().join("");
    }
    function trimCharacter(str, char) {
      let start = 0;
      let end = str.length;
      while (start < end && str[start] === char) {
        ++start;
      }
      while (end > start && str[end - 1] === char) {
        --end;
      }
      return start > 0 || end < str.length ? str.substring(start, end) : str;
    }
    function get8(obj, path) {
      for (const key2 of path) {
        if (!obj) {
          return void 0;
        }
        obj = obj[key2];
      }
      return obj;
    }
    function mergeDuplicatesPreferLast(items, getKey) {
      const map = /* @__PURE__ */ new Map();
      for (let i2 = items.length; i2-- > 0; ) {
        const item = items[i2];
        const key2 = getKey(item);
        map.set(key2, map.has(key2) ? merge(item, map.get(key2), { arrayMerge: overwriteMerge }) : item);
      }
      return [...map.values()].reverse();
    }
    var overwriteMerge = (acc, src, options) => [...src];
    module2.exports = {
      get: get8,
      limitedDepthRecursive,
      mergeDuplicatesPreferLast,
      numberToLetterSequence,
      numberToRoman,
      splitClassesAndIds,
      trimCharacter
    };
  }
});

// node_modules/html-to-text/lib/typedefs.js
var require_typedefs = __commonJS({
  "node_modules/html-to-text/lib/typedefs.js"() {
  }
});

// node_modules/html-to-text/lib/inline-text-builder.js
var require_inline_text_builder = __commonJS({
  "node_modules/html-to-text/lib/inline-text-builder.js"(exports, module2) {
    require_typedefs();
    var InlineTextBuilder = class {
      constructor(options, maxLineLength = void 0) {
        this.lines = [];
        this.nextLineWords = [];
        this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;
        this.nextLineAvailableChars = this.maxLineLength;
        this.wrapCharacters = options.longWordSplit.wrapCharacters || [];
        this.forceWrapOnLimit = options.longWordSplit.forceWrapOnLimit || false;
        this.stashedSpace = false;
        this.wordBreakOpportunity = false;
      }
      pushWord(word) {
        if (this.nextLineAvailableChars <= 0) {
          this.startNewLine();
        }
        const isLineStart = this.nextLineWords.length === 0;
        const cost = word.length + (isLineStart ? 0 : 1);
        if (cost <= this.nextLineAvailableChars) {
          this.nextLineWords.push(word);
          this.nextLineAvailableChars -= cost;
        } else {
          const [first, ...rest] = this.splitLongWord(word);
          if (!isLineStart) {
            this.startNewLine();
          }
          this.nextLineWords.push(first);
          this.nextLineAvailableChars -= first.length;
          for (const part of rest) {
            this.startNewLine();
            this.nextLineWords.push(part);
            this.nextLineAvailableChars -= part.length;
          }
        }
      }
      popWord() {
        const lastWord = this.nextLineWords.pop();
        if (lastWord !== void 0) {
          const isLineStart = this.nextLineWords.length === 0;
          const cost = lastWord.length + (isLineStart ? 0 : 1);
          this.nextLineAvailableChars += cost;
        }
        return lastWord;
      }
      concatWord(word) {
        if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {
          this.pushWord(word);
          this.wordBreakOpportunity = false;
        } else {
          const lastWord = this.popWord();
          this.pushWord(lastWord ? lastWord.concat(word) : word);
        }
      }
      startNewLine(n = 1) {
        this.lines.push(this.nextLineWords);
        if (n > 1) {
          this.lines.push(...Array.from({ length: n - 1 }, () => []));
        }
        this.nextLineWords = [];
        this.nextLineAvailableChars = this.maxLineLength;
      }
      isEmpty() {
        return this.lines.length === 0 && this.nextLineWords.length === 0;
      }
      clear() {
        this.lines.length = 0;
        this.nextLineWords.length = 0;
        this.nextLineAvailableChars = this.maxLineLength;
      }
      toString() {
        return [...this.lines, this.nextLineWords].map((words) => words.join(" ")).join("\n");
      }
      splitLongWord(word) {
        const parts = [];
        let idx = 0;
        while (word.length > this.maxLineLength) {
          const firstLine = word.substring(0, this.maxLineLength);
          const remainingChars = word.substring(this.maxLineLength);
          const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);
          if (splitIndex > -1) {
            word = firstLine.substring(splitIndex + 1) + remainingChars;
            parts.push(firstLine.substring(0, splitIndex + 1));
          } else {
            idx++;
            if (idx < this.wrapCharacters.length) {
              word = firstLine + remainingChars;
            } else {
              if (this.forceWrapOnLimit) {
                parts.push(firstLine);
                word = remainingChars;
                if (word.length > this.maxLineLength) {
                  continue;
                }
              } else {
                word = firstLine + remainingChars;
              }
              break;
            }
          }
        }
        parts.push(word);
        return parts;
      }
    };
    module2.exports = { InlineTextBuilder };
  }
});

// node_modules/html-to-text/lib/stack-item.js
var require_stack_item = __commonJS({
  "node_modules/html-to-text/lib/stack-item.js"(exports, module2) {
    var { InlineTextBuilder } = require_inline_text_builder();
    var StackItem = class {
      constructor(next = null) {
        this.next = next;
      }
      getRoot() {
        return this.next ? this.next : this;
      }
    };
    var BlockStackItem = class extends StackItem {
      constructor(options, next = null, leadingLineBreaks = 1, maxLineLength = void 0) {
        super(next);
        this.leadingLineBreaks = leadingLineBreaks;
        this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);
        this.rawText = "";
        this.stashedLineBreaks = 0;
        this.isPre = next && next.isPre;
      }
    };
    var TableStackItem = class extends StackItem {
      constructor(next = null) {
        super(next);
        this.rows = [];
        this.isPre = next && next.isPre;
      }
    };
    var TableRowStackItem = class extends StackItem {
      constructor(next = null) {
        super(next);
        this.cells = [];
        this.isPre = next && next.isPre;
      }
    };
    var TableCellStackItem = class extends StackItem {
      constructor(options, next = null, maxColumnWidth = void 0) {
        super(next);
        this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);
        this.rawText = "";
        this.stashedLineBreaks = 0;
        this.isPre = next && next.isPre;
      }
    };
    var TransformerStackItem = class extends StackItem {
      constructor(next = null, transform) {
        super(next);
        this.transform = transform;
      }
    };
    module2.exports = {
      BlockStackItem,
      StackItem,
      TableCellStackItem,
      TableRowStackItem,
      TableStackItem,
      TransformerStackItem
    };
  }
});

// node_modules/html-to-text/lib/table-printer.js
var require_table_printer = __commonJS({
  "node_modules/html-to-text/lib/table-printer.js"(exports, module2) {
    function getRow(matrix, j) {
      if (!matrix[j]) {
        matrix[j] = [];
      }
      return matrix[j];
    }
    function findFirstVacantIndex(row, x2 = 0) {
      while (row[x2]) {
        x2++;
      }
      return x2;
    }
    function transposeInPlace(matrix, maxSize) {
      for (let i2 = 0; i2 < maxSize; i2++) {
        const rowI = getRow(matrix, i2);
        for (let j = 0; j < i2; j++) {
          const rowJ = getRow(matrix, j);
          const temp = rowI[j];
          rowI[j] = rowJ[i2];
          rowJ[i2] = temp;
        }
      }
    }
    function putCellIntoLayout(cell, layout, baseRow, baseCol) {
      for (let r2 = 0; r2 < cell.rowspan; r2++) {
        const layoutRow = getRow(layout, baseRow + r2);
        for (let c = 0; c < cell.colspan; c++) {
          layoutRow[baseCol + c] = cell;
        }
      }
    }
    function updateOffset(offsets, base2, span, value) {
      offsets[base2 + span] = Math.max(offsets[base2 + span] || 0, offsets[base2] + value);
    }
    function tableToString(tableRows, rowSpacing, colSpacing) {
      const layout = [];
      let colNumber = 0;
      const rowNumber = tableRows.length;
      const rowOffsets = [0];
      for (let j = 0; j < rowNumber; j++) {
        const layoutRow = getRow(layout, j);
        const cells = tableRows[j];
        let x2 = 0;
        for (let i2 = 0; i2 < cells.length; i2++) {
          const cell = cells[i2];
          x2 = findFirstVacantIndex(layoutRow, x2);
          putCellIntoLayout(cell, layout, j, x2);
          x2 += cell.colspan;
          cell.lines = cell.text.split("\n");
          const cellHeight = cell.lines.length;
          updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);
        }
        colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;
      }
      transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);
      const outputLines = [];
      const colOffsets = [0];
      for (let x2 = 0; x2 < colNumber; x2++) {
        let y = 0;
        let cell;
        while (y < rowNumber && (cell = layout[x2][y])) {
          if (!cell.rendered) {
            let cellWidth = 0;
            for (let j = 0; j < cell.lines.length; j++) {
              const line = cell.lines[j];
              const lineOffset = rowOffsets[y] + j;
              outputLines[lineOffset] = (outputLines[lineOffset] || "").padEnd(colOffsets[x2]) + line;
              cellWidth = line.length > cellWidth ? line.length : cellWidth;
            }
            updateOffset(colOffsets, x2, cell.colspan, cellWidth + colSpacing);
            cell.rendered = true;
          }
          y += cell.rowspan;
        }
      }
      return outputLines.join("\n");
    }
    module2.exports = { tableToString };
  }
});

// node_modules/html-to-text/lib/whitespace-processor.js
var require_whitespace_processor = __commonJS({
  "node_modules/html-to-text/lib/whitespace-processor.js"(exports, module2) {
    var { InlineTextBuilder } = require_inline_text_builder();
    require_typedefs();
    function charactersToCodes(str) {
      return [...str].map((c) => "\\u" + c.charCodeAt(0).toString(16).padStart(4, "0")).join("");
    }
    var WhitespaceProcessor = class {
      constructor(options) {
        this.whitespaceChars = options.preserveNewlines ? options.whitespaceCharacters.replace(/\n/g, "") : options.whitespaceCharacters;
        const whitespaceCodes = charactersToCodes(this.whitespaceChars);
        this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);
        this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);
        this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);
        this.newlineOrNonWhitespaceRe = new RegExp(`(\\n|[^\\n${whitespaceCodes}])`, "g");
        if (options.preserveNewlines) {
          const wordOrNewlineRe = new RegExp(`\\n|[^\\n${whitespaceCodes}]+`, "gm");
          this.shrinkWrapAdd = function(text, inlineTextBuilder, transform = (str) => str) {
            if (!text) {
              return;
            }
            const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
            let anyMatch = false;
            let m2 = wordOrNewlineRe.exec(text);
            if (m2) {
              anyMatch = true;
              if (m2[0] === "\n") {
                inlineTextBuilder.startNewLine();
              } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
                inlineTextBuilder.pushWord(transform(m2[0]));
              } else {
                inlineTextBuilder.concatWord(transform(m2[0]));
              }
              while ((m2 = wordOrNewlineRe.exec(text)) !== null) {
                if (m2[0] === "\n") {
                  inlineTextBuilder.startNewLine();
                } else {
                  inlineTextBuilder.pushWord(transform(m2[0]));
                }
              }
            }
            inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);
          };
        } else {
          const wordRe = new RegExp(`[^${whitespaceCodes}]+`, "g");
          this.shrinkWrapAdd = function(text, inlineTextBuilder, transform = (str) => str) {
            if (!text) {
              return;
            }
            const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
            let anyMatch = false;
            let m2 = wordRe.exec(text);
            if (m2) {
              anyMatch = true;
              if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
                inlineTextBuilder.pushWord(transform(m2[0]));
              } else {
                inlineTextBuilder.concatWord(transform(m2[0]));
              }
              while ((m2 = wordRe.exec(text)) !== null) {
                inlineTextBuilder.pushWord(transform(m2[0]));
              }
            }
            inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);
          };
        }
      }
      testLeadingWhitespace(text) {
        return this.leadingWhitespaceRe.test(text);
      }
      testTrailingWhitespace(text) {
        return this.trailingWhitespaceRe.test(text);
      }
      testContainsWords(text) {
        return !this.allWhitespaceOrEmptyRe.test(text);
      }
      countNewlinesNoWords(text) {
        this.newlineOrNonWhitespaceRe.lastIndex = 0;
        let counter = 0;
        let match2;
        while ((match2 = this.newlineOrNonWhitespaceRe.exec(text)) !== null) {
          if (match2[0] === "\n") {
            counter++;
          } else {
            return 0;
          }
        }
        return counter;
      }
    };
    module2.exports = { WhitespaceProcessor };
  }
});

// node_modules/html-to-text/lib/block-text-builder.js
var require_block_text_builder = __commonJS({
  "node_modules/html-to-text/lib/block-text-builder.js"(exports, module2) {
    var { Picker } = require_selderee();
    var { trimCharacter } = require_helper();
    var { StackItem, BlockStackItem, TableCellStackItem, TableRowStackItem, TableStackItem, TransformerStackItem } = require_stack_item();
    var { tableToString } = require_table_printer();
    var { WhitespaceProcessor } = require_whitespace_processor();
    require_typedefs();
    var BlockTextBuilder = class {
      constructor(options, picker) {
        this.options = options;
        this.picker = picker;
        this.whitespaceProcessor = new WhitespaceProcessor(options);
        this._stackItem = new BlockStackItem(options);
        this._wordTransformer = void 0;
      }
      pushWordTransform(wordTransform) {
        this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);
      }
      popWordTransform() {
        if (!this._wordTransformer) {
          return void 0;
        }
        const transform = this._wordTransformer.transform;
        this._wordTransformer = this._wordTransformer.next;
        return transform;
      }
      _getCombinedWordTransformer() {
        const applyTransformer = (str, transformer) => transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;
        return (str) => applyTransformer(str, this._wordTransformer);
      }
      _popStackItem() {
        const item = this._stackItem;
        this._stackItem = item.next;
        return item;
      }
      addLineBreak() {
        if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof TableCellStackItem)) {
          return;
        }
        if (this._stackItem.isPre) {
          this._stackItem.rawText += "\n";
        } else {
          this._stackItem.inlineTextBuilder.startNewLine();
        }
      }
      addWordBreakOpportunity() {
        if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof TableCellStackItem) {
          this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;
        }
      }
      addInline(str, optionsObjectOrNoWordTransform = {}) {
        if (typeof optionsObjectOrNoWordTransform === "object") {
          this._addInline(str, optionsObjectOrNoWordTransform);
        } else {
          this._addInline(str, { noWordTransform: optionsObjectOrNoWordTransform });
        }
      }
      _addInline(str, { noWordTransform = false } = {}) {
        if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof TableCellStackItem)) {
          return;
        }
        if (this._stackItem.isPre) {
          this._stackItem.rawText += str;
          return;
        }
        if (str.length === 0 || this._stackItem.stashedLineBreaks && !this.whitespaceProcessor.testContainsWords(str)) {
          return;
        }
        if (this.options.preserveNewlines) {
          const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);
          if (newlinesNumber > 0) {
            this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);
            return;
          }
        }
        if (this._stackItem.stashedLineBreaks) {
          this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
        }
        this.whitespaceProcessor.shrinkWrapAdd(str, this._stackItem.inlineTextBuilder, this._wordTransformer && !noWordTransform ? this._getCombinedWordTransformer() : void 0);
        this._stackItem.stashedLineBreaks = 0;
      }
      openBlock(optionsObjectOrLeadingLineBreaks = {}, reservedLineLength = void 0, isPre = void 0) {
        if (typeof optionsObjectOrLeadingLineBreaks === "object") {
          this._openBlock(optionsObjectOrLeadingLineBreaks);
        } else {
          this._openBlock({
            isPre,
            leadingLineBreaks: optionsObjectOrLeadingLineBreaks,
            reservedLineLength
          });
        }
      }
      _openBlock({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {
        const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);
        this._stackItem = new BlockStackItem(this.options, this._stackItem, leadingLineBreaks, maxLineLength);
        if (isPre) {
          this._stackItem.isPre = true;
        }
      }
      closeBlock(optionsObjectOrTrailingLineBreaks = {}, blockTransform = void 0) {
        if (typeof optionsObjectOrTrailingLineBreaks === "object") {
          this._closeBlock(optionsObjectOrTrailingLineBreaks);
        } else {
          this._closeBlock({
            trailingLineBreaks: optionsObjectOrTrailingLineBreaks,
            blockTransform
          });
        }
      }
      _closeBlock({ trailingLineBreaks = 1, blockTransform = void 0 } = {}) {
        const block = this._popStackItem();
        const blockText = blockTransform ? blockTransform(getText(block)) : getText(block);
        addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));
      }
      openTable() {
        this._stackItem = new TableStackItem(this._stackItem);
      }
      openTableRow() {
        if (!(this._stackItem instanceof TableStackItem)) {
          throw new Error("Can't add table row to something that is not a table! Check the formatter.");
        }
        this._stackItem = new TableRowStackItem(this._stackItem);
      }
      openTableCell(optionsObjectOrMaxColumnWidth = {}) {
        if (typeof optionsObjectOrMaxColumnWidth === "object") {
          this._openTableCell(optionsObjectOrMaxColumnWidth);
        } else {
          this._openTableCell({ maxColumnWidth: optionsObjectOrMaxColumnWidth });
        }
      }
      _openTableCell({ maxColumnWidth = void 0 } = {}) {
        if (!(this._stackItem instanceof TableRowStackItem)) {
          throw new Error("Can't add table cell to something that is not a table row! Check the formatter.");
        }
        this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);
      }
      closeTableCell(optionsObjectOrColspan = {}, rowspan = void 0) {
        if (typeof optionsObjectOrColspan === "object") {
          this._closeTableCell(optionsObjectOrColspan);
        } else {
          this._closeTableCell({
            colspan: optionsObjectOrColspan,
            rowspan
          });
        }
      }
      _closeTableCell({ colspan = 1, rowspan = 1 } = {}) {
        const cell = this._popStackItem();
        const text = trimCharacter(getText(cell), "\n");
        cell.next.cells.push({ colspan, rowspan, text });
      }
      closeTableRow() {
        const row = this._popStackItem();
        row.next.rows.push(row.cells);
      }
      closeTable(optionsObjectOrColSpacing = {}, rowSpacing = void 0, leadingLineBreaks = void 0, trailingLineBreaks = void 0) {
        if (typeof optionsObjectOrColSpacing === "object") {
          this._closeTable(optionsObjectOrColSpacing);
        } else {
          this._closeTable({
            colSpacing: optionsObjectOrColSpacing,
            leadingLineBreaks,
            rowSpacing,
            trailingLineBreaks
          });
        }
      }
      _closeTable({ colSpacing = 3, rowSpacing = 0, leadingLineBreaks = 2, trailingLineBreaks = 2 } = {}) {
        const table = this._popStackItem();
        const output = tableToString(table.rows, rowSpacing, colSpacing);
        if (output) {
          addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);
        }
      }
      toString() {
        return getText(this._stackItem.getRoot());
      }
    };
    function getText(stackItem) {
      if (!(stackItem instanceof BlockStackItem || stackItem instanceof TableCellStackItem)) {
        throw new Error("Only blocks and table cells can be requested for text contents.");
      }
      return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();
    }
    function addText(stackItem, text, leadingLineBreaks, trailingLineBreaks) {
      if (!(stackItem instanceof BlockStackItem || stackItem instanceof TableCellStackItem)) {
        throw new Error("Only blocks and table cells can contain text.");
      }
      const parentText = getText(stackItem);
      const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);
      stackItem.inlineTextBuilder.clear();
      if (parentText) {
        stackItem.rawText = parentText + "\n".repeat(lineBreaks) + text;
      } else {
        stackItem.rawText = text;
        stackItem.leadingLineBreaks = lineBreaks;
      }
      stackItem.stashedLineBreaks = trailingLineBreaks;
    }
    module2.exports = { BlockTextBuilder };
  }
});

// node_modules/html-to-text/lib/formatter.js
var require_formatter = __commonJS({
  "node_modules/html-to-text/lib/formatter.js"(exports, module2) {
    var he = require_he();
    var { get: get8, numberToLetterSequence, numberToRoman, splitClassesAndIds, trimCharacter } = require_helper();
    require_typedefs();
    function formatSkip(elem, walk, builder, formatOptions) {
    }
    function formatInline(elem, walk, builder, formatOptions) {
      walk(elem.children, builder);
    }
    function formatBlock(elem, walk, builder, formatOptions) {
      builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });
      walk(elem.children, builder);
      builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });
    }
    function formatLineBreak(elem, walk, builder, formatOptions) {
      builder.addLineBreak();
    }
    function formatWbr(elem, walk, builder, formatOptions) {
      builder.addWordBreakOpportunity();
    }
    function formatHorizontalLine(elem, walk, builder, formatOptions) {
      builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
      builder.addInline("-".repeat(formatOptions.length || builder.options.wordwrap || 40));
      builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
    }
    function formatParagraph(elem, walk, builder, formatOptions) {
      builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
      walk(elem.children, builder);
      builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
    }
    function formatPre(elem, walk, builder, formatOptions) {
      builder.openBlock({
        isPre: true,
        leadingLineBreaks: formatOptions.leadingLineBreaks || 2
      });
      walk(elem.children, builder);
      builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
    }
    function formatHeading(elem, walk, builder, formatOptions) {
      builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
      if (formatOptions.uppercase !== false) {
        builder.pushWordTransform((str) => str.toUpperCase());
        walk(elem.children, builder);
        builder.popWordTransform();
      } else {
        walk(elem.children, builder);
      }
      builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
    }
    function formatBlockquote(elem, walk, builder, formatOptions) {
      builder.openBlock({
        leadingLineBreaks: formatOptions.leadingLineBreaks || 2,
        reservedLineLength: 2
      });
      walk(elem.children, builder);
      builder.closeBlock({
        trailingLineBreaks: formatOptions.trailingLineBreaks || 2,
        blockTransform: (str) => (formatOptions.trimEmptyLines !== false ? trimCharacter(str, "\n") : str).split("\n").map((line) => "> " + line).join("\n")
      });
    }
    function withBrackets(str, brackets) {
      if (!brackets) {
        return str;
      }
      const lbr2 = typeof brackets[0] === "string" ? brackets[0] : "[";
      const rbr2 = typeof brackets[1] === "string" ? brackets[1] : "]";
      return lbr2 + str + rbr2;
    }
    function formatImage(elem, walk, builder, formatOptions) {
      const attribs = elem.attribs || {};
      const alt = attribs.alt ? he.decode(attribs.alt, builder.options.decodeOptions) : "";
      const src = !attribs.src ? "" : formatOptions.baseUrl && attribs.src.indexOf("/") === 0 ? formatOptions.baseUrl + attribs.src : attribs.src;
      const text = !src ? alt : !alt ? withBrackets(src, formatOptions.linkBrackets) : alt + " " + withBrackets(src, formatOptions.linkBrackets);
      builder.addInline(text);
    }
    function formatAnchor(elem, walk, builder, formatOptions) {
      function getHref() {
        if (formatOptions.ignoreHref) {
          return "";
        }
        if (!elem.attribs || !elem.attribs.href) {
          return "";
        }
        let href2 = elem.attribs.href.replace(/^mailto:/, "");
        if (formatOptions.noAnchorUrl && href2[0] === "#") {
          return "";
        }
        href2 = formatOptions.baseUrl && href2[0] === "/" ? formatOptions.baseUrl + href2 : href2;
        return he.decode(href2, builder.options.decodeOptions);
      }
      const href = getHref();
      if (!href) {
        walk(elem.children, builder);
      } else {
        let text = "";
        builder.pushWordTransform((str) => {
          if (str) {
            text += str;
          }
          return str;
        });
        walk(elem.children, builder);
        builder.popWordTransform();
        const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;
        if (!hideSameLink) {
          builder.addInline(!text ? href : " " + withBrackets(href, formatOptions.linkBrackets), { noWordTransform: true });
        }
      }
    }
    function formatList(elem, walk, builder, formatOptions, nextPrefixCallback) {
      const isNestedList = get8(elem, ["parent", "name"]) === "li";
      let maxPrefixLength = 0;
      const listItems = (elem.children || []).filter((child) => child.type !== "text" || !/^\s*$/.test(child.data)).map(function(child) {
        if (child.name !== "li") {
          return { node: child, prefix: "" };
        }
        const prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();
        if (prefix.length > maxPrefixLength) {
          maxPrefixLength = prefix.length;
        }
        return { node: child, prefix };
      });
      if (!listItems.length) {
        return;
      }
      const reservedLineLength = maxPrefixLength;
      const spacing = "\n" + " ".repeat(reservedLineLength);
      builder.openBlock({ leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2 });
      for (const { node, prefix } of listItems) {
        builder.openBlock({
          leadingLineBreaks: 1,
          reservedLineLength
        });
        walk([node], builder);
        builder.closeBlock({
          trailingLineBreaks: 1,
          blockTransform: (str) => prefix + " ".repeat(reservedLineLength - prefix.length) + str.replace(/\n/g, spacing)
        });
      }
      builder.closeBlock({ trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2 });
    }
    function formatUnorderedList(elem, walk, builder, formatOptions) {
      const prefix = formatOptions.itemPrefix || " * ";
      return formatList(elem, walk, builder, formatOptions, () => prefix);
    }
    function formatOrderedList(elem, walk, builder, formatOptions) {
      let nextIndex = Number(elem.attribs.start || "1");
      const indexFunction = getOrderedListIndexFunction(elem.attribs.type);
      const nextPrefixCallback = () => " " + indexFunction(nextIndex++) + ". ";
      return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);
    }
    function getOrderedListIndexFunction(olType = "1") {
      switch (olType) {
        case "a":
          return (i2) => numberToLetterSequence(i2, "a");
        case "A":
          return (i2) => numberToLetterSequence(i2, "A");
        case "i":
          return (i2) => numberToRoman(i2).toLowerCase();
        case "I":
          return (i2) => numberToRoman(i2);
        case "1":
        default:
          return (i2) => i2.toString();
      }
    }
    function isDataTable(attr, tables) {
      if (tables === true) {
        return true;
      }
      if (!attr) {
        return false;
      }
      const { classes, ids } = splitClassesAndIds(tables);
      const attrClasses = (attr["class"] || "").split(" ");
      const attrIds = (attr["id"] || "").split(" ");
      return attrClasses.some((x2) => classes.includes(x2)) || attrIds.some((x2) => ids.includes(x2));
    }
    function formatTable(elem, walk, builder, formatOptions) {
      return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);
    }
    function formatDataTable(elem, walk, builder, formatOptions) {
      builder.openTable();
      elem.children.forEach(walkTable);
      builder.closeTable({
        colSpacing: formatOptions.colSpacing,
        leadingLineBreaks: formatOptions.leadingLineBreaks,
        rowSpacing: formatOptions.rowSpacing,
        trailingLineBreaks: formatOptions.trailingLineBreaks
      });
      function formatCell(cellNode) {
        const colspan = +get8(cellNode, ["attribs", "colspan"]) || 1;
        const rowspan = +get8(cellNode, ["attribs", "rowspan"]) || 1;
        builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });
        walk(cellNode.children, builder);
        builder.closeTableCell({ colspan, rowspan });
      }
      function walkTable(elem2) {
        if (elem2.type !== "tag") {
          return;
        }
        const formatHeaderCell = formatOptions.uppercaseHeaderCells !== false ? (cellNode) => {
          builder.pushWordTransform((str) => str.toUpperCase());
          formatCell(cellNode);
          builder.popWordTransform();
        } : formatCell;
        switch (elem2.name) {
          case "thead":
          case "tbody":
          case "tfoot":
          case "center":
            elem2.children.forEach(walkTable);
            return;
          case "tr": {
            builder.openTableRow();
            for (const childOfTr of elem2.children) {
              if (childOfTr.type !== "tag") {
                continue;
              }
              switch (childOfTr.name) {
                case "th": {
                  formatHeaderCell(childOfTr);
                  break;
                }
                case "td": {
                  formatCell(childOfTr);
                  break;
                }
                default:
              }
            }
            builder.closeTableRow();
            break;
          }
          default:
        }
      }
    }
    module2.exports = {
      anchor: formatAnchor,
      block: formatBlock,
      blockquote: formatBlockquote,
      dataTable: formatDataTable,
      heading: formatHeading,
      horizontalLine: formatHorizontalLine,
      image: formatImage,
      inline: formatInline,
      lineBreak: formatLineBreak,
      orderedList: formatOrderedList,
      paragraph: formatParagraph,
      pre: formatPre,
      skip: formatSkip,
      table: formatTable,
      unorderedList: formatUnorderedList,
      wbr: formatWbr
    };
  }
});

// node_modules/html-to-text/lib/html-to-text.js
var require_html_to_text = __commonJS({
  "node_modules/html-to-text/lib/html-to-text.js"(exports, module2) {
    var { hp2Builder } = require_hp2_builder();
    var merge = require_cjs();
    var he = require_he();
    var htmlparser = require_lib7();
    var selderee = require_selderee();
    var { BlockTextBuilder } = require_block_text_builder();
    var defaultFormatters = require_formatter();
    var { limitedDepthRecursive, mergeDuplicatesPreferLast, get: get8 } = require_helper();
    require_typedefs();
    var DEFAULT_OPTIONS = {
      baseElements: {
        selectors: ["body"],
        orderBy: "selectors",
        returnDomByDefault: true
      },
      decodeOptions: {
        isAttributeValue: false,
        strict: false
      },
      formatters: {},
      limits: {
        ellipsis: "...",
        maxBaseElements: void 0,
        maxChildNodes: void 0,
        maxDepth: void 0,
        maxInputLength: 1 << 24
      },
      longWordSplit: {
        forceWrapOnLimit: false,
        wrapCharacters: []
      },
      preserveNewlines: false,
      selectors: [
        { selector: "*", format: "inline" },
        {
          selector: "a",
          format: "anchor",
          options: {
            baseUrl: null,
            hideLinkHrefIfSameAsText: false,
            ignoreHref: false,
            linkBrackets: ["[", "]"],
            noAnchorUrl: true
          }
        },
        { selector: "article", format: "block" },
        { selector: "aside", format: "block" },
        {
          selector: "blockquote",
          format: "blockquote",
          options: { leadingLineBreaks: 2, trailingLineBreaks: 2, trimEmptyLines: true }
        },
        { selector: "br", format: "lineBreak" },
        { selector: "div", format: "block" },
        { selector: "footer", format: "block" },
        { selector: "form", format: "block" },
        { selector: "h1", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
        { selector: "h2", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
        { selector: "h3", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
        { selector: "h4", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
        { selector: "h5", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
        { selector: "h6", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
        { selector: "header", format: "block" },
        {
          selector: "hr",
          format: "horizontalLine",
          options: { leadingLineBreaks: 2, length: void 0, trailingLineBreaks: 2 }
        },
        {
          selector: "img",
          format: "image",
          options: { baseUrl: null, linkBrackets: ["[", "]"] }
        },
        { selector: "main", format: "block" },
        { selector: "nav", format: "block" },
        {
          selector: "ol",
          format: "orderedList",
          options: { leadingLineBreaks: 2, trailingLineBreaks: 2 }
        },
        { selector: "p", format: "paragraph", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
        { selector: "pre", format: "pre", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
        { selector: "section", format: "block" },
        {
          selector: "table",
          format: "table",
          options: {
            colSpacing: 3,
            leadingLineBreaks: 2,
            maxColumnWidth: 60,
            rowSpacing: 0,
            trailingLineBreaks: 2,
            uppercaseHeaderCells: true
          }
        },
        {
          selector: "ul",
          format: "unorderedList",
          options: { itemPrefix: " * ", leadingLineBreaks: 2, trailingLineBreaks: 2 }
        },
        { selector: "wbr", format: "wbr" }
      ],
      tables: [],
      whitespaceCharacters: " 	\r\n\f\u200B",
      wordwrap: 80
    };
    var concatMerge = (acc, src, options) => [...acc, ...src];
    var overwriteMerge = (acc, src, options) => [...src];
    var selectorsMerge = (acc, src, options) => acc.some((s3) => typeof s3 === "object") ? concatMerge(acc, src, options) : overwriteMerge(acc, src, options);
    function compile(options = {}) {
      options = merge(DEFAULT_OPTIONS, options, {
        arrayMerge: overwriteMerge,
        customMerge: (key2) => key2 === "selectors" ? selectorsMerge : void 0
      });
      options.formatters = Object.assign({}, defaultFormatters, options.formatters);
      handleDeprecatedOptions(options);
      const uniqueSelectors = mergeDuplicatesPreferLast(options.selectors, (s3) => s3.selector);
      const selectorsWithoutFormat = uniqueSelectors.filter((s3) => !s3.format);
      if (selectorsWithoutFormat.length) {
        throw new Error("Following selectors have no specified format: " + selectorsWithoutFormat.map((s3) => `\`${s3.selector}\``).join(", "));
      }
      const picker = new selderee.DecisionTree(uniqueSelectors.map((s3) => [s3.selector, s3])).build(hp2Builder);
      const baseSelectorsPicker = new selderee.DecisionTree(options.baseElements.selectors.map((s3, i2) => [s3, i2 + 1])).build(hp2Builder);
      function findBaseElements(dom) {
        return findBases(dom, options, baseSelectorsPicker);
      }
      const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk, function(dom, builder) {
        builder.addInline(options.limits.ellipsis || "");
      });
      return function(html) {
        return process2(html, options, picker, findBaseElements, limitedWalk);
      };
    }
    function process2(html, options, picker, findBaseElements, walk) {
      const maxInputLength = options.limits.maxInputLength;
      if (maxInputLength && html && html.length > maxInputLength) {
        console.warn(`Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`);
        html = html.substring(0, maxInputLength);
      }
      const handler = new htmlparser.DomHandler();
      new htmlparser.Parser(handler, { decodeEntities: false }).parseComplete(html);
      const bases = findBaseElements(handler.dom);
      const builder = new BlockTextBuilder(options, picker);
      walk(bases, builder);
      return builder.toString();
    }
    function convert2(html, options = {}) {
      return compile(options)(html);
    }
    function handleDeprecatedOptions(options) {
      const selectorDefinitions = options.selectors;
      if (options.tags) {
        const tagDefinitions = Object.entries(options.tags).map(([selector, definition]) => __spreadProps(__spreadValues({}, definition), { selector: selector || "*" }));
        selectorDefinitions.push(...tagDefinitions);
      }
      function set(obj, path, value) {
        const valueKey = path.pop();
        for (const key2 of path) {
          let nested = obj[key2];
          if (!nested) {
            nested = {};
            obj[key2] = nested;
          }
          obj = nested;
        }
        obj[valueKey] = value;
      }
      function copyFormatterOption(source, format3, target) {
        if (options[source] === void 0) {
          return;
        }
        for (const definition of selectorDefinitions) {
          if (definition.format === format3) {
            set(definition, ["options", target], options[source]);
          }
        }
      }
      copyFormatterOption("hideLinkHrefIfSameAsText", "anchor", "hideLinkHrefIfSameAsText");
      copyFormatterOption("ignoreHref", "anchor", "ignoreHref");
      copyFormatterOption("linkHrefBaseUrl", "anchor", "baseUrl");
      copyFormatterOption("noAnchorUrl", "anchor", "noAnchorUrl");
      copyFormatterOption("noLinkBrackets", "anchor", "noLinkBrackets");
      copyFormatterOption("linkHrefBaseUrl", "image", "baseUrl");
      copyFormatterOption("unorderedListItemPrefix", "unorderedList", "itemPrefix");
      copyFormatterOption("uppercaseHeadings", "heading", "uppercase");
      copyFormatterOption("uppercaseHeadings", "table", "uppercaseHeadings");
      copyFormatterOption("uppercaseHeadings", "dataTable", "uppercaseHeadings");
      if (options["ignoreImage"]) {
        for (const definition of selectorDefinitions) {
          if (definition.format === "image") {
            definition.format = "skip";
          }
        }
      }
      if (options["singleNewLineParagraphs"]) {
        for (const definition of selectorDefinitions) {
          if (definition.format === "paragraph" || definition.format === "pre") {
            set(definition, ["options", "leadingLineBreaks"], 1);
            set(definition, ["options", "trailingLineBreaks"], 1);
          }
        }
      }
      if (options["baseElement"]) {
        const baseElement = options["baseElement"];
        set(options, ["baseElements", "selectors"], Array.isArray(baseElement) ? baseElement : [baseElement]);
      }
      if (options["returnDomByDefault"] !== void 0) {
        set(options, ["baseElements", "returnDomByDefault"], options["returnDomByDefault"]);
      }
      for (const definition of selectorDefinitions) {
        if (definition.format === "anchor" && get8(definition, ["options", "noLinkBrackets"])) {
          set(definition, ["options", "linkBrackets"], false);
        }
      }
    }
    function findBases(dom, options, baseSelectorsPicker) {
      const results = [];
      function recursiveWalk2(walk, dom2) {
        dom2 = dom2.slice(0, options.limits.maxChildNodes);
        for (const elem of dom2) {
          if (elem.type !== "tag") {
            continue;
          }
          const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);
          if (pickedSelectorIndex > 0) {
            results.push({ selectorIndex: pickedSelectorIndex, element: elem });
          } else if (elem.children) {
            walk(elem.children);
          }
          if (results.length >= options.limits.maxBaseElements) {
            return;
          }
        }
      }
      const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk2);
      limitedWalk(dom);
      if (options.baseElements.orderBy !== "occurrence") {
        results.sort((a, b) => a.selectorIndex - b.selectorIndex);
      }
      return options.baseElements.returnDomByDefault && results.length === 0 ? dom : results.map((x2) => x2.element);
    }
    function recursiveWalk(walk, dom, builder) {
      if (!dom) {
        return;
      }
      const options = builder.options;
      const tooManyChildNodes = dom.length > options.limits.maxChildNodes;
      if (tooManyChildNodes) {
        dom = dom.slice(0, options.limits.maxChildNodes);
        dom.push({
          data: options.limits.ellipsis,
          type: "text"
        });
      }
      for (const elem of dom) {
        switch (elem.type) {
          case "text": {
            builder.addInline(he.decode(elem.data, options.decodeOptions));
            break;
          }
          case "tag": {
            const tagDefinition = builder.picker.pick1(elem);
            const format3 = options.formatters[tagDefinition.format];
            format3(elem, walk, builder, tagDefinition.options || {});
            break;
          }
          default:
            break;
        }
      }
      return;
    }
    var fromString2 = (html, options = {}) => convert2(html, options);
    module2.exports = {
      compile,
      convert: convert2,
      fromString: fromString2,
      htmlToText: convert2
    };
  }
});

// node_modules/html-to-text/index.js
var require_html_to_text2 = __commonJS({
  "node_modules/html-to-text/index.js"(exports, module2) {
    module2.exports = require_html_to_text();
  }
});

// .svelte-kit/output/server/entries/endpoints/blog/_id_.txt.ts.js
var id_txt_ts_exports = {};
__export(id_txt_ts_exports, {
  get: () => get5
});
function serializeNewsletter(newsletter) {
  const lines = [];
  lines.push("---");
  const txtTitle = (0, import_html_to_text.convert)(newsletter.title);
  lines.push(`title: ${txtTitle}`);
  lines.push(`id: ${newsletter.id}`);
  lines.push(`html_url: "https://acmcsuf.com${newsletter.url}"`);
  lines.push(`discussion_url: "${newsletter.discussionUrl}"`);
  const author = newsletter.author.displayname + (newsletter.author.url !== void 0 ? ` (${newsletter.author.url})` : "");
  lines.push(`author: "${author}"`);
  const labels = newsletter.labels.map((l) => `"${l}"`).join(", ");
  lines.push(`labels: [${labels}]`);
  lines.push(`created: "${new Date(newsletter.createdAt).toISOString()}"`);
  if (newsletter.lastEdited) {
    lines.push(`edited: "${new Date(newsletter.lastEdited).toISOString()}"`);
  }
  lines.push("---");
  lines.push("");
  lines.push(txtTitle);
  lines.push("=".repeat(txtTitle.length));
  lines.push("");
  return lines.concat((0, import_html_to_text.convert)(newsletter.html, { wordwrap: 100 })).join("\n");
}
async function getCache2(id, baseURL) {
  const target = baseURL + `/blog.json`;
  try {
    const response = await fetch(target);
    const data = await response.json();
    const newsletter = [...data].find((item) => item.id === id);
    return newsletter;
  } catch (err) {
    console.error(err);
    return void 0;
  }
}
async function get5(event) {
  const id = Number(event.params.id);
  const newsletter = await getCache2(id, event.url.origin);
  if (!newsletter) {
    return new Response("404 Not Found", {
      status: 404,
      headers: { "Content-Type": "text/plain" }
    });
  }
  return new Response(serializeNewsletter(newsletter), {
    status: 200,
    headers: { "Content-Type": "text/plain" }
  });
}
var import_html_to_text;
var init_id_txt_ts = __esm({
  ".svelte-kit/output/server/entries/endpoints/blog/_id_.txt.ts.js"() {
    import_html_to_text = __toESM(require_html_to_text2(), 1);
  }
});

// .svelte-kit/output/server/entries/endpoints/blog/_id_.json.ts.js
var id_json_ts_exports = {};
__export(id_json_ts_exports, {
  get: () => get6
});
async function getCache3(id, origin) {
  const target = origin + `/blog.json`;
  try {
    const response = await fetch(target);
    const data = await response.json();
    const newsletter = data.find((item) => {
      return item.id === id;
    });
    return newsletter;
  } catch (err) {
    console.error(err);
    return void 0;
  }
}
async function get6(event) {
  const id = Number(event.params.id);
  const payload = await getCache3(id, event.url.origin);
  if (typeof payload === "undefined") {
    return new Response(null, { status: 404, headers: { "Content-Type": "application/json" } });
  }
  return new Response(JSON.stringify(payload), {
    status: 200,
    headers: { "Content-Type": "application/json" }
  });
}
var init_id_json_ts = __esm({
  ".svelte-kit/output/server/entries/endpoints/blog/_id_.json.ts.js"() {
  }
});

// node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "node_modules/qrcode/lib/can-promise.js"(exports, module2) {
    module2.exports = function() {
      return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
    };
  }
});

// node_modules/qrcode/lib/core/utils.js
var require_utils = __commonJS({
  "node_modules/qrcode/lib/core/utils.js"(exports) {
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports.getSymbolSize = function getSymbolSize(version) {
      if (!version)
        throw new Error('"version" cannot be null or undefined');
      if (version < 1 || version > 40)
        throw new Error('"version" should be in range from 1 to 40');
      return version * 4 + 17;
    };
    exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {
      return CODEWORDS_COUNT[version];
    };
    exports.getBCHDigit = function(data) {
      let digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    };
    exports.setToSJISFunction = function setToSJISFunction(f3) {
      if (typeof f3 !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f3;
    };
    exports.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-level.js"(exports) {
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString2(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string);
      }
    }
    exports.isValid = function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString2(value);
      } catch (e2) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "node_modules/qrcode/lib/core/bit-buffer.js"(exports, module2) {
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    BitBuffer.prototype = {
      get: function(index) {
        const bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
      },
      put: function(num, length) {
        for (let i2 = 0; i2 < length; i2++) {
          this.putBit((num >>> length - i2 - 1 & 1) === 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        const bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module2.exports = BitBuffer;
  }
});

// node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "node_modules/qrcode/lib/core/bit-matrix.js"(exports, module2) {
    function BitMatrix(size) {
      if (!size || size < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size;
      this.data = new Uint8Array(size * size);
      this.reservedBit = new Uint8Array(size * size);
    }
    BitMatrix.prototype.set = function(row, col, value, reserved2) {
      const index = row * this.size + col;
      this.data[index] = value;
      if (reserved2)
        this.reservedBit[index] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value) {
      this.data[row * this.size + col] ^= value;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module2.exports = BitMatrix;
  }
});

// node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "node_modules/qrcode/lib/core/alignment-pattern.js"(exports) {
    var getSymbolSize = require_utils().getSymbolSize;
    exports.getRowColCoords = function getRowColCoords(version) {
      if (version === 1)
        return [];
      const posCount = Math.floor(version / 7) + 2;
      const size = getSymbolSize(version);
      const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      const positions = [size - 7];
      for (let i2 = 1; i2 < posCount - 1; i2++) {
        positions[i2] = positions[i2 - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports.getPositions = function getPositions(version) {
      const coords = [];
      const pos = exports.getRowColCoords(version);
      const posLength = pos.length;
      for (let i2 = 0; i2 < posLength; i2++) {
        for (let j = 0; j < posLength; j++) {
          if (i2 === 0 && j === 0 || i2 === 0 && j === posLength - 1 || i2 === posLength - 1 && j === 0) {
            continue;
          }
          coords.push([pos[i2], pos[j]]);
        }
      }
      return coords;
    };
  }
});

// node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "node_modules/qrcode/lib/core/finder-pattern.js"(exports) {
    var getSymbolSize = require_utils().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports.getPositions = function getPositions(version) {
      const size = getSymbolSize(version);
      return [
        [0, 0],
        [size - FINDER_PATTERN_SIZE, 0],
        [0, size - FINDER_PATTERN_SIZE]
      ];
    };
  }
});

// node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "node_modules/qrcode/lib/core/mask-pattern.js"(exports) {
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports.isValid = function isValid(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports.from = function from(value) {
      return exports.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports.getPenaltyN1 = function getPenaltyN1(data) {
      const size = data.size;
      let points = 0;
      let sameCountCol = 0;
      let sameCountRow = 0;
      let lastCol = null;
      let lastRow = null;
      for (let row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (let col = 0; col < size; col++) {
          let module3 = data.get(row, col);
          if (module3 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5)
              points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module3;
            sameCountCol = 1;
          }
          module3 = data.get(col, row);
          if (module3 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5)
              points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module3;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5)
          points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5)
          points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports.getPenaltyN2 = function getPenaltyN2(data) {
      const size = data.size;
      let points = 0;
      for (let row = 0; row < size - 1; row++) {
        for (let col = 0; col < size - 1; col++) {
          const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last === 4 || last === 0)
            points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports.getPenaltyN3 = function getPenaltyN3(data) {
      const size = data.size;
      let points = 0;
      let bitsCol = 0;
      let bitsRow = 0;
      for (let row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (let col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
            points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
            points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports.getPenaltyN4 = function getPenaltyN4(data) {
      let darkCount = 0;
      const modulesCount = data.data.length;
      for (let i2 = 0; i2 < modulesCount; i2++)
        darkCount += data.data[i2];
      const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern, i2, j) {
      switch (maskPattern) {
        case exports.Patterns.PATTERN000:
          return (i2 + j) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i2 % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i2 + j) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i2 / 2) + Math.floor(j / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return i2 * j % 2 + i2 * j % 3 === 0;
        case exports.Patterns.PATTERN110:
          return (i2 * j % 2 + i2 * j % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (i2 * j % 3 + (i2 + j) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    exports.applyMask = function applyMask(pattern, data) {
      const size = data.size;
      for (let col = 0; col < size; col++) {
        for (let row = 0; row < size; row++) {
          if (data.isReserved(row, col))
            continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports.getBestMask = function getBestMask(data, setupFormatFunc) {
      const numPatterns = Object.keys(exports.Patterns).length;
      let bestPattern = 0;
      let lowerPenalty = Infinity;
      for (let p = 0; p < numPatterns; p++) {
        setupFormatFunc(p);
        exports.applyMask(p, data);
        const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
        exports.applyMask(p, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p;
        }
      }
      return bestPattern;
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-code.js"(exports) {
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports.getBlocksCount = function getBlocksCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    exports.getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
  }
});

// node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "node_modules/qrcode/lib/core/galois-field.js"(exports) {
    var EXP_TABLE = new Uint8Array(512);
    var LOG_TABLE = new Uint8Array(256);
    (function initTables() {
      let x2 = 1;
      for (let i2 = 0; i2 < 255; i2++) {
        EXP_TABLE[i2] = x2;
        LOG_TABLE[x2] = i2;
        x2 <<= 1;
        if (x2 & 256) {
          x2 ^= 285;
        }
      }
      for (let i2 = 255; i2 < 512; i2++) {
        EXP_TABLE[i2] = EXP_TABLE[i2 - 255];
      }
    })();
    exports.log = function log(n) {
      if (n < 1)
        throw new Error("log(" + n + ")");
      return LOG_TABLE[n];
    };
    exports.exp = function exp(n) {
      return EXP_TABLE[n];
    };
    exports.mul = function mul(x2, y) {
      if (x2 === 0 || y === 0)
        return 0;
      return EXP_TABLE[LOG_TABLE[x2] + LOG_TABLE[y]];
    };
  }
});

// node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "node_modules/qrcode/lib/core/polynomial.js"(exports) {
    var GF = require_galois_field();
    exports.mul = function mul(p1, p2) {
      const coeff = new Uint8Array(p1.length + p2.length - 1);
      for (let i2 = 0; i2 < p1.length; i2++) {
        for (let j = 0; j < p2.length; j++) {
          coeff[i2 + j] ^= GF.mul(p1[i2], p2[j]);
        }
      }
      return coeff;
    };
    exports.mod = function mod(divident, divisor) {
      let result = new Uint8Array(divident);
      while (result.length - divisor.length >= 0) {
        const coeff = result[0];
        for (let i2 = 0; i2 < divisor.length; i2++) {
          result[i2] ^= GF.mul(divisor[i2], coeff);
        }
        let offset2 = 0;
        while (offset2 < result.length && result[offset2] === 0)
          offset2++;
        result = result.slice(offset2);
      }
      return result;
    };
    exports.generateECPolynomial = function generateECPolynomial(degree) {
      let poly = new Uint8Array([1]);
      for (let i2 = 0; i2 < degree; i2++) {
        poly = exports.mul(poly, new Uint8Array([1, GF.exp(i2)]));
      }
      return poly;
    };
  }
});

// node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports, module2) {
    var Polynomial = require_polynomial();
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree)
        this.initialize(this.degree);
    }
    ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    ReedSolomonEncoder.prototype.encode = function encode2(data) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      const paddedData = new Uint8Array(data.length + this.degree);
      paddedData.set(data);
      const remainder = Polynomial.mod(paddedData, this.genPoly);
      const start = this.degree - remainder.length;
      if (start > 0) {
        const buff = new Uint8Array(this.degree);
        buff.set(remainder, start);
        return buff;
      }
      return remainder;
    };
    module2.exports = ReedSolomonEncoder;
  }
});

// node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "node_modules/qrcode/lib/core/version-check.js"(exports) {
    exports.isValid = function isValid(version) {
      return !isNaN(version) && version >= 1 && version <= 40;
    };
  }
});

// node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "node_modules/qrcode/lib/core/regex.js"(exports) {
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports.KANJI = new RegExp(kanji, "g");
    exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports.BYTE = new RegExp(byte, "g");
    exports.NUMERIC = new RegExp(numeric, "g");
    exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };
    exports.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };
    exports.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };
  }
});

// node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS({
  "node_modules/qrcode/lib/core/mode.js"(exports) {
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports.MIXED = {
      bit: -1
    };
    exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {
      if (!mode.ccBits)
        throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version)) {
        throw new Error("Invalid version: " + version);
      }
      if (version >= 1 && version < 10)
        return mode.ccBits[0];
      else if (version < 27)
        return mode.ccBits[1];
      return mode.ccBits[2];
    };
    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr))
        return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr))
        return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr))
        return exports.KANJI;
      else
        return exports.BYTE;
    };
    exports.toString = function toString(mode) {
      if (mode && mode.id)
        return mode.id;
      throw new Error("Invalid mode");
    };
    exports.isValid = function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    function fromString2(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string);
      }
    }
    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString2(value);
      } catch (e2) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/version.js
var require_version = __commonJS({
  "node_modules/qrcode/lib/core/version.js"(exports) {
    var Utils = require_utils();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode, version) {
      return Mode.getCharCountIndicator(mode, version) + 4;
    }
    function getTotalBitsFromDataArray(segments, version) {
      let totalBits = 0;
      segments.forEach(function(data) {
        const reservedBits = getReservedBitsCount(data.mode, version);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        const length = getTotalBitsFromDataArray(segments, currentVersion);
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports.from = function from(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined")
        mode = Mode.BYTE;
      const totalCodewords = Utils.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED)
        return dataTotalCodewordsBits;
      const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
      let seg;
      const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (Array.isArray(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports.getEncodedBits = function getEncodedBits(version) {
      if (!VersionCheck.isValid(version) || version < 7) {
        throw new Error("Invalid QR Code version");
      }
      let d = version << 12;
      while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
        d ^= G18 << Utils.getBCHDigit(d) - G18_BCH;
      }
      return version << 12 | d;
    };
  }
});

// node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "node_modules/qrcode/lib/core/format-info.js"(exports) {
    var Utils = require_utils();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
      const data = errorCorrectionLevel.bit << 3 | mask;
      let d = data << 10;
      while (Utils.getBCHDigit(d) - G15_BCH >= 0) {
        d ^= G15 << Utils.getBCHDigit(d) - G15_BCH;
      }
      return (data << 10 | d) ^ G15_MASK;
    };
  }
});

// node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "node_modules/qrcode/lib/core/numeric-data.js"(exports, module2) {
    var Mode = require_mode();
    function NumericData(data) {
      this.mode = Mode.NUMERIC;
      this.data = data.toString();
    }
    NumericData.getBitsLength = function getBitsLength(length) {
      return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
    };
    NumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };
    NumericData.prototype.write = function write(bitBuffer) {
      let i2, group, value;
      for (i2 = 0; i2 + 3 <= this.data.length; i2 += 3) {
        group = this.data.substr(i2, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
      }
      const remainingNum = this.data.length - i2;
      if (remainingNum > 0) {
        group = this.data.substr(i2);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };
    module2.exports = NumericData;
  }
});

// node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "node_modules/qrcode/lib/core/alphanumeric-data.js"(exports, module2) {
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data;
    }
    AlphanumericData.getBitsLength = function getBitsLength(length) {
      return 11 * Math.floor(length / 2) + 6 * (length % 2);
    };
    AlphanumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };
    AlphanumericData.prototype.write = function write(bitBuffer) {
      let i2;
      for (i2 = 0; i2 + 2 <= this.data.length; i2 += 2) {
        let value = ALPHA_NUM_CHARS.indexOf(this.data[i2]) * 45;
        value += ALPHA_NUM_CHARS.indexOf(this.data[i2 + 1]);
        bitBuffer.put(value, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i2]), 6);
      }
    };
    module2.exports = AlphanumericData;
  }
});

// node_modules/encode-utf8/index.js
var require_encode_utf8 = __commonJS({
  "node_modules/encode-utf8/index.js"(exports, module2) {
    "use strict";
    module2.exports = function encodeUtf8(input) {
      var result = [];
      var size = input.length;
      for (var index = 0; index < size; index++) {
        var point = input.charCodeAt(index);
        if (point >= 55296 && point <= 56319 && size > index + 1) {
          var second = input.charCodeAt(index + 1);
          if (second >= 56320 && second <= 57343) {
            point = (point - 55296) * 1024 + second - 56320 + 65536;
            index += 1;
          }
        }
        if (point < 128) {
          result.push(point);
          continue;
        }
        if (point < 2048) {
          result.push(point >> 6 | 192);
          result.push(point & 63 | 128);
          continue;
        }
        if (point < 55296 || point >= 57344 && point < 65536) {
          result.push(point >> 12 | 224);
          result.push(point >> 6 & 63 | 128);
          result.push(point & 63 | 128);
          continue;
        }
        if (point >= 65536 && point <= 1114111) {
          result.push(point >> 18 | 240);
          result.push(point >> 12 & 63 | 128);
          result.push(point >> 6 & 63 | 128);
          result.push(point & 63 | 128);
          continue;
        }
        result.push(239, 191, 189);
      }
      return new Uint8Array(result).buffer;
    };
  }
});

// node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "node_modules/qrcode/lib/core/byte-data.js"(exports, module2) {
    var encodeUtf8 = require_encode_utf8();
    var Mode = require_mode();
    function ByteData(data) {
      this.mode = Mode.BYTE;
      this.data = new Uint8Array(encodeUtf8(data));
    }
    ByteData.getBitsLength = function getBitsLength(length) {
      return length * 8;
    };
    ByteData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };
    ByteData.prototype.write = function(bitBuffer) {
      for (let i2 = 0, l = this.data.length; i2 < l; i2++) {
        bitBuffer.put(this.data[i2], 8);
      }
    };
    module2.exports = ByteData;
  }
});

// node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "node_modules/qrcode/lib/core/kanji-data.js"(exports, module2) {
    var Mode = require_mode();
    var Utils = require_utils();
    function KanjiData(data) {
      this.mode = Mode.KANJI;
      this.data = data;
    }
    KanjiData.getBitsLength = function getBitsLength(length) {
      return length * 13;
    };
    KanjiData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };
    KanjiData.prototype.write = function(bitBuffer) {
      let i2;
      for (i2 = 0; i2 < this.data.length; i2++) {
        let value = Utils.toSJIS(this.data[i2]);
        if (value >= 33088 && value <= 40956) {
          value -= 33088;
        } else if (value >= 57408 && value <= 60351) {
          value -= 49472;
        } else {
          throw new Error("Invalid SJIS character: " + this.data[i2] + "\nMake sure your charset is UTF-8");
        }
        value = (value >>> 8 & 255) * 192 + (value & 255);
        bitBuffer.put(value, 13);
      }
    };
    module2.exports = KanjiData;
  }
});

// node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/dijkstrajs/dijkstra.js"(exports, module2) {
    "use strict";
    var dijkstra = {
      single_source_shortest_paths: function(graph, s3, d) {
        var predecessors = {};
        var costs = {};
        costs[s3] = 0;
        var open = dijkstra.PriorityQueue.make();
        open.push(s3, 0);
        var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open.empty()) {
          closest = open.pop();
          u = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u] || {};
          for (v in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v)) {
              cost_of_e = adjacent_nodes[v];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v];
              first_visit = typeof costs[v] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v] = u;
              }
            }
          }
        }
        if (typeof d !== "undefined" && typeof costs[d] === "undefined") {
          var msg = ["Could not find a path from ", s3, " to ", d, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d) {
        var nodes = [];
        var u = d;
        var predecessor;
        while (u) {
          nodes.push(u);
          predecessor = predecessors[u];
          u = predecessors[u];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s3, d) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s3, d);
        return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);
      },
      PriorityQueue: {
        make: function(opts) {
          var T = dijkstra.PriorityQueue, t2 = {}, key2;
          opts = opts || {};
          for (key2 in T) {
            if (T.hasOwnProperty(key2)) {
              t2[key2] = T[key2];
            }
          }
          t2.queue = [];
          t2.sorter = opts.sorter || T.default_sorter;
          return t2;
        },
        default_sorter: function(a, b) {
          return a.cost - b.cost;
        },
        push: function(value, cost) {
          var item = { value, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    if (typeof module2 !== "undefined") {
      module2.exports = dijkstra;
    }
  }
});

// node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS({
  "node_modules/qrcode/lib/core/segments.js"(exports) {
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex, mode, str) {
      const segments = [];
      let result;
      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length
        });
      }
      return segments;
    }
    function getSegmentsFromString(dataStr) {
      const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      let byteSegs;
      let kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s22) {
        return s1.index - s22.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length);
        case Mode.BYTE:
          return ByteData.getBitsLength(length);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      const nodes = [];
      for (let i2 = 0; i2 < segs.length; i2++) {
        const seg = segs[i2];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version) {
      const table = {};
      const graph = { start: {} };
      let prevNodeIds = ["start"];
      for (let i2 = 0; i2 < nodes.length; i2++) {
        const nodeGroup = nodes[i2];
        const currentNodeIds = [];
        for (let j = 0; j < nodeGroup.length; j++) {
          const node = nodeGroup[j];
          const key2 = "" + i2 + j;
          currentNodeIds.push(key2);
          table[key2] = { node, lastCount: 0 };
          graph[key2] = {};
          for (let n = 0; n < prevNodeIds.length; n++) {
            const prevNodeId = prevNodeIds[n];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key2] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId])
                table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key2] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (let n = 0; n < prevNodeIds.length; n++) {
        graph[prevNodeIds[n]].end = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data, modesHint) {
      let mode;
      const bestMode = Mode.getBestModeForData(data);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    exports.fromArray = function fromArray(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports.fromString = function fromString2(data, version) {
      const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      const nodes = buildNodes(segs);
      const graph = buildGraph(nodes, version);
      const path = dijkstra.find_path(graph.map, "start", "end");
      const optimizedSegs = [];
      for (let i2 = 1; i2 < path.length - 1; i2++) {
        optimizedSegs.push(graph.table[path[i2]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    exports.rawSplit = function rawSplit(data) {
      return exports.fromArray(getSegmentsFromString(data, Utils.isKanjiModeEnabled()));
    };
  }
});

// node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/qrcode/lib/core/qrcode.js"(exports) {
    var Utils = require_utils();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    function setupFinderPattern(matrix, version) {
      const size = matrix.size;
      const pos = FinderPattern.getPositions(version);
      for (let i2 = 0; i2 < pos.length; i2++) {
        const row = pos[i2][0];
        const col = pos[i2][1];
        for (let r2 = -1; r2 <= 7; r2++) {
          if (row + r2 <= -1 || size <= row + r2)
            continue;
          for (let c = -1; c <= 7; c++) {
            if (col + c <= -1 || size <= col + c)
              continue;
            if (r2 >= 0 && r2 <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r2 === 0 || r2 === 6) || r2 >= 2 && r2 <= 4 && c >= 2 && c <= 4) {
              matrix.set(row + r2, col + c, true, true);
            } else {
              matrix.set(row + r2, col + c, false, true);
            }
          }
        }
      }
    }
    function setupTimingPattern(matrix) {
      const size = matrix.size;
      for (let r2 = 8; r2 < size - 8; r2++) {
        const value = r2 % 2 === 0;
        matrix.set(r2, 6, value, true);
        matrix.set(6, r2, value, true);
      }
    }
    function setupAlignmentPattern(matrix, version) {
      const pos = AlignmentPattern.getPositions(version);
      for (let i2 = 0; i2 < pos.length; i2++) {
        const row = pos[i2][0];
        const col = pos[i2][1];
        for (let r2 = -2; r2 <= 2; r2++) {
          for (let c = -2; c <= 2; c++) {
            if (r2 === -2 || r2 === 2 || c === -2 || c === 2 || r2 === 0 && c === 0) {
              matrix.set(row + r2, col + c, true, true);
            } else {
              matrix.set(row + r2, col + c, false, true);
            }
          }
        }
      }
    }
    function setupVersionInfo(matrix, version) {
      const size = matrix.size;
      const bits = Version.getEncodedBits(version);
      let row, col, mod;
      for (let i2 = 0; i2 < 18; i2++) {
        row = Math.floor(i2 / 3);
        col = i2 % 3 + size - 8 - 3;
        mod = (bits >> i2 & 1) === 1;
        matrix.set(row, col, mod, true);
        matrix.set(col, row, mod, true);
      }
    }
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      const size = matrix.size;
      const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      let i2, mod;
      for (i2 = 0; i2 < 15; i2++) {
        mod = (bits >> i2 & 1) === 1;
        if (i2 < 6) {
          matrix.set(i2, 8, mod, true);
        } else if (i2 < 8) {
          matrix.set(i2 + 1, 8, mod, true);
        } else {
          matrix.set(size - 15 + i2, 8, mod, true);
        }
        if (i2 < 8) {
          matrix.set(8, size - i2 - 1, mod, true);
        } else if (i2 < 9) {
          matrix.set(8, 15 - i2 - 1 + 1, mod, true);
        } else {
          matrix.set(8, 15 - i2 - 1, mod, true);
        }
      }
      matrix.set(size - 8, 8, 1, true);
    }
    function setupData(matrix, data) {
      const size = matrix.size;
      let inc = -1;
      let row = size - 1;
      let bitIndex = 7;
      let byteIndex = 0;
      for (let col = size - 1; col > 0; col -= 2) {
        if (col === 6)
          col--;
        while (true) {
          for (let c = 0; c < 2; c++) {
            if (!matrix.isReserved(row, col - c)) {
              let dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix.set(row, col - c, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    function createData(version, errorCorrectionLevel, segments) {
      const buffer = new BitBuffer();
      segments.forEach(function(data) {
        buffer.put(data.mode.bit, 4);
        buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));
        data.write(buffer);
      });
      const totalCodewords = Utils.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer.put(0, 4);
      }
      while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(0);
      }
      const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
      for (let i2 = 0; i2 < remainingByte; i2++) {
        buffer.put(i2 % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer, version, errorCorrectionLevel);
    }
    function createCodewords(bitBuffer, version, errorCorrectionLevel) {
      const totalCodewords = Utils.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewords = totalCodewords - ecTotalCodewords;
      const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);
      const blocksInGroup2 = totalCodewords % ecTotalBlocks;
      const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      const rs = new ReedSolomonEncoder(ecCount);
      let offset2 = 0;
      const dcData = new Array(ecTotalBlocks);
      const ecData = new Array(ecTotalBlocks);
      let maxDataSize = 0;
      const buffer = new Uint8Array(bitBuffer.buffer);
      for (let b = 0; b < ecTotalBlocks; b++) {
        const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b] = buffer.slice(offset2, offset2 + dataSize);
        ecData[b] = rs.encode(dcData[b]);
        offset2 += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      const data = new Uint8Array(totalCodewords);
      let index = 0;
      let i2, r2;
      for (i2 = 0; i2 < maxDataSize; i2++) {
        for (r2 = 0; r2 < ecTotalBlocks; r2++) {
          if (i2 < dcData[r2].length) {
            data[index++] = dcData[r2][i2];
          }
        }
      }
      for (i2 = 0; i2 < ecCount; i2++) {
        for (r2 = 0; r2 < ecTotalBlocks; r2++) {
          data[index++] = ecData[r2][i2];
        }
      }
      return data;
    }
    function createSymbol(data, version, errorCorrectionLevel, maskPattern) {
      let segments;
      if (Array.isArray(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === "string") {
        let estimatedVersion = version;
        if (!estimatedVersion) {
          const rawSegments = Segments.rawSplit(data);
          estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
        }
        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version) {
        version = bestVersion;
      } else if (version < bestVersion) {
        throw new Error("\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n");
      }
      const dataBits = createData(version, errorCorrectionLevel, segments);
      const moduleCount = Utils.getSymbolSize(version);
      const modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version >= 7) {
        setupVersionInfo(modules, version);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    exports.create = function create(data, options) {
      if (typeof data === "undefined" || data === "") {
        throw new Error("No input text");
      }
      let errorCorrectionLevel = ECLevel.M;
      let version;
      let mask;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data, version, errorCorrectionLevel, mask);
    };
  }
});

// node_modules/pngjs/lib/chunkstream.js
var require_chunkstream = __commonJS({
  "node_modules/pngjs/lib/chunkstream.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var Stream2 = require("stream");
    var ChunkStream = module2.exports = function() {
      Stream2.call(this);
      this._buffers = [];
      this._buffered = 0;
      this._reads = [];
      this._paused = false;
      this._encoding = "utf8";
      this.writable = true;
    };
    util.inherits(ChunkStream, Stream2);
    ChunkStream.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
      process.nextTick(function() {
        this._process();
        if (this._paused && this._reads && this._reads.length > 0) {
          this._paused = false;
          this.emit("drain");
        }
      }.bind(this));
    };
    ChunkStream.prototype.write = function(data, encoding) {
      if (!this.writable) {
        this.emit("error", new Error("Stream not writable"));
        return false;
      }
      let dataBuffer;
      if (Buffer.isBuffer(data)) {
        dataBuffer = data;
      } else {
        dataBuffer = Buffer.from(data, encoding || this._encoding);
      }
      this._buffers.push(dataBuffer);
      this._buffered += dataBuffer.length;
      this._process();
      if (this._reads && this._reads.length === 0) {
        this._paused = true;
      }
      return this.writable && !this._paused;
    };
    ChunkStream.prototype.end = function(data, encoding) {
      if (data) {
        this.write(data, encoding);
      }
      this.writable = false;
      if (!this._buffers) {
        return;
      }
      if (this._buffers.length === 0) {
        this._end();
      } else {
        this._buffers.push(null);
        this._process();
      }
    };
    ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
    ChunkStream.prototype._end = function() {
      if (this._reads.length > 0) {
        this.emit("error", new Error("Unexpected end of input"));
      }
      this.destroy();
    };
    ChunkStream.prototype.destroy = function() {
      if (!this._buffers) {
        return;
      }
      this.writable = false;
      this._reads = null;
      this._buffers = null;
      this.emit("close");
    };
    ChunkStream.prototype._processReadAllowingLess = function(read2) {
      this._reads.shift();
      let smallerBuf = this._buffers[0];
      if (smallerBuf.length > read2.length) {
        this._buffered -= read2.length;
        this._buffers[0] = smallerBuf.slice(read2.length);
        read2.func.call(this, smallerBuf.slice(0, read2.length));
      } else {
        this._buffered -= smallerBuf.length;
        this._buffers.shift();
        read2.func.call(this, smallerBuf);
      }
    };
    ChunkStream.prototype._processRead = function(read2) {
      this._reads.shift();
      let pos = 0;
      let count = 0;
      let data = Buffer.alloc(read2.length);
      while (pos < read2.length) {
        let buf = this._buffers[count++];
        let len = Math.min(buf.length, read2.length - pos);
        buf.copy(data, pos, 0, len);
        pos += len;
        if (len !== buf.length) {
          this._buffers[--count] = buf.slice(len);
        }
      }
      if (count > 0) {
        this._buffers.splice(0, count);
      }
      this._buffered -= read2.length;
      read2.func.call(this, data);
    };
    ChunkStream.prototype._process = function() {
      try {
        while (this._buffered > 0 && this._reads && this._reads.length > 0) {
          let read2 = this._reads[0];
          if (read2.allowLess) {
            this._processReadAllowingLess(read2);
          } else if (this._buffered >= read2.length) {
            this._processRead(read2);
          } else {
            break;
          }
        }
        if (this._buffers && !this.writable) {
          this._end();
        }
      } catch (ex) {
        this.emit("error", ex);
      }
    };
  }
});

// node_modules/pngjs/lib/interlace.js
var require_interlace = __commonJS({
  "node_modules/pngjs/lib/interlace.js"(exports) {
    "use strict";
    var imagePasses = [
      {
        x: [0],
        y: [0]
      },
      {
        x: [4],
        y: [0]
      },
      {
        x: [0, 4],
        y: [4]
      },
      {
        x: [2, 6],
        y: [0, 4]
      },
      {
        x: [0, 2, 4, 6],
        y: [2, 6]
      },
      {
        x: [1, 3, 5, 7],
        y: [0, 2, 4, 6]
      },
      {
        x: [0, 1, 2, 3, 4, 5, 6, 7],
        y: [1, 3, 5, 7]
      }
    ];
    exports.getImagePasses = function(width, height) {
      let images = [];
      let xLeftOver = width % 8;
      let yLeftOver = height % 8;
      let xRepeats = (width - xLeftOver) / 8;
      let yRepeats = (height - yLeftOver) / 8;
      for (let i2 = 0; i2 < imagePasses.length; i2++) {
        let pass = imagePasses[i2];
        let passWidth = xRepeats * pass.x.length;
        let passHeight = yRepeats * pass.y.length;
        for (let j = 0; j < pass.x.length; j++) {
          if (pass.x[j] < xLeftOver) {
            passWidth++;
          } else {
            break;
          }
        }
        for (let j = 0; j < pass.y.length; j++) {
          if (pass.y[j] < yLeftOver) {
            passHeight++;
          } else {
            break;
          }
        }
        if (passWidth > 0 && passHeight > 0) {
          images.push({ width: passWidth, height: passHeight, index: i2 });
        }
      }
      return images;
    };
    exports.getInterlaceIterator = function(width) {
      return function(x2, y, pass) {
        let outerXLeftOver = x2 % imagePasses[pass].x.length;
        let outerX = (x2 - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
        let outerYLeftOver = y % imagePasses[pass].y.length;
        let outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
        return outerX * 4 + outerY * width * 4;
      };
    };
  }
});

// node_modules/pngjs/lib/paeth-predictor.js
var require_paeth_predictor = __commonJS({
  "node_modules/pngjs/lib/paeth-predictor.js"(exports, module2) {
    "use strict";
    module2.exports = function paethPredictor(left, above, upLeft) {
      let paeth = left + above - upLeft;
      let pLeft = Math.abs(paeth - left);
      let pAbove = Math.abs(paeth - above);
      let pUpLeft = Math.abs(paeth - upLeft);
      if (pLeft <= pAbove && pLeft <= pUpLeft) {
        return left;
      }
      if (pAbove <= pUpLeft) {
        return above;
      }
      return upLeft;
    };
  }
});

// node_modules/pngjs/lib/filter-parse.js
var require_filter_parse = __commonJS({
  "node_modules/pngjs/lib/filter-parse.js"(exports, module2) {
    "use strict";
    var interlaceUtils = require_interlace();
    var paethPredictor = require_paeth_predictor();
    function getByteWidth(width, bpp, depth) {
      let byteWidth = width * bpp;
      if (depth !== 8) {
        byteWidth = Math.ceil(byteWidth / (8 / depth));
      }
      return byteWidth;
    }
    var Filter = module2.exports = function(bitmapInfo, dependencies) {
      let width = bitmapInfo.width;
      let height = bitmapInfo.height;
      let interlace = bitmapInfo.interlace;
      let bpp = bitmapInfo.bpp;
      let depth = bitmapInfo.depth;
      this.read = dependencies.read;
      this.write = dependencies.write;
      this.complete = dependencies.complete;
      this._imageIndex = 0;
      this._images = [];
      if (interlace) {
        let passes = interlaceUtils.getImagePasses(width, height);
        for (let i2 = 0; i2 < passes.length; i2++) {
          this._images.push({
            byteWidth: getByteWidth(passes[i2].width, bpp, depth),
            height: passes[i2].height,
            lineIndex: 0
          });
        }
      } else {
        this._images.push({
          byteWidth: getByteWidth(width, bpp, depth),
          height,
          lineIndex: 0
        });
      }
      if (depth === 8) {
        this._xComparison = bpp;
      } else if (depth === 16) {
        this._xComparison = bpp * 2;
      } else {
        this._xComparison = 1;
      }
    };
    Filter.prototype.start = function() {
      this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
    };
    Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let rawByte = rawData[1 + x2];
        let f1Left = x2 > xBiggerThan ? unfilteredLine[x2 - xComparison] : 0;
        unfilteredLine[x2] = rawByte + f1Left;
      }
    };
    Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
      let lastLine = this._lastLine;
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let rawByte = rawData[1 + x2];
        let f2Up = lastLine ? lastLine[x2] : 0;
        unfilteredLine[x2] = rawByte + f2Up;
      }
    };
    Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      let lastLine = this._lastLine;
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let rawByte = rawData[1 + x2];
        let f3Up = lastLine ? lastLine[x2] : 0;
        let f3Left = x2 > xBiggerThan ? unfilteredLine[x2 - xComparison] : 0;
        let f3Add = Math.floor((f3Left + f3Up) / 2);
        unfilteredLine[x2] = rawByte + f3Add;
      }
    };
    Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      let lastLine = this._lastLine;
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let rawByte = rawData[1 + x2];
        let f4Up = lastLine ? lastLine[x2] : 0;
        let f4Left = x2 > xBiggerThan ? unfilteredLine[x2 - xComparison] : 0;
        let f4UpLeft = x2 > xBiggerThan && lastLine ? lastLine[x2 - xComparison] : 0;
        let f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
        unfilteredLine[x2] = rawByte + f4Add;
      }
    };
    Filter.prototype._reverseFilterLine = function(rawData) {
      let filter = rawData[0];
      let unfilteredLine;
      let currentImage = this._images[this._imageIndex];
      let byteWidth = currentImage.byteWidth;
      if (filter === 0) {
        unfilteredLine = rawData.slice(1, byteWidth + 1);
      } else {
        unfilteredLine = Buffer.alloc(byteWidth);
        switch (filter) {
          case 1:
            this._unFilterType1(rawData, unfilteredLine, byteWidth);
            break;
          case 2:
            this._unFilterType2(rawData, unfilteredLine, byteWidth);
            break;
          case 3:
            this._unFilterType3(rawData, unfilteredLine, byteWidth);
            break;
          case 4:
            this._unFilterType4(rawData, unfilteredLine, byteWidth);
            break;
          default:
            throw new Error("Unrecognised filter type - " + filter);
        }
      }
      this.write(unfilteredLine);
      currentImage.lineIndex++;
      if (currentImage.lineIndex >= currentImage.height) {
        this._lastLine = null;
        this._imageIndex++;
        currentImage = this._images[this._imageIndex];
      } else {
        this._lastLine = unfilteredLine;
      }
      if (currentImage) {
        this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
      } else {
        this._lastLine = null;
        this.complete();
      }
    };
  }
});

// node_modules/pngjs/lib/filter-parse-async.js
var require_filter_parse_async = __commonJS({
  "node_modules/pngjs/lib/filter-parse-async.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var ChunkStream = require_chunkstream();
    var Filter = require_filter_parse();
    var FilterAsync = module2.exports = function(bitmapInfo) {
      ChunkStream.call(this);
      let buffers = [];
      let that = this;
      this._filter = new Filter(bitmapInfo, {
        read: this.read.bind(this),
        write: function(buffer) {
          buffers.push(buffer);
        },
        complete: function() {
          that.emit("complete", Buffer.concat(buffers));
        }
      });
      this._filter.start();
    };
    util.inherits(FilterAsync, ChunkStream);
  }
});

// node_modules/pngjs/lib/constants.js
var require_constants = __commonJS({
  "node_modules/pngjs/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
      TYPE_IHDR: 1229472850,
      TYPE_IEND: 1229278788,
      TYPE_IDAT: 1229209940,
      TYPE_PLTE: 1347179589,
      TYPE_tRNS: 1951551059,
      TYPE_gAMA: 1732332865,
      COLORTYPE_GRAYSCALE: 0,
      COLORTYPE_PALETTE: 1,
      COLORTYPE_COLOR: 2,
      COLORTYPE_ALPHA: 4,
      COLORTYPE_PALETTE_COLOR: 3,
      COLORTYPE_COLOR_ALPHA: 6,
      COLORTYPE_TO_BPP_MAP: {
        0: 1,
        2: 3,
        3: 1,
        4: 2,
        6: 4
      },
      GAMMA_DIVISION: 1e5
    };
  }
});

// node_modules/pngjs/lib/crc.js
var require_crc = __commonJS({
  "node_modules/pngjs/lib/crc.js"(exports, module2) {
    "use strict";
    var crcTable = [];
    (function() {
      for (let i2 = 0; i2 < 256; i2++) {
        let currentCrc = i2;
        for (let j = 0; j < 8; j++) {
          if (currentCrc & 1) {
            currentCrc = 3988292384 ^ currentCrc >>> 1;
          } else {
            currentCrc = currentCrc >>> 1;
          }
        }
        crcTable[i2] = currentCrc;
      }
    })();
    var CrcCalculator = module2.exports = function() {
      this._crc = -1;
    };
    CrcCalculator.prototype.write = function(data) {
      for (let i2 = 0; i2 < data.length; i2++) {
        this._crc = crcTable[(this._crc ^ data[i2]) & 255] ^ this._crc >>> 8;
      }
      return true;
    };
    CrcCalculator.prototype.crc32 = function() {
      return this._crc ^ -1;
    };
    CrcCalculator.crc32 = function(buf) {
      let crc = -1;
      for (let i2 = 0; i2 < buf.length; i2++) {
        crc = crcTable[(crc ^ buf[i2]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    };
  }
});

// node_modules/pngjs/lib/parser.js
var require_parser = __commonJS({
  "node_modules/pngjs/lib/parser.js"(exports, module2) {
    "use strict";
    var constants = require_constants();
    var CrcCalculator = require_crc();
    var Parser = module2.exports = function(options, dependencies) {
      this._options = options;
      options.checkCRC = options.checkCRC !== false;
      this._hasIHDR = false;
      this._hasIEND = false;
      this._emittedHeadersFinished = false;
      this._palette = [];
      this._colorType = 0;
      this._chunks = {};
      this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
      this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
      this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
      this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
      this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
      this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);
      this.read = dependencies.read;
      this.error = dependencies.error;
      this.metadata = dependencies.metadata;
      this.gamma = dependencies.gamma;
      this.transColor = dependencies.transColor;
      this.palette = dependencies.palette;
      this.parsed = dependencies.parsed;
      this.inflateData = dependencies.inflateData;
      this.finished = dependencies.finished;
      this.simpleTransparency = dependencies.simpleTransparency;
      this.headersFinished = dependencies.headersFinished || function() {
      };
    };
    Parser.prototype.start = function() {
      this.read(constants.PNG_SIGNATURE.length, this._parseSignature.bind(this));
    };
    Parser.prototype._parseSignature = function(data) {
      let signature = constants.PNG_SIGNATURE;
      for (let i2 = 0; i2 < signature.length; i2++) {
        if (data[i2] !== signature[i2]) {
          this.error(new Error("Invalid file signature"));
          return;
        }
      }
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._parseChunkBegin = function(data) {
      let length = data.readUInt32BE(0);
      let type = data.readUInt32BE(4);
      let name = "";
      for (let i2 = 4; i2 < 8; i2++) {
        name += String.fromCharCode(data[i2]);
      }
      let ancillary = Boolean(data[4] & 32);
      if (!this._hasIHDR && type !== constants.TYPE_IHDR) {
        this.error(new Error("Expected IHDR on beggining"));
        return;
      }
      this._crc = new CrcCalculator();
      this._crc.write(Buffer.from(name));
      if (this._chunks[type]) {
        return this._chunks[type](length);
      }
      if (!ancillary) {
        this.error(new Error("Unsupported critical chunk type " + name));
        return;
      }
      this.read(length + 4, this._skipChunk.bind(this));
    };
    Parser.prototype._skipChunk = function() {
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._handleChunkEnd = function() {
      this.read(4, this._parseChunkEnd.bind(this));
    };
    Parser.prototype._parseChunkEnd = function(data) {
      let fileCrc = data.readInt32BE(0);
      let calcCrc = this._crc.crc32();
      if (this._options.checkCRC && calcCrc !== fileCrc) {
        this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
        return;
      }
      if (!this._hasIEND) {
        this.read(8, this._parseChunkBegin.bind(this));
      }
    };
    Parser.prototype._handleIHDR = function(length) {
      this.read(length, this._parseIHDR.bind(this));
    };
    Parser.prototype._parseIHDR = function(data) {
      this._crc.write(data);
      let width = data.readUInt32BE(0);
      let height = data.readUInt32BE(4);
      let depth = data[8];
      let colorType = data[9];
      let compr = data[10];
      let filter = data[11];
      let interlace = data[12];
      if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
        this.error(new Error("Unsupported bit depth " + depth));
        return;
      }
      if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {
        this.error(new Error("Unsupported color type"));
        return;
      }
      if (compr !== 0) {
        this.error(new Error("Unsupported compression method"));
        return;
      }
      if (filter !== 0) {
        this.error(new Error("Unsupported filter method"));
        return;
      }
      if (interlace !== 0 && interlace !== 1) {
        this.error(new Error("Unsupported interlace method"));
        return;
      }
      this._colorType = colorType;
      let bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];
      this._hasIHDR = true;
      this.metadata({
        width,
        height,
        depth,
        interlace: Boolean(interlace),
        palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
        color: Boolean(colorType & constants.COLORTYPE_COLOR),
        alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
        bpp,
        colorType
      });
      this._handleChunkEnd();
    };
    Parser.prototype._handlePLTE = function(length) {
      this.read(length, this._parsePLTE.bind(this));
    };
    Parser.prototype._parsePLTE = function(data) {
      this._crc.write(data);
      let entries = Math.floor(data.length / 3);
      for (let i2 = 0; i2 < entries; i2++) {
        this._palette.push([data[i2 * 3], data[i2 * 3 + 1], data[i2 * 3 + 2], 255]);
      }
      this.palette(this._palette);
      this._handleChunkEnd();
    };
    Parser.prototype._handleTRNS = function(length) {
      this.simpleTransparency();
      this.read(length, this._parseTRNS.bind(this));
    };
    Parser.prototype._parseTRNS = function(data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
        if (this._palette.length === 0) {
          this.error(new Error("Transparency chunk must be after palette"));
          return;
        }
        if (data.length > this._palette.length) {
          this.error(new Error("More transparent colors than palette size"));
          return;
        }
        for (let i2 = 0; i2 < data.length; i2++) {
          this._palette[i2][3] = data[i2];
        }
        this.palette(this._palette);
      }
      if (this._colorType === constants.COLORTYPE_GRAYSCALE) {
        this.transColor([data.readUInt16BE(0)]);
      }
      if (this._colorType === constants.COLORTYPE_COLOR) {
        this.transColor([
          data.readUInt16BE(0),
          data.readUInt16BE(2),
          data.readUInt16BE(4)
        ]);
      }
      this._handleChunkEnd();
    };
    Parser.prototype._handleGAMA = function(length) {
      this.read(length, this._parseGAMA.bind(this));
    };
    Parser.prototype._parseGAMA = function(data) {
      this._crc.write(data);
      this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);
      this._handleChunkEnd();
    };
    Parser.prototype._handleIDAT = function(length) {
      if (!this._emittedHeadersFinished) {
        this._emittedHeadersFinished = true;
        this.headersFinished();
      }
      this.read(-length, this._parseIDAT.bind(this, length));
    };
    Parser.prototype._parseIDAT = function(length, data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
        throw new Error("Expected palette not found");
      }
      this.inflateData(data);
      let leftOverLength = length - data.length;
      if (leftOverLength > 0) {
        this._handleIDAT(leftOverLength);
      } else {
        this._handleChunkEnd();
      }
    };
    Parser.prototype._handleIEND = function(length) {
      this.read(length, this._parseIEND.bind(this));
    };
    Parser.prototype._parseIEND = function(data) {
      this._crc.write(data);
      this._hasIEND = true;
      this._handleChunkEnd();
      if (this.finished) {
        this.finished();
      }
    };
  }
});

// node_modules/pngjs/lib/bitmapper.js
var require_bitmapper = __commonJS({
  "node_modules/pngjs/lib/bitmapper.js"(exports) {
    "use strict";
    var interlaceUtils = require_interlace();
    var pixelBppMapper = [
      function() {
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos === data.length) {
          throw new Error("Ran out of data");
        }
        let pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = 255;
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 1 >= data.length) {
          throw new Error("Ran out of data");
        }
        let pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = data[rawPos + 1];
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 2 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = 255;
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 3 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = data[rawPos + 3];
      }
    ];
    var pixelBppCustomMapper = [
      function() {
      },
      function(pxData, pixelData, pxPos, maxBit) {
        let pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = maxBit;
      },
      function(pxData, pixelData, pxPos) {
        let pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = pixelData[1];
      },
      function(pxData, pixelData, pxPos, maxBit) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = maxBit;
      },
      function(pxData, pixelData, pxPos) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = pixelData[3];
      }
    ];
    function bitRetriever(data, depth) {
      let leftOver = [];
      let i2 = 0;
      function split() {
        if (i2 === data.length) {
          throw new Error("Ran out of data");
        }
        let byte = data[i2];
        i2++;
        let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
        switch (depth) {
          default:
            throw new Error("unrecognised depth");
          case 16:
            byte2 = data[i2];
            i2++;
            leftOver.push((byte << 8) + byte2);
            break;
          case 4:
            byte2 = byte & 15;
            byte1 = byte >> 4;
            leftOver.push(byte1, byte2);
            break;
          case 2:
            byte4 = byte & 3;
            byte3 = byte >> 2 & 3;
            byte2 = byte >> 4 & 3;
            byte1 = byte >> 6 & 3;
            leftOver.push(byte1, byte2, byte3, byte4);
            break;
          case 1:
            byte8 = byte & 1;
            byte7 = byte >> 1 & 1;
            byte6 = byte >> 2 & 1;
            byte5 = byte >> 3 & 1;
            byte4 = byte >> 4 & 1;
            byte3 = byte >> 5 & 1;
            byte2 = byte >> 6 & 1;
            byte1 = byte >> 7 & 1;
            leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
            break;
        }
      }
      return {
        get: function(count) {
          while (leftOver.length < count) {
            split();
          }
          let returner = leftOver.slice(0, count);
          leftOver = leftOver.slice(count);
          return returner;
        },
        resetAfterLine: function() {
          leftOver.length = 0;
        },
        end: function() {
          if (i2 !== data.length) {
            throw new Error("extra data found");
          }
        }
      };
    }
    function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
      let imageWidth = image.width;
      let imageHeight = image.height;
      let imagePass = image.index;
      for (let y = 0; y < imageHeight; y++) {
        for (let x2 = 0; x2 < imageWidth; x2++) {
          let pxPos = getPxPos(x2, y, imagePass);
          pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
          rawPos += bpp;
        }
      }
      return rawPos;
    }
    function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
      let imageWidth = image.width;
      let imageHeight = image.height;
      let imagePass = image.index;
      for (let y = 0; y < imageHeight; y++) {
        for (let x2 = 0; x2 < imageWidth; x2++) {
          let pixelData = bits.get(bpp);
          let pxPos = getPxPos(x2, y, imagePass);
          pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
        }
        bits.resetAfterLine();
      }
    }
    exports.dataToBitMap = function(data, bitmapInfo) {
      let width = bitmapInfo.width;
      let height = bitmapInfo.height;
      let depth = bitmapInfo.depth;
      let bpp = bitmapInfo.bpp;
      let interlace = bitmapInfo.interlace;
      let bits;
      if (depth !== 8) {
        bits = bitRetriever(data, depth);
      }
      let pxData;
      if (depth <= 8) {
        pxData = Buffer.alloc(width * height * 4);
      } else {
        pxData = new Uint16Array(width * height * 4);
      }
      let maxBit = Math.pow(2, depth) - 1;
      let rawPos = 0;
      let images;
      let getPxPos;
      if (interlace) {
        images = interlaceUtils.getImagePasses(width, height);
        getPxPos = interlaceUtils.getInterlaceIterator(width, height);
      } else {
        let nonInterlacedPxPos = 0;
        getPxPos = function() {
          let returner = nonInterlacedPxPos;
          nonInterlacedPxPos += 4;
          return returner;
        };
        images = [{ width, height }];
      }
      for (let imageIndex = 0; imageIndex < images.length; imageIndex++) {
        if (depth === 8) {
          rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);
        } else {
          mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
        }
      }
      if (depth === 8) {
        if (rawPos !== data.length) {
          throw new Error("extra data found");
        }
      } else {
        bits.end();
      }
      return pxData;
    };
  }
});

// node_modules/pngjs/lib/format-normaliser.js
var require_format_normaliser = __commonJS({
  "node_modules/pngjs/lib/format-normaliser.js"(exports, module2) {
    "use strict";
    function dePalette(indata, outdata, width, height, palette) {
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x2 = 0; x2 < width; x2++) {
          let color = palette[indata[pxPos]];
          if (!color) {
            throw new Error("index " + indata[pxPos] + " not in palette");
          }
          for (let i2 = 0; i2 < 4; i2++) {
            outdata[pxPos + i2] = color[i2];
          }
          pxPos += 4;
        }
      }
    }
    function replaceTransparentColor(indata, outdata, width, height, transColor) {
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x2 = 0; x2 < width; x2++) {
          let makeTrans = false;
          if (transColor.length === 1) {
            if (transColor[0] === indata[pxPos]) {
              makeTrans = true;
            }
          } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
            makeTrans = true;
          }
          if (makeTrans) {
            for (let i2 = 0; i2 < 4; i2++) {
              outdata[pxPos + i2] = 0;
            }
          }
          pxPos += 4;
        }
      }
    }
    function scaleDepth(indata, outdata, width, height, depth) {
      let maxOutSample = 255;
      let maxInSample = Math.pow(2, depth) - 1;
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x2 = 0; x2 < width; x2++) {
          for (let i2 = 0; i2 < 4; i2++) {
            outdata[pxPos + i2] = Math.floor(indata[pxPos + i2] * maxOutSample / maxInSample + 0.5);
          }
          pxPos += 4;
        }
      }
    }
    module2.exports = function(indata, imageData) {
      let depth = imageData.depth;
      let width = imageData.width;
      let height = imageData.height;
      let colorType = imageData.colorType;
      let transColor = imageData.transColor;
      let palette = imageData.palette;
      let outdata = indata;
      if (colorType === 3) {
        dePalette(indata, outdata, width, height, palette);
      } else {
        if (transColor) {
          replaceTransparentColor(indata, outdata, width, height, transColor);
        }
        if (depth !== 8) {
          if (depth === 16) {
            outdata = Buffer.alloc(width * height * 4);
          }
          scaleDepth(indata, outdata, width, height, depth);
        }
      }
      return outdata;
    };
  }
});

// node_modules/pngjs/lib/parser-async.js
var require_parser_async = __commonJS({
  "node_modules/pngjs/lib/parser-async.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var zlib2 = require("zlib");
    var ChunkStream = require_chunkstream();
    var FilterAsync = require_filter_parse_async();
    var Parser = require_parser();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    var ParserAsync = module2.exports = function(options) {
      ChunkStream.call(this);
      this._parser = new Parser(options, {
        read: this.read.bind(this),
        error: this._handleError.bind(this),
        metadata: this._handleMetaData.bind(this),
        gamma: this.emit.bind(this, "gamma"),
        palette: this._handlePalette.bind(this),
        transColor: this._handleTransColor.bind(this),
        finished: this._finished.bind(this),
        inflateData: this._inflateData.bind(this),
        simpleTransparency: this._simpleTransparency.bind(this),
        headersFinished: this._headersFinished.bind(this)
      });
      this._options = options;
      this.writable = true;
      this._parser.start();
    };
    util.inherits(ParserAsync, ChunkStream);
    ParserAsync.prototype._handleError = function(err) {
      this.emit("error", err);
      this.writable = false;
      this.destroy();
      if (this._inflate && this._inflate.destroy) {
        this._inflate.destroy();
      }
      if (this._filter) {
        this._filter.destroy();
        this._filter.on("error", function() {
        });
      }
      this.errord = true;
    };
    ParserAsync.prototype._inflateData = function(data) {
      if (!this._inflate) {
        if (this._bitmapInfo.interlace) {
          this._inflate = zlib2.createInflate();
          this._inflate.on("error", this.emit.bind(this, "error"));
          this._filter.on("complete", this._complete.bind(this));
          this._inflate.pipe(this._filter);
        } else {
          let rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
          let imageSize = rowSize * this._bitmapInfo.height;
          let chunkSize = Math.max(imageSize, zlib2.Z_MIN_CHUNK);
          this._inflate = zlib2.createInflate({ chunkSize });
          let leftToInflate = imageSize;
          let emitError = this.emit.bind(this, "error");
          this._inflate.on("error", function(err) {
            if (!leftToInflate) {
              return;
            }
            emitError(err);
          });
          this._filter.on("complete", this._complete.bind(this));
          let filterWrite = this._filter.write.bind(this._filter);
          this._inflate.on("data", function(chunk) {
            if (!leftToInflate) {
              return;
            }
            if (chunk.length > leftToInflate) {
              chunk = chunk.slice(0, leftToInflate);
            }
            leftToInflate -= chunk.length;
            filterWrite(chunk);
          });
          this._inflate.on("end", this._filter.end.bind(this._filter));
        }
      }
      this._inflate.write(data);
    };
    ParserAsync.prototype._handleMetaData = function(metaData) {
      this._metaData = metaData;
      this._bitmapInfo = Object.create(metaData);
      this._filter = new FilterAsync(this._bitmapInfo);
    };
    ParserAsync.prototype._handleTransColor = function(transColor) {
      this._bitmapInfo.transColor = transColor;
    };
    ParserAsync.prototype._handlePalette = function(palette) {
      this._bitmapInfo.palette = palette;
    };
    ParserAsync.prototype._simpleTransparency = function() {
      this._metaData.alpha = true;
    };
    ParserAsync.prototype._headersFinished = function() {
      this.emit("metadata", this._metaData);
    };
    ParserAsync.prototype._finished = function() {
      if (this.errord) {
        return;
      }
      if (!this._inflate) {
        this.emit("error", "No Inflate block");
      } else {
        this._inflate.end();
      }
    };
    ParserAsync.prototype._complete = function(filteredData) {
      if (this.errord) {
        return;
      }
      let normalisedBitmapData;
      try {
        let bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);
        normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);
        bitmapData = null;
      } catch (ex) {
        this._handleError(ex);
        return;
      }
      this.emit("parsed", normalisedBitmapData);
    };
  }
});

// node_modules/pngjs/lib/bitpacker.js
var require_bitpacker = __commonJS({
  "node_modules/pngjs/lib/bitpacker.js"(exports, module2) {
    "use strict";
    var constants = require_constants();
    module2.exports = function(dataIn, width, height, options) {
      let outHasAlpha = [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;
      if (options.colorType === options.inputColorType) {
        let bigEndian = function() {
          let buffer = new ArrayBuffer(2);
          new DataView(buffer).setInt16(0, 256, true);
          return new Int16Array(buffer)[0] !== 256;
        }();
        if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {
          return dataIn;
        }
      }
      let data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
      let maxValue = 255;
      let inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];
      if (inBpp === 4 && !options.inputHasAlpha) {
        inBpp = 3;
      }
      let outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];
      if (options.bitDepth === 16) {
        maxValue = 65535;
        outBpp *= 2;
      }
      let outData = Buffer.alloc(width * height * outBpp);
      let inIndex = 0;
      let outIndex = 0;
      let bgColor = options.bgColor || {};
      if (bgColor.red === void 0) {
        bgColor.red = maxValue;
      }
      if (bgColor.green === void 0) {
        bgColor.green = maxValue;
      }
      if (bgColor.blue === void 0) {
        bgColor.blue = maxValue;
      }
      function getRGBA() {
        let red;
        let green;
        let blue;
        let alpha = maxValue;
        switch (options.inputColorType) {
          case constants.COLORTYPE_COLOR_ALPHA:
            alpha = data[inIndex + 3];
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants.COLORTYPE_COLOR:
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants.COLORTYPE_ALPHA:
            alpha = data[inIndex + 1];
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          case constants.COLORTYPE_GRAYSCALE:
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          default:
            throw new Error("input color type:" + options.inputColorType + " is not supported at present");
        }
        if (options.inputHasAlpha) {
          if (!outHasAlpha) {
            alpha /= maxValue;
            red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);
            green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);
            blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);
          }
        }
        return { red, green, blue, alpha };
      }
      for (let y = 0; y < height; y++) {
        for (let x2 = 0; x2 < width; x2++) {
          let rgba = getRGBA(data, inIndex);
          switch (options.colorType) {
            case constants.COLORTYPE_COLOR_ALPHA:
            case constants.COLORTYPE_COLOR:
              if (options.bitDepth === 8) {
                outData[outIndex] = rgba.red;
                outData[outIndex + 1] = rgba.green;
                outData[outIndex + 2] = rgba.blue;
                if (outHasAlpha) {
                  outData[outIndex + 3] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(rgba.red, outIndex);
                outData.writeUInt16BE(rgba.green, outIndex + 2);
                outData.writeUInt16BE(rgba.blue, outIndex + 4);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 6);
                }
              }
              break;
            case constants.COLORTYPE_ALPHA:
            case constants.COLORTYPE_GRAYSCALE: {
              let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
              if (options.bitDepth === 8) {
                outData[outIndex] = grayscale;
                if (outHasAlpha) {
                  outData[outIndex + 1] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(grayscale, outIndex);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 2);
                }
              }
              break;
            }
            default:
              throw new Error("unrecognised color Type " + options.colorType);
          }
          inIndex += inBpp;
          outIndex += outBpp;
        }
      }
      return outData;
    };
  }
});

// node_modules/pngjs/lib/filter-pack.js
var require_filter_pack = __commonJS({
  "node_modules/pngjs/lib/filter-pack.js"(exports, module2) {
    "use strict";
    var paethPredictor = require_paeth_predictor();
    function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (let x2 = 0; x2 < byteWidth; x2++) {
        rawData[rawPos + x2] = pxData[pxPos + x2];
      }
    }
    function filterSumNone(pxData, pxPos, byteWidth) {
      let sum = 0;
      let length = pxPos + byteWidth;
      for (let i2 = pxPos; i2 < length; i2++) {
        sum += Math.abs(pxData[i2]);
      }
      return sum;
    }
    function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
        let val = pxData[pxPos + x2] - left;
        rawData[rawPos + x2] = val;
      }
    }
    function filterSumSub(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
        let val = pxData[pxPos + x2] - left;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let up = pxPos > 0 ? pxData[pxPos + x2 - byteWidth] : 0;
        let val = pxData[pxPos + x2] - up;
        rawData[rawPos + x2] = val;
      }
    }
    function filterSumUp(pxData, pxPos, byteWidth) {
      let sum = 0;
      let length = pxPos + byteWidth;
      for (let x2 = pxPos; x2 < length; x2++) {
        let up = pxPos > 0 ? pxData[x2 - byteWidth] : 0;
        let val = pxData[x2] - up;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x2 - byteWidth] : 0;
        let val = pxData[pxPos + x2] - (left + up >> 1);
        rawData[rawPos + x2] = val;
      }
    }
    function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x2 - byteWidth] : 0;
        let val = pxData[pxPos + x2] - (left + up >> 1);
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x2 - byteWidth] : 0;
        let upleft = pxPos > 0 && x2 >= bpp ? pxData[pxPos + x2 - (byteWidth + bpp)] : 0;
        let val = pxData[pxPos + x2] - paethPredictor(left, up, upleft);
        rawData[rawPos + x2] = val;
      }
    }
    function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x2 = 0; x2 < byteWidth; x2++) {
        let left = x2 >= bpp ? pxData[pxPos + x2 - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x2 - byteWidth] : 0;
        let upleft = pxPos > 0 && x2 >= bpp ? pxData[pxPos + x2 - (byteWidth + bpp)] : 0;
        let val = pxData[pxPos + x2] - paethPredictor(left, up, upleft);
        sum += Math.abs(val);
      }
      return sum;
    }
    var filters = {
      0: filterNone,
      1: filterSub,
      2: filterUp,
      3: filterAvg,
      4: filterPaeth
    };
    var filterSums = {
      0: filterSumNone,
      1: filterSumSub,
      2: filterSumUp,
      3: filterSumAvg,
      4: filterSumPaeth
    };
    module2.exports = function(pxData, width, height, options, bpp) {
      let filterTypes;
      if (!("filterType" in options) || options.filterType === -1) {
        filterTypes = [0, 1, 2, 3, 4];
      } else if (typeof options.filterType === "number") {
        filterTypes = [options.filterType];
      } else {
        throw new Error("unrecognised filter types");
      }
      if (options.bitDepth === 16) {
        bpp *= 2;
      }
      let byteWidth = width * bpp;
      let rawPos = 0;
      let pxPos = 0;
      let rawData = Buffer.alloc((byteWidth + 1) * height);
      let sel = filterTypes[0];
      for (let y = 0; y < height; y++) {
        if (filterTypes.length > 1) {
          let min = Infinity;
          for (let i2 = 0; i2 < filterTypes.length; i2++) {
            let sum = filterSums[filterTypes[i2]](pxData, pxPos, byteWidth, bpp);
            if (sum < min) {
              sel = filterTypes[i2];
              min = sum;
            }
          }
        }
        rawData[rawPos] = sel;
        rawPos++;
        filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
        rawPos += byteWidth;
        pxPos += byteWidth;
      }
      return rawData;
    };
  }
});

// node_modules/pngjs/lib/packer.js
var require_packer = __commonJS({
  "node_modules/pngjs/lib/packer.js"(exports, module2) {
    "use strict";
    var constants = require_constants();
    var CrcStream = require_crc();
    var bitPacker = require_bitpacker();
    var filter = require_filter_pack();
    var zlib2 = require("zlib");
    var Packer = module2.exports = function(options) {
      this._options = options;
      options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
      options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
      options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
      options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
      options.deflateFactory = options.deflateFactory || zlib2.createDeflate;
      options.bitDepth = options.bitDepth || 8;
      options.colorType = typeof options.colorType === "number" ? options.colorType : constants.COLORTYPE_COLOR_ALPHA;
      options.inputColorType = typeof options.inputColorType === "number" ? options.inputColorType : constants.COLORTYPE_COLOR_ALPHA;
      if ([
        constants.COLORTYPE_GRAYSCALE,
        constants.COLORTYPE_COLOR,
        constants.COLORTYPE_COLOR_ALPHA,
        constants.COLORTYPE_ALPHA
      ].indexOf(options.colorType) === -1) {
        throw new Error("option color type:" + options.colorType + " is not supported at present");
      }
      if ([
        constants.COLORTYPE_GRAYSCALE,
        constants.COLORTYPE_COLOR,
        constants.COLORTYPE_COLOR_ALPHA,
        constants.COLORTYPE_ALPHA
      ].indexOf(options.inputColorType) === -1) {
        throw new Error("option input color type:" + options.inputColorType + " is not supported at present");
      }
      if (options.bitDepth !== 8 && options.bitDepth !== 16) {
        throw new Error("option bit depth:" + options.bitDepth + " is not supported at present");
      }
    };
    Packer.prototype.getDeflateOptions = function() {
      return {
        chunkSize: this._options.deflateChunkSize,
        level: this._options.deflateLevel,
        strategy: this._options.deflateStrategy
      };
    };
    Packer.prototype.createDeflate = function() {
      return this._options.deflateFactory(this.getDeflateOptions());
    };
    Packer.prototype.filterData = function(data, width, height) {
      let packedData = bitPacker(data, width, height, this._options);
      let bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
      let filteredData = filter(packedData, width, height, this._options, bpp);
      return filteredData;
    };
    Packer.prototype._packChunk = function(type, data) {
      let len = data ? data.length : 0;
      let buf = Buffer.alloc(len + 12);
      buf.writeUInt32BE(len, 0);
      buf.writeUInt32BE(type, 4);
      if (data) {
        data.copy(buf, 8);
      }
      buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
      return buf;
    };
    Packer.prototype.packGAMA = function(gamma) {
      let buf = Buffer.alloc(4);
      buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);
      return this._packChunk(constants.TYPE_gAMA, buf);
    };
    Packer.prototype.packIHDR = function(width, height) {
      let buf = Buffer.alloc(13);
      buf.writeUInt32BE(width, 0);
      buf.writeUInt32BE(height, 4);
      buf[8] = this._options.bitDepth;
      buf[9] = this._options.colorType;
      buf[10] = 0;
      buf[11] = 0;
      buf[12] = 0;
      return this._packChunk(constants.TYPE_IHDR, buf);
    };
    Packer.prototype.packIDAT = function(data) {
      return this._packChunk(constants.TYPE_IDAT, data);
    };
    Packer.prototype.packIEND = function() {
      return this._packChunk(constants.TYPE_IEND, null);
    };
  }
});

// node_modules/pngjs/lib/packer-async.js
var require_packer_async = __commonJS({
  "node_modules/pngjs/lib/packer-async.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var Stream2 = require("stream");
    var constants = require_constants();
    var Packer = require_packer();
    var PackerAsync = module2.exports = function(opt) {
      Stream2.call(this);
      let options = opt || {};
      this._packer = new Packer(options);
      this._deflate = this._packer.createDeflate();
      this.readable = true;
    };
    util.inherits(PackerAsync, Stream2);
    PackerAsync.prototype.pack = function(data, width, height, gamma) {
      this.emit("data", Buffer.from(constants.PNG_SIGNATURE));
      this.emit("data", this._packer.packIHDR(width, height));
      if (gamma) {
        this.emit("data", this._packer.packGAMA(gamma));
      }
      let filteredData = this._packer.filterData(data, width, height);
      this._deflate.on("error", this.emit.bind(this, "error"));
      this._deflate.on("data", function(compressedData) {
        this.emit("data", this._packer.packIDAT(compressedData));
      }.bind(this));
      this._deflate.on("end", function() {
        this.emit("data", this._packer.packIEND());
        this.emit("end");
      }.bind(this));
      this._deflate.end(filteredData);
    };
  }
});

// node_modules/pngjs/lib/sync-inflate.js
var require_sync_inflate = __commonJS({
  "node_modules/pngjs/lib/sync-inflate.js"(exports, module2) {
    "use strict";
    var assert = require("assert").ok;
    var zlib2 = require("zlib");
    var util = require("util");
    var kMaxLength = require("buffer").kMaxLength;
    function Inflate(opts) {
      if (!(this instanceof Inflate)) {
        return new Inflate(opts);
      }
      if (opts && opts.chunkSize < zlib2.Z_MIN_CHUNK) {
        opts.chunkSize = zlib2.Z_MIN_CHUNK;
      }
      zlib2.Inflate.call(this, opts);
      this._offset = this._offset === void 0 ? this._outOffset : this._offset;
      this._buffer = this._buffer || this._outBuffer;
      if (opts && opts.maxLength != null) {
        this._maxLength = opts.maxLength;
      }
    }
    function createInflate(opts) {
      return new Inflate(opts);
    }
    function _close(engine, callback) {
      if (callback) {
        process.nextTick(callback);
      }
      if (!engine._handle) {
        return;
      }
      engine._handle.close();
      engine._handle = null;
    }
    Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
      if (typeof asyncCb === "function") {
        return zlib2.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
      }
      let self2 = this;
      let availInBefore = chunk && chunk.length;
      let availOutBefore = this._chunkSize - this._offset;
      let leftToInflate = this._maxLength;
      let inOff = 0;
      let buffers = [];
      let nread = 0;
      let error2;
      this.on("error", function(err) {
        error2 = err;
      });
      function handleChunk(availInAfter, availOutAfter) {
        if (self2._hadError) {
          return;
        }
        let have = availOutBefore - availOutAfter;
        assert(have >= 0, "have should not go down");
        if (have > 0) {
          let out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (out.length > leftToInflate) {
            out = out.slice(0, leftToInflate);
          }
          buffers.push(out);
          nread += out.length;
          leftToInflate -= out.length;
          if (leftToInflate === 0) {
            return false;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          return true;
        }
        return false;
      }
      assert(this._handle, "zlib binding closed");
      let res;
      do {
        res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
        res = res || this._writeState;
      } while (!this._hadError && handleChunk(res[0], res[1]));
      if (this._hadError) {
        throw error2;
      }
      if (nread >= kMaxLength) {
        _close(this);
        throw new RangeError("Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes");
      }
      let buf = Buffer.concat(buffers, nread);
      _close(this);
      return buf;
    };
    util.inherits(Inflate, zlib2.Inflate);
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === "string") {
        buffer = Buffer.from(buffer);
      }
      if (!(buffer instanceof Buffer)) {
        throw new TypeError("Not a string or buffer");
      }
      let flushFlag = engine._finishFlushFlag;
      if (flushFlag == null) {
        flushFlag = zlib2.Z_FINISH;
      }
      return engine._processChunk(buffer, flushFlag);
    }
    function inflateSync(buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    }
    module2.exports = exports = inflateSync;
    exports.Inflate = Inflate;
    exports.createInflate = createInflate;
    exports.inflateSync = inflateSync;
  }
});

// node_modules/pngjs/lib/sync-reader.js
var require_sync_reader = __commonJS({
  "node_modules/pngjs/lib/sync-reader.js"(exports, module2) {
    "use strict";
    var SyncReader = module2.exports = function(buffer) {
      this._buffer = buffer;
      this._reads = [];
    };
    SyncReader.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
    };
    SyncReader.prototype.process = function() {
      while (this._reads.length > 0 && this._buffer.length) {
        let read2 = this._reads[0];
        if (this._buffer.length && (this._buffer.length >= read2.length || read2.allowLess)) {
          this._reads.shift();
          let buf = this._buffer;
          this._buffer = buf.slice(read2.length);
          read2.func.call(this, buf.slice(0, read2.length));
        } else {
          break;
        }
      }
      if (this._reads.length > 0) {
        return new Error("There are some read requests waitng on finished stream");
      }
      if (this._buffer.length > 0) {
        return new Error("unrecognised content at end of stream");
      }
    };
  }
});

// node_modules/pngjs/lib/filter-parse-sync.js
var require_filter_parse_sync = __commonJS({
  "node_modules/pngjs/lib/filter-parse-sync.js"(exports) {
    "use strict";
    var SyncReader = require_sync_reader();
    var Filter = require_filter_parse();
    exports.process = function(inBuffer, bitmapInfo) {
      let outBuffers = [];
      let reader = new SyncReader(inBuffer);
      let filter = new Filter(bitmapInfo, {
        read: reader.read.bind(reader),
        write: function(bufferPart) {
          outBuffers.push(bufferPart);
        },
        complete: function() {
        }
      });
      filter.start();
      reader.process();
      return Buffer.concat(outBuffers);
    };
  }
});

// node_modules/pngjs/lib/parser-sync.js
var require_parser_sync = __commonJS({
  "node_modules/pngjs/lib/parser-sync.js"(exports, module2) {
    "use strict";
    var hasSyncZlib = true;
    var zlib2 = require("zlib");
    var inflateSync = require_sync_inflate();
    if (!zlib2.deflateSync) {
      hasSyncZlib = false;
    }
    var SyncReader = require_sync_reader();
    var FilterSync = require_filter_parse_sync();
    var Parser = require_parser();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    module2.exports = function(buffer, options) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
      }
      let err;
      function handleError(_err_) {
        err = _err_;
      }
      let metaData;
      function handleMetaData(_metaData_) {
        metaData = _metaData_;
      }
      function handleTransColor(transColor) {
        metaData.transColor = transColor;
      }
      function handlePalette(palette) {
        metaData.palette = palette;
      }
      function handleSimpleTransparency() {
        metaData.alpha = true;
      }
      let gamma;
      function handleGamma(_gamma_) {
        gamma = _gamma_;
      }
      let inflateDataList = [];
      function handleInflateData(inflatedData2) {
        inflateDataList.push(inflatedData2);
      }
      let reader = new SyncReader(buffer);
      let parser = new Parser(options, {
        read: reader.read.bind(reader),
        error: handleError,
        metadata: handleMetaData,
        gamma: handleGamma,
        palette: handlePalette,
        transColor: handleTransColor,
        inflateData: handleInflateData,
        simpleTransparency: handleSimpleTransparency
      });
      parser.start();
      reader.process();
      if (err) {
        throw err;
      }
      let inflateData = Buffer.concat(inflateDataList);
      inflateDataList.length = 0;
      let inflatedData;
      if (metaData.interlace) {
        inflatedData = zlib2.inflateSync(inflateData);
      } else {
        let rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
        let imageSize = rowSize * metaData.height;
        inflatedData = inflateSync(inflateData, {
          chunkSize: imageSize,
          maxLength: imageSize
        });
      }
      inflateData = null;
      if (!inflatedData || !inflatedData.length) {
        throw new Error("bad png - invalid inflate data response");
      }
      let unfilteredData = FilterSync.process(inflatedData, metaData);
      inflateData = null;
      let bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
      unfilteredData = null;
      let normalisedBitmapData = formatNormaliser(bitmapData, metaData);
      metaData.data = normalisedBitmapData;
      metaData.gamma = gamma || 0;
      return metaData;
    };
  }
});

// node_modules/pngjs/lib/packer-sync.js
var require_packer_sync = __commonJS({
  "node_modules/pngjs/lib/packer-sync.js"(exports, module2) {
    "use strict";
    var hasSyncZlib = true;
    var zlib2 = require("zlib");
    if (!zlib2.deflateSync) {
      hasSyncZlib = false;
    }
    var constants = require_constants();
    var Packer = require_packer();
    module2.exports = function(metaData, opt) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
      }
      let options = opt || {};
      let packer = new Packer(options);
      let chunks = [];
      chunks.push(Buffer.from(constants.PNG_SIGNATURE));
      chunks.push(packer.packIHDR(metaData.width, metaData.height));
      if (metaData.gamma) {
        chunks.push(packer.packGAMA(metaData.gamma));
      }
      let filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);
      let compressedData = zlib2.deflateSync(filteredData, packer.getDeflateOptions());
      filteredData = null;
      if (!compressedData || !compressedData.length) {
        throw new Error("bad png - invalid compressed data response");
      }
      chunks.push(packer.packIDAT(compressedData));
      chunks.push(packer.packIEND());
      return Buffer.concat(chunks);
    };
  }
});

// node_modules/pngjs/lib/png-sync.js
var require_png_sync = __commonJS({
  "node_modules/pngjs/lib/png-sync.js"(exports) {
    "use strict";
    var parse3 = require_parser_sync();
    var pack = require_packer_sync();
    exports.read = function(buffer, options) {
      return parse3(buffer, options || {});
    };
    exports.write = function(png, options) {
      return pack(png, options);
    };
  }
});

// node_modules/pngjs/lib/png.js
var require_png = __commonJS({
  "node_modules/pngjs/lib/png.js"(exports) {
    "use strict";
    var util = require("util");
    var Stream2 = require("stream");
    var Parser = require_parser_async();
    var Packer = require_packer_async();
    var PNGSync = require_png_sync();
    var PNG = exports.PNG = function(options) {
      Stream2.call(this);
      options = options || {};
      this.width = options.width | 0;
      this.height = options.height | 0;
      this.data = this.width > 0 && this.height > 0 ? Buffer.alloc(4 * this.width * this.height) : null;
      if (options.fill && this.data) {
        this.data.fill(0);
      }
      this.gamma = 0;
      this.readable = this.writable = true;
      this._parser = new Parser(options);
      this._parser.on("error", this.emit.bind(this, "error"));
      this._parser.on("close", this._handleClose.bind(this));
      this._parser.on("metadata", this._metadata.bind(this));
      this._parser.on("gamma", this._gamma.bind(this));
      this._parser.on("parsed", function(data) {
        this.data = data;
        this.emit("parsed", data);
      }.bind(this));
      this._packer = new Packer(options);
      this._packer.on("data", this.emit.bind(this, "data"));
      this._packer.on("end", this.emit.bind(this, "end"));
      this._parser.on("close", this._handleClose.bind(this));
      this._packer.on("error", this.emit.bind(this, "error"));
    };
    util.inherits(PNG, Stream2);
    PNG.sync = PNGSync;
    PNG.prototype.pack = function() {
      if (!this.data || !this.data.length) {
        this.emit("error", "No data provided");
        return this;
      }
      process.nextTick(function() {
        this._packer.pack(this.data, this.width, this.height, this.gamma);
      }.bind(this));
      return this;
    };
    PNG.prototype.parse = function(data, callback) {
      if (callback) {
        let onParsed, onError;
        onParsed = function(parsedData) {
          this.removeListener("error", onError);
          this.data = parsedData;
          callback(null, this);
        }.bind(this);
        onError = function(err) {
          this.removeListener("parsed", onParsed);
          callback(err, null);
        }.bind(this);
        this.once("parsed", onParsed);
        this.once("error", onError);
      }
      this.end(data);
      return this;
    };
    PNG.prototype.write = function(data) {
      this._parser.write(data);
      return true;
    };
    PNG.prototype.end = function(data) {
      this._parser.end(data);
    };
    PNG.prototype._metadata = function(metadata) {
      this.width = metadata.width;
      this.height = metadata.height;
      this.emit("metadata", metadata);
    };
    PNG.prototype._gamma = function(gamma) {
      this.gamma = gamma;
    };
    PNG.prototype._handleClose = function() {
      if (!this._parser.writable && !this._packer.readable) {
        this.emit("close");
      }
    };
    PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
      srcX |= 0;
      srcY |= 0;
      width |= 0;
      height |= 0;
      deltaX |= 0;
      deltaY |= 0;
      if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
        throw new Error("bitblt reading outside image");
      }
      if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
        throw new Error("bitblt writing outside image");
      }
      for (let y = 0; y < height; y++) {
        src.data.copy(dst.data, (deltaY + y) * dst.width + deltaX << 2, (srcY + y) * src.width + srcX << 2, (srcY + y) * src.width + srcX + width << 2);
      }
    };
    PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
      PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
      return this;
    };
    PNG.adjustGamma = function(src) {
      if (src.gamma) {
        for (let y = 0; y < src.height; y++) {
          for (let x2 = 0; x2 < src.width; x2++) {
            let idx = src.width * y + x2 << 2;
            for (let i2 = 0; i2 < 3; i2++) {
              let sample = src.data[idx + i2] / 255;
              sample = Math.pow(sample, 1 / 2.2 / src.gamma);
              src.data[idx + i2] = Math.round(sample * 255);
            }
          }
        }
        src.gamma = 0;
      }
    };
    PNG.prototype.adjustGamma = function() {
      PNG.adjustGamma(this);
    };
  }
});

// node_modules/qrcode/lib/renderer/utils.js
var require_utils2 = __commonJS({
  "node_modules/qrcode/lib/renderer/utils.js"(exports) {
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      let hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c) {
          return [c, c];
        }));
      }
      if (hexCode.length === 6)
        hexCode.push("F", "F");
      const hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports.getOptions = function getOptions(options) {
      if (!options)
        options = {};
      if (!options.color)
        options.color = {};
      const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      const width = options.width && options.width >= 21 ? options.width : void 0;
      const scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      const scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
      const size = qr.modules.size;
      const data = qr.modules.data;
      const scale = exports.getScale(size, opts);
      const symbolSize = Math.floor((size + opts.margin * 2) * scale);
      const scaledMargin = opts.margin * scale;
      const palette = [opts.color.light, opts.color.dark];
      for (let i2 = 0; i2 < symbolSize; i2++) {
        for (let j = 0; j < symbolSize; j++) {
          let posDst = (i2 * symbolSize + j) * 4;
          let pxColor = opts.color.light;
          if (i2 >= scaledMargin && j >= scaledMargin && i2 < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
            const iSrc = Math.floor((i2 - scaledMargin) / scale);
            const jSrc = Math.floor((j - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  }
});

// node_modules/qrcode/lib/renderer/png.js
var require_png2 = __commonJS({
  "node_modules/qrcode/lib/renderer/png.js"(exports) {
    var fs = require("fs");
    var PNG = require_png().PNG;
    var Utils = require_utils2();
    exports.render = function render(qrData, options) {
      const opts = Utils.getOptions(options);
      const pngOpts = opts.rendererOpts;
      const size = Utils.getImageWidth(qrData.modules.size, opts);
      pngOpts.width = size;
      pngOpts.height = size;
      const pngImage = new PNG(pngOpts);
      Utils.qrToImageData(pngImage.data, qrData, opts);
      return pngImage;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, options, cb) {
      if (typeof cb === "undefined") {
        cb = options;
        options = void 0;
      }
      exports.renderToBuffer(qrData, options, function(err, output) {
        if (err)
          cb(err);
        let url = "data:image/png;base64,";
        url += output.toString("base64");
        cb(null, url);
      });
    };
    exports.renderToBuffer = function renderToBuffer(qrData, options, cb) {
      if (typeof cb === "undefined") {
        cb = options;
        options = void 0;
      }
      const png = exports.render(qrData, options);
      const buffer = [];
      png.on("error", cb);
      png.on("data", function(data) {
        buffer.push(data);
      });
      png.on("end", function() {
        cb(null, Buffer.concat(buffer));
      });
      png.pack();
    };
    exports.renderToFile = function renderToFile(path, qrData, options, cb) {
      if (typeof cb === "undefined") {
        cb = options;
        options = void 0;
      }
      let called = false;
      const done = (...args) => {
        if (called)
          return;
        called = true;
        cb.apply(null, args);
      };
      const stream = fs.createWriteStream(path);
      stream.on("error", done);
      stream.on("close", done);
      exports.renderToFileStream(stream, qrData, options);
    };
    exports.renderToFileStream = function renderToFileStream(stream, qrData, options) {
      const png = exports.render(qrData, options);
      png.pack().pipe(stream);
    };
  }
});

// node_modules/qrcode/lib/renderer/utf8.js
var require_utf8 = __commonJS({
  "node_modules/qrcode/lib/renderer/utf8.js"(exports) {
    var Utils = require_utils2();
    var BLOCK_CHAR = {
      WW: " ",
      WB: "\u2584",
      BB: "\u2588",
      BW: "\u2580"
    };
    var INVERTED_BLOCK_CHAR = {
      BB: " ",
      BW: "\u2584",
      WW: "\u2588",
      WB: "\u2580"
    };
    function getBlockChar(top, bottom, blocks) {
      if (top && bottom)
        return blocks.BB;
      if (top && !bottom)
        return blocks.BW;
      if (!top && bottom)
        return blocks.WB;
      return blocks.WW;
    }
    exports.render = function(qrData, options, cb) {
      const opts = Utils.getOptions(options);
      let blocks = BLOCK_CHAR;
      if (opts.color.dark.hex === "#ffffff" || opts.color.light.hex === "#000000") {
        blocks = INVERTED_BLOCK_CHAR;
      }
      const size = qrData.modules.size;
      const data = qrData.modules.data;
      let output = "";
      let hMargin = Array(size + opts.margin * 2 + 1).join(blocks.WW);
      hMargin = Array(opts.margin / 2 + 1).join(hMargin + "\n");
      const vMargin = Array(opts.margin + 1).join(blocks.WW);
      output += hMargin;
      for (let i2 = 0; i2 < size; i2 += 2) {
        output += vMargin;
        for (let j = 0; j < size; j++) {
          const topModule = data[i2 * size + j];
          const bottomModule = data[(i2 + 1) * size + j];
          output += getBlockChar(topModule, bottomModule, blocks);
        }
        output += vMargin + "\n";
      }
      output += hMargin.slice(0, -1);
      if (typeof cb === "function") {
        cb(null, output);
      }
      return output;
    };
    exports.renderToFile = function renderToFile(path, qrData, options, cb) {
      if (typeof cb === "undefined") {
        cb = options;
        options = void 0;
      }
      const fs = require("fs");
      const utf8 = exports.render(qrData, options);
      fs.writeFile(path, utf8, cb);
    };
  }
});

// node_modules/qrcode/lib/renderer/terminal/terminal.js
var require_terminal = __commonJS({
  "node_modules/qrcode/lib/renderer/terminal/terminal.js"(exports) {
    exports.render = function(qrData, options, cb) {
      const size = qrData.modules.size;
      const data = qrData.modules.data;
      const black = "\x1B[40m  \x1B[0m";
      const white = "\x1B[47m  \x1B[0m";
      let output = "";
      const hMargin = Array(size + 3).join(white);
      const vMargin = Array(2).join(white);
      output += hMargin + "\n";
      for (let i2 = 0; i2 < size; ++i2) {
        output += white;
        for (let j = 0; j < size; j++) {
          output += data[i2 * size + j] ? black : white;
        }
        output += vMargin + "\n";
      }
      output += hMargin + "\n";
      if (typeof cb === "function") {
        cb(null, output);
      }
      return output;
    };
  }
});

// node_modules/qrcode/lib/renderer/terminal/terminal-small.js
var require_terminal_small = __commonJS({
  "node_modules/qrcode/lib/renderer/terminal/terminal-small.js"(exports) {
    var backgroundWhite = "\x1B[47m";
    var backgroundBlack = "\x1B[40m";
    var foregroundWhite = "\x1B[37m";
    var foregroundBlack = "\x1B[30m";
    var reset = "\x1B[0m";
    var lineSetupNormal = backgroundWhite + foregroundBlack;
    var lineSetupInverse = backgroundBlack + foregroundWhite;
    var createPalette = function(lineSetup, foregroundWhite2, foregroundBlack2) {
      return {
        "00": reset + " " + lineSetup,
        "01": reset + foregroundWhite2 + "\u2584" + lineSetup,
        "02": reset + foregroundBlack2 + "\u2584" + lineSetup,
        10: reset + foregroundWhite2 + "\u2580" + lineSetup,
        11: " ",
        12: "\u2584",
        20: reset + foregroundBlack2 + "\u2580" + lineSetup,
        21: "\u2580",
        22: "\u2588"
      };
    };
    var mkCodePixel = function(modules, size, x2, y) {
      const sizePlus = size + 1;
      if (x2 >= sizePlus || y >= sizePlus || y < -1 || x2 < -1)
        return "0";
      if (x2 >= size || y >= size || y < 0 || x2 < 0)
        return "1";
      const idx = y * size + x2;
      return modules[idx] ? "2" : "1";
    };
    var mkCode = function(modules, size, x2, y) {
      return mkCodePixel(modules, size, x2, y) + mkCodePixel(modules, size, x2, y + 1);
    };
    exports.render = function(qrData, options, cb) {
      const size = qrData.modules.size;
      const data = qrData.modules.data;
      const inverse = !!(options && options.inverse);
      const lineSetup = options && options.inverse ? lineSetupInverse : lineSetupNormal;
      const white = inverse ? foregroundBlack : foregroundWhite;
      const black = inverse ? foregroundWhite : foregroundBlack;
      const palette = createPalette(lineSetup, white, black);
      const newLine = reset + "\n" + lineSetup;
      let output = lineSetup;
      for (let y = -1; y < size + 1; y += 2) {
        for (let x2 = -1; x2 < size; x2++) {
          output += palette[mkCode(data, size, x2, y)];
        }
        output += palette[mkCode(data, size, size, y)] + newLine;
      }
      output += reset;
      if (typeof cb === "function") {
        cb(null, output);
      }
      return output;
    };
  }
});

// node_modules/qrcode/lib/renderer/terminal.js
var require_terminal2 = __commonJS({
  "node_modules/qrcode/lib/renderer/terminal.js"(exports) {
    var big = require_terminal();
    var small = require_terminal_small();
    exports.render = function(qrData, options, cb) {
      if (options && options.small) {
        return small.render(qrData, options, cb);
      }
      return big.render(qrData, options, cb);
    };
  }
});

// node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "node_modules/qrcode/lib/renderer/svg-tag.js"(exports) {
    var Utils = require_utils2();
    function getColorAttrib(color, attrib) {
      const alpha = color.a / 255;
      const str = attrib + '="' + color.hex + '"';
      return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
    }
    function svgCmd(cmd, x2, y) {
      let str = cmd + x2;
      if (typeof y !== "undefined")
        str += " " + y;
      return str;
    }
    function qrToPath(data, size, margin) {
      let path = "";
      let moveBy = 0;
      let newRow = false;
      let lineLength = 0;
      for (let i2 = 0; i2 < data.length; i2++) {
        const col = Math.floor(i2 % size);
        const row = Math.floor(i2 / size);
        if (!col && !newRow)
          newRow = true;
        if (data[i2]) {
          lineLength++;
          if (!(i2 > 0 && col > 0 && data[i2 - 1])) {
            path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size && data[i2 + 1])) {
            path += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path;
    }
    exports.render = function render(qrData, options, cb) {
      const opts = Utils.getOptions(options);
      const size = qrData.modules.size;
      const data = qrData.modules.data;
      const qrcodesize = size + opts.margin * 2;
      const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
      const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
      const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
      const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
      if (typeof cb === "function") {
        cb(null, svgTag);
      }
      return svgTag;
    };
  }
});

// node_modules/qrcode/lib/renderer/svg.js
var require_svg = __commonJS({
  "node_modules/qrcode/lib/renderer/svg.js"(exports) {
    var svgTagRenderer = require_svg_tag();
    exports.render = svgTagRenderer.render;
    exports.renderToFile = function renderToFile(path, qrData, options, cb) {
      if (typeof cb === "undefined") {
        cb = options;
        options = void 0;
      }
      const fs = require("fs");
      const svgTag = exports.render(qrData, options);
      const xmlStr = '<?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">' + svgTag;
      fs.writeFile(path, xmlStr, cb);
    };
  }
});

// node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS({
  "node_modules/qrcode/lib/renderer/canvas.js"(exports) {
    var Utils = require_utils2();
    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style)
        canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + "px";
      canvas.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e2) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports.render = function render(qrData, canvas, options) {
      let opts = options;
      let canvasEl = canvas;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      const size = Utils.getImageWidth(qrData.modules.size, opts);
      const ctx = canvasEl.getContext("2d");
      const image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      let opts = options;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!opts)
        opts = {};
      const canvasEl = exports.render(qrData, canvas, opts);
      const type = opts.type || "image/png";
      const rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
  }
});

// node_modules/qrcode/lib/browser.js
var require_browser = __commonJS({
  "node_modules/qrcode/lib/browser.js"(exports) {
    var canPromise = require_can_promise();
    var QRCode2 = require_qrcode();
    var CanvasRenderer = require_canvas();
    var SvgRenderer = require_svg_tag();
    function renderCanvas(renderFunc, canvas, text, opts, cb) {
      const args = [].slice.call(arguments, 1);
      const argsNum = args.length;
      const isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === "undefined") {
            cb = opts;
            opts = void 0;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = void 0;
        }
        return new Promise(function(resolve2, reject) {
          try {
            const data = QRCode2.create(text, opts);
            resolve2(renderFunc(data, canvas, opts));
          } catch (e2) {
            reject(e2);
          }
        });
      }
      try {
        const data = QRCode2.create(text, opts);
        cb(null, renderFunc(data, canvas, opts));
      } catch (e2) {
        cb(e2);
      }
    }
    exports.create = QRCode2.create;
    exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
    exports.toString = renderCanvas.bind(null, function(data, _, opts) {
      return SvgRenderer.render(data, opts);
    });
  }
});

// node_modules/qrcode/lib/server.js
var require_server = __commonJS({
  "node_modules/qrcode/lib/server.js"(exports) {
    var canPromise = require_can_promise();
    var QRCode2 = require_qrcode();
    var PngRenderer = require_png2();
    var Utf8Renderer = require_utf8();
    var TerminalRenderer = require_terminal2();
    var SvgRenderer = require_svg();
    function checkParams(text, opts, cb) {
      if (typeof text === "undefined") {
        throw new Error("String required as first argument");
      }
      if (typeof cb === "undefined") {
        cb = opts;
        opts = {};
      }
      if (typeof cb !== "function") {
        if (!canPromise()) {
          throw new Error("Callback required as last argument");
        } else {
          opts = cb || {};
          cb = null;
        }
      }
      return {
        opts,
        cb
      };
    }
    function getTypeFromFilename(path) {
      return path.slice((path.lastIndexOf(".") - 1 >>> 0) + 2).toLowerCase();
    }
    function getRendererFromType(type) {
      switch (type) {
        case "svg":
          return SvgRenderer;
        case "txt":
        case "utf8":
          return Utf8Renderer;
        case "png":
        case "image/png":
        default:
          return PngRenderer;
      }
    }
    function getStringRendererFromType(type) {
      switch (type) {
        case "svg":
          return SvgRenderer;
        case "terminal":
          return TerminalRenderer;
        case "utf8":
        default:
          return Utf8Renderer;
      }
    }
    function render(renderFunc, text, params) {
      if (!params.cb) {
        return new Promise(function(resolve2, reject) {
          try {
            const data = QRCode2.create(text, params.opts);
            return renderFunc(data, params.opts, function(err, data2) {
              return err ? reject(err) : resolve2(data2);
            });
          } catch (e2) {
            reject(e2);
          }
        });
      }
      try {
        const data = QRCode2.create(text, params.opts);
        return renderFunc(data, params.opts, params.cb);
      } catch (e2) {
        params.cb(e2);
      }
    }
    exports.create = QRCode2.create;
    exports.toCanvas = require_browser().toCanvas;
    exports.toString = function toString(text, opts, cb) {
      const params = checkParams(text, opts, cb);
      const type = params.opts ? params.opts.type : void 0;
      const renderer = getStringRendererFromType(type);
      return render(renderer.render, text, params);
    };
    exports.toDataURL = function toDataURL(text, opts, cb) {
      const params = checkParams(text, opts, cb);
      const renderer = getRendererFromType(params.opts.type);
      return render(renderer.renderToDataURL, text, params);
    };
    exports.toBuffer = function toBuffer(text, opts, cb) {
      const params = checkParams(text, opts, cb);
      const renderer = getRendererFromType(params.opts.type);
      return render(renderer.renderToBuffer, text, params);
    };
    exports.toFile = function toFile(path, text, opts, cb) {
      if (typeof path !== "string" || !(typeof text === "string" || typeof text === "object")) {
        throw new Error("Invalid argument");
      }
      if (arguments.length < 3 && !canPromise()) {
        throw new Error("Too few arguments provided");
      }
      const params = checkParams(text, opts, cb);
      const type = params.opts.type || getTypeFromFilename(path);
      const renderer = getRendererFromType(type);
      const renderToFile = renderer.renderToFile.bind(null, path);
      return render(renderToFile, text, params);
    };
    exports.toFileStream = function toFileStream(stream, text, opts) {
      if (arguments.length < 2) {
        throw new Error("Too few arguments provided");
      }
      const params = checkParams(text, opts, stream.emit.bind(stream, "error"));
      const renderer = getRendererFromType("png");
      const renderToFileStream = renderer.renderToFileStream.bind(null, stream);
      render(renderToFileStream, text, params);
    };
  }
});

// node_modules/qrcode/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/qrcode/lib/index.js"(exports, module2) {
    module2.exports = require_server();
  }
});

// .svelte-kit/output/server/chunks/utils-6d0dc2bc.js
function normalizeLinkName(link) {
  const cleanedLink = link.replace(/[^a-zA-Z0-9-]/g, "").toLowerCase();
  return cleanedLink;
}
function genQRCodeSvg(url) {
  return new Promise((resolve2, reject) => {
    import_qrcode.default.toString(url, { type: "svg" }, (err, svg) => {
      if (err)
        reject(err);
      resolve2(svg);
    });
  });
}
var import_qrcode;
var init_utils_6d0dc2bc = __esm({
  ".svelte-kit/output/server/chunks/utils-6d0dc2bc.js"() {
    import_qrcode = __toESM(require_lib8(), 1);
  }
});

// .svelte-kit/output/server/entries/endpoints/_link_link_.svg.ts.js
var link_link_svg_ts_exports = {};
__export(link_link_svg_ts_exports, {
  get: () => get7
});
async function get7(event) {
  const destination = links[normalizeLinkName(event.params.link)];
  const payload = await genQRCodeSvg(destination);
  return new Response(payload, {
    status: 200,
    headers: { "Content-Type": "image/svg+xml" }
  });
}
var import_qrcode2;
var init_link_link_svg_ts = __esm({
  ".svelte-kit/output/server/entries/endpoints/_link_link_.svg.ts.js"() {
    init_links_275d677a();
    init_utils_6d0dc2bc();
    import_qrcode2 = __toESM(require_lib8(), 1);
  }
});

// .svelte-kit/output/server/entries/matchers/link.js
var link_exports = {};
__export(link_exports, {
  match: () => match
});
function makeLinkMatcher() {
  return (param) => normalizeLinkName(param) in links;
}
function match(param) {
  const matcher = makeLinkMatcher();
  return matcher(param);
}
var import_qrcode3;
var init_link = __esm({
  ".svelte-kit/output/server/entries/matchers/link.js"() {
    init_links_275d677a();
    init_utils_6d0dc2bc();
    import_qrcode3 = __toESM(require_lib8(), 1);
  }
});

// .svelte-kit/vercel-tmp/entry.js
var entry_exports = {};
__export(entry_exports, {
  default: () => entry_default
});
module.exports = __toCommonJS(entry_exports);

// .svelte-kit/vercel-tmp/shims.js
init_install_fetch();
installFetch();

// node_modules/@sveltejs/kit/dist/node.js
var import_stream = require("stream");
function get_raw_body(req) {
  return new Promise((fulfil, reject) => {
    const h2 = req.headers;
    if (!h2["content-type"]) {
      return fulfil(null);
    }
    req.on("error", reject);
    const length = Number(h2["content-length"]);
    if (isNaN(length) && h2["transfer-encoding"] == null) {
      return fulfil(null);
    }
    let data = new Uint8Array(length || 0);
    if (length > 0) {
      let offset2 = 0;
      req.on("data", (chunk) => {
        const new_len = offset2 + Buffer.byteLength(chunk);
        if (new_len > length) {
          return reject({
            status: 413,
            reason: 'Exceeded "Content-Length" limit'
          });
        }
        data.set(chunk, offset2);
        offset2 = new_len;
      });
    } else {
      req.on("data", (chunk) => {
        const new_data = new Uint8Array(data.length + chunk.length);
        new_data.set(data, 0);
        new_data.set(chunk, data.length);
        data = new_data;
      });
    }
    req.on("end", () => {
      fulfil(data);
    });
  });
}
async function getRequest(base2, req) {
  let headers = req.headers;
  if (req.httpVersionMajor === 2) {
    headers = Object.assign({}, headers);
    delete headers[":method"];
    delete headers[":path"];
    delete headers[":authority"];
    delete headers[":scheme"];
  }
  return new Request(base2 + req.url, {
    method: req.method,
    headers,
    body: await get_raw_body(req)
  });
}
async function setResponse(res, response) {
  const headers = Object.fromEntries(response.headers);
  if (response.headers.has("set-cookie")) {
    headers["set-cookie"] = response.headers.raw()["set-cookie"];
  }
  res.writeHead(response.status, headers);
  if (response.body instanceof import_stream.Readable) {
    response.body.pipe(res);
  } else {
    if (response.body) {
      res.write(await response.arrayBuffer());
    }
    res.end();
  }
}

// .svelte-kit/output/server/index.js
init_index_b01bd1b0();
var __accessCheck2 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet2 = (obj, member, getter) => {
  __accessCheck2(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd2 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet2 = (obj, member, value, setter) => {
  __accessCheck2(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _use_hashes;
var _dev;
var _script_needs_csp;
var _style_needs_csp;
var _directives;
var _script_src;
var _style_src;
function afterUpdate() {
}
var Root = create_ssr_component(($$result, $$props, $$bindings, slots2) => {
  let { stores } = $$props;
  let { page: page2 } = $$props;
  let { components } = $$props;
  let { props_0 = null } = $$props;
  let { props_1 = null } = $$props;
  let { props_2 = null } = $$props;
  setContext("__svelte__", stores);
  afterUpdate(stores.page.notify);
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page2 !== void 0)
    $$bindings.page(page2);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
    $$bindings.props_0(props_0);
  if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
    $$bindings.props_1(props_1);
  if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
    $$bindings.props_2(props_2);
  {
    stores.page.set(page2);
  }
  return `


${components[1] ? `${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
    default: () => {
      return `${components[2] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
        default: () => {
          return `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}`;
        }
      })}` : `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {})}`}`;
    }
  })}` : `${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {})}`}

${``}`;
});
function to_headers(object) {
  const headers = new Headers();
  if (object) {
    for (const key2 in object) {
      const value = object[key2];
      if (!value)
        continue;
      if (Array.isArray(value)) {
        value.forEach((value2) => {
          headers.append(key2, value2);
        });
      } else {
        headers.set(key2, value);
      }
    }
  }
  return headers;
}
function hash(value) {
  let hash2 = 5381;
  let i2 = value.length;
  if (typeof value === "string") {
    while (i2)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i2);
  } else {
    while (i2)
      hash2 = hash2 * 33 ^ value[--i2];
  }
  return (hash2 >>> 0).toString(36);
}
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key2 in obj) {
    clone2[key2.toLowerCase()] = obj[key2];
  }
  return clone2;
}
function decode_params(params) {
  for (const key2 in params) {
    params[key2] = params[key2].replace(/%23/g, "#").replace(/%3[Bb]/g, ";").replace(/%2[Cc]/g, ",").replace(/%2[Ff]/g, "/").replace(/%3[Ff]/g, "?").replace(/%3[Aa]/g, ":").replace(/%40/g, "@").replace(/%26/g, "&").replace(/%3[Dd]/g, "=").replace(/%2[Bb]/g, "+").replace(/%24/g, "$");
  }
  return params;
}
function is_pojo(body) {
  if (typeof body !== "object")
    return false;
  if (body) {
    if (body instanceof Uint8Array)
      return false;
    if (body._readableState && typeof body.pipe === "function")
      return false;
    if (typeof ReadableStream !== "undefined" && body instanceof ReadableStream)
      return false;
  }
  return true;
}
function normalize_request_method(event) {
  const method = event.request.method.toLowerCase();
  return method === "delete" ? "del" : method;
}
function error(body) {
  return new Response(body, {
    status: 500
  });
}
function is_string(s22) {
  return typeof s22 === "string" || s22 instanceof String;
}
var text_types = /* @__PURE__ */ new Set([
  "application/xml",
  "application/json",
  "application/x-www-form-urlencoded",
  "multipart/form-data"
]);
function is_text(content_type) {
  if (!content_type)
    return true;
  const type = content_type.split(";")[0].toLowerCase();
  return type.startsWith("text/") || type.endsWith("+xml") || text_types.has(type);
}
async function render_endpoint(event, mod) {
  const method = normalize_request_method(event);
  let handler = mod[method];
  if (!handler && method === "head") {
    handler = mod.get;
  }
  if (!handler) {
    const allowed = [];
    for (const method2 in ["get", "post", "put", "patch"]) {
      if (mod[method2])
        allowed.push(method2.toUpperCase());
    }
    if (mod.del)
      allowed.push("DELETE");
    if (mod.get || mod.head)
      allowed.push("HEAD");
    return event.request.headers.get("x-sveltekit-load") ? new Response(void 0, {
      status: 204
    }) : new Response(`${event.request.method} method not allowed`, {
      status: 405,
      headers: {
        allow: allowed.join(", ")
      }
    });
  }
  const response = await handler(event);
  const preface = `Invalid response from route ${event.url.pathname}`;
  if (typeof response !== "object") {
    return error(`${preface}: expected an object, got ${typeof response}`);
  }
  if (response.fallthrough) {
    throw new Error("fallthrough is no longer supported. Use matchers instead: https://kit.svelte.dev/docs/routing#advanced-routing-matching");
  }
  const { status = 200, body = {} } = response;
  const headers = response.headers instanceof Headers ? new Headers(response.headers) : to_headers(response.headers);
  const type = headers.get("content-type");
  if (!is_text(type) && !(body instanceof Uint8Array || is_string(body))) {
    return error(`${preface}: body must be an instance of string or Uint8Array if content-type is not a supported textual content-type`);
  }
  let normalized_body;
  if (is_pojo(body) && (!type || type.startsWith("application/json"))) {
    headers.set("content-type", "application/json; charset=utf-8");
    normalized_body = JSON.stringify(body);
  } else {
    normalized_body = body;
  }
  if ((typeof normalized_body === "string" || normalized_body instanceof Uint8Array) && !headers.has("etag")) {
    const cache_control = headers.get("cache-control");
    if (!cache_control || !/(no-store|immutable)/.test(cache_control)) {
      headers.set("etag", `"${hash(normalized_body)}"`);
    }
  }
  return new Response(method !== "head" ? normalized_body : void 0, {
    status,
    headers
  });
}
var chars$1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
var escaped2 = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function devalue(value) {
  var counts = /* @__PURE__ */ new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key2) {
            return walk(thing[key2]);
          });
      }
    }
  }
  walk(value);
  var names = /* @__PURE__ */ new Map();
  Array.from(counts).filter(function(entry11) {
    return entry11[1] > 1;
  }).sort(function(a, b) {
    return b[1] - a[1];
  }).forEach(function(entry11, i2) {
    names.set(entry11[0], getName(i2));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v, i2) {
          return i2 in thing ? stringify(v) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key2) {
          return safeKey(key2) + ":" + stringify(thing[key2]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name, thing) {
      params_1.push(name);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v, i2) {
            statements_1.push(name + "[" + i2 + "]=" + stringify(v));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name + "." + Array.from(thing).map(function(v) {
            return "add(" + stringify(v) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name + "." + Array.from(thing).map(function(_a4) {
            var k = _a4[0], v = _a4[1];
            return "set(" + stringify(k) + ", " + stringify(v) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key2) {
            statements_1.push("" + name + safeProp(key2) + "=" + stringify(thing[key2]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name = "";
  do {
    name = chars$1[num % chars$1.length] + name;
    num = ~~(num / chars$1.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? name + "_" : name;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped2[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? key2 : escapeUnsafeChars(JSON.stringify(key2));
}
function safeProp(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? "." + key2 : "[" + escapeUnsafeChars(JSON.stringify(key2)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i2 = 0; i2 < str.length; i2 += 1) {
    var char = str.charAt(i2);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped2) {
      result += escaped2[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str.charCodeAt(i2 + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i2];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop3() {
}
function safe_not_equal2(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
Promise.resolve();
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop3) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal2(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop3) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop3;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}
function coalesce_to_error(err) {
  return err instanceof Error || err && err.name && err.message ? err : new Error(JSON.stringify(err));
}
var render_json_payload_script_dict = {
  "<": "\\u003C",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var render_json_payload_script_regex = new RegExp(`[${Object.keys(render_json_payload_script_dict).join("")}]`, "g");
function render_json_payload_script(attrs, payload) {
  const safe_payload = JSON.stringify(payload).replace(render_json_payload_script_regex, (match2) => render_json_payload_script_dict[match2]);
  let safe_attrs = "";
  for (const [key2, value] of Object.entries(attrs)) {
    if (value === void 0)
      continue;
    safe_attrs += ` sveltekit:data-${key2}=${escape_html_attr(value)}`;
  }
  return `<script type="application/json"${safe_attrs}>${safe_payload}<\/script>`;
}
var escape_html_attr_dict = {
  "&": "&amp;",
  '"': "&quot;"
};
var escape_html_attr_regex = new RegExp(`[${Object.keys(escape_html_attr_dict).join("")}]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\udc00-\\udfff]`, "g");
function escape_html_attr(str) {
  const escaped_str = str.replace(escape_html_attr_regex, (match2) => {
    if (match2.length === 2) {
      return match2;
    }
    return escape_html_attr_dict[match2] ?? `&#${match2.charCodeAt(0)};`;
  });
  return `"${escaped_str}"`;
}
var s2 = JSON.stringify;
function create_prerendering_url_proxy(url) {
  return new Proxy(url, {
    get: (target, prop, receiver) => {
      if (prop === "search" || prop === "searchParams") {
        throw new Error(`Cannot access url.${prop} on a page with prerendering enabled`);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
var encoder = new TextEncoder();
function sha256(data) {
  if (!key[0])
    precompute();
  const out = init.slice(0);
  const array = encode$1(data);
  for (let i2 = 0; i2 < array.length; i2 += 16) {
    const w = array.subarray(i2, i2 + 16);
    let tmp;
    let a;
    let b;
    let out0 = out[0];
    let out1 = out[1];
    let out2 = out[2];
    let out3 = out[3];
    let out4 = out[4];
    let out5 = out[5];
    let out6 = out[6];
    let out7 = out[7];
    for (let i22 = 0; i22 < 64; i22++) {
      if (i22 < 16) {
        tmp = w[i22];
      } else {
        a = w[i22 + 1 & 15];
        b = w[i22 + 14 & 15];
        tmp = w[i22 & 15] = (a >>> 7 ^ a >>> 18 ^ a >>> 3 ^ a << 25 ^ a << 14) + (b >>> 17 ^ b >>> 19 ^ b >>> 10 ^ b << 15 ^ b << 13) + w[i22 & 15] + w[i22 + 9 & 15] | 0;
      }
      tmp = tmp + out7 + (out4 >>> 6 ^ out4 >>> 11 ^ out4 >>> 25 ^ out4 << 26 ^ out4 << 21 ^ out4 << 7) + (out6 ^ out4 & (out5 ^ out6)) + key[i22];
      out7 = out6;
      out6 = out5;
      out5 = out4;
      out4 = out3 + tmp | 0;
      out3 = out2;
      out2 = out1;
      out1 = out0;
      out0 = tmp + (out1 & out2 ^ out3 & (out1 ^ out2)) + (out1 >>> 2 ^ out1 >>> 13 ^ out1 >>> 22 ^ out1 << 30 ^ out1 << 19 ^ out1 << 10) | 0;
    }
    out[0] = out[0] + out0 | 0;
    out[1] = out[1] + out1 | 0;
    out[2] = out[2] + out2 | 0;
    out[3] = out[3] + out3 | 0;
    out[4] = out[4] + out4 | 0;
    out[5] = out[5] + out5 | 0;
    out[6] = out[6] + out6 | 0;
    out[7] = out[7] + out7 | 0;
  }
  const bytes = new Uint8Array(out.buffer);
  reverse_endianness(bytes);
  return base64(bytes);
}
var init = new Uint32Array(8);
var key = new Uint32Array(64);
function precompute() {
  function frac(x2) {
    return (x2 - Math.floor(x2)) * 4294967296;
  }
  let prime = 2;
  for (let i2 = 0; i2 < 64; prime++) {
    let is_prime = true;
    for (let factor = 2; factor * factor <= prime; factor++) {
      if (prime % factor === 0) {
        is_prime = false;
        break;
      }
    }
    if (is_prime) {
      if (i2 < 8) {
        init[i2] = frac(prime ** (1 / 2));
      }
      key[i2] = frac(prime ** (1 / 3));
      i2++;
    }
  }
}
function reverse_endianness(bytes) {
  for (let i2 = 0; i2 < bytes.length; i2 += 4) {
    const a = bytes[i2 + 0];
    const b = bytes[i2 + 1];
    const c = bytes[i2 + 2];
    const d = bytes[i2 + 3];
    bytes[i2 + 0] = d;
    bytes[i2 + 1] = c;
    bytes[i2 + 2] = b;
    bytes[i2 + 3] = a;
  }
}
function encode$1(str) {
  const encoded = encoder.encode(str);
  const length = encoded.length * 8;
  const size = 512 * Math.ceil((length + 65) / 512);
  const bytes = new Uint8Array(size / 8);
  bytes.set(encoded);
  bytes[encoded.length] = 128;
  reverse_endianness(bytes);
  const words = new Uint32Array(bytes.buffer);
  words[words.length - 2] = Math.floor(length / 4294967296);
  words[words.length - 1] = length;
  return words;
}
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
function base64(bytes) {
  const l = bytes.length;
  let result = "";
  let i2;
  for (i2 = 2; i2 < l; i2 += 3) {
    result += chars[bytes[i2 - 2] >> 2];
    result += chars[(bytes[i2 - 2] & 3) << 4 | bytes[i2 - 1] >> 4];
    result += chars[(bytes[i2 - 1] & 15) << 2 | bytes[i2] >> 6];
    result += chars[bytes[i2] & 63];
  }
  if (i2 === l + 1) {
    result += chars[bytes[i2 - 2] >> 2];
    result += chars[(bytes[i2 - 2] & 3) << 4];
    result += "==";
  }
  if (i2 === l) {
    result += chars[bytes[i2 - 2] >> 2];
    result += chars[(bytes[i2 - 2] & 3) << 4 | bytes[i2 - 1] >> 4];
    result += chars[(bytes[i2 - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
var csp_ready;
var generate_nonce;
var generate_hash;
if (typeof crypto !== "undefined") {
  const array = new Uint8Array(16);
  generate_nonce = () => {
    crypto.getRandomValues(array);
    return base64(array);
  };
  generate_hash = sha256;
} else {
  const name = "crypto";
  csp_ready = import(name).then((crypto2) => {
    generate_nonce = () => {
      return crypto2.randomBytes(16).toString("base64");
    };
    generate_hash = (input) => {
      return crypto2.createHash("sha256").update(input, "utf-8").digest().toString("base64");
    };
  });
}
var quoted = /* @__PURE__ */ new Set([
  "self",
  "unsafe-eval",
  "unsafe-hashes",
  "unsafe-inline",
  "none",
  "strict-dynamic",
  "report-sample"
]);
var crypto_pattern = /^(nonce|sha\d\d\d)-/;
var Csp = class {
  constructor({ mode, directives }, { dev, prerender, needs_nonce }) {
    __privateAdd2(this, _use_hashes, void 0);
    __privateAdd2(this, _dev, void 0);
    __privateAdd2(this, _script_needs_csp, void 0);
    __privateAdd2(this, _style_needs_csp, void 0);
    __privateAdd2(this, _directives, void 0);
    __privateAdd2(this, _script_src, void 0);
    __privateAdd2(this, _style_src, void 0);
    __privateSet2(this, _use_hashes, mode === "hash" || mode === "auto" && prerender);
    __privateSet2(this, _directives, dev ? __spreadValues({}, directives) : directives);
    __privateSet2(this, _dev, dev);
    const d = __privateGet2(this, _directives);
    if (dev) {
      const effective_style_src2 = d["style-src"] || d["default-src"];
      if (effective_style_src2 && !effective_style_src2.includes("unsafe-inline")) {
        d["style-src"] = [...effective_style_src2, "unsafe-inline"];
      }
    }
    __privateSet2(this, _script_src, []);
    __privateSet2(this, _style_src, []);
    const effective_script_src = d["script-src"] || d["default-src"];
    const effective_style_src = d["style-src"] || d["default-src"];
    __privateSet2(this, _script_needs_csp, !!effective_script_src && effective_script_src.filter((value) => value !== "unsafe-inline").length > 0);
    __privateSet2(this, _style_needs_csp, !dev && !!effective_style_src && effective_style_src.filter((value) => value !== "unsafe-inline").length > 0);
    this.script_needs_nonce = __privateGet2(this, _script_needs_csp) && !__privateGet2(this, _use_hashes);
    this.style_needs_nonce = __privateGet2(this, _style_needs_csp) && !__privateGet2(this, _use_hashes);
    if (this.script_needs_nonce || this.style_needs_nonce || needs_nonce) {
      this.nonce = generate_nonce();
    }
  }
  add_script(content) {
    if (__privateGet2(this, _script_needs_csp)) {
      if (__privateGet2(this, _use_hashes)) {
        __privateGet2(this, _script_src).push(`sha256-${generate_hash(content)}`);
      } else if (__privateGet2(this, _script_src).length === 0) {
        __privateGet2(this, _script_src).push(`nonce-${this.nonce}`);
      }
    }
  }
  add_style(content) {
    if (__privateGet2(this, _style_needs_csp)) {
      if (__privateGet2(this, _use_hashes)) {
        __privateGet2(this, _style_src).push(`sha256-${generate_hash(content)}`);
      } else if (__privateGet2(this, _style_src).length === 0) {
        __privateGet2(this, _style_src).push(`nonce-${this.nonce}`);
      }
    }
  }
  get_header(is_meta = false) {
    const header = [];
    const directives = __spreadValues({}, __privateGet2(this, _directives));
    if (__privateGet2(this, _style_src).length > 0) {
      directives["style-src"] = [
        ...directives["style-src"] || directives["default-src"] || [],
        ...__privateGet2(this, _style_src)
      ];
    }
    if (__privateGet2(this, _script_src).length > 0) {
      directives["script-src"] = [
        ...directives["script-src"] || directives["default-src"] || [],
        ...__privateGet2(this, _script_src)
      ];
    }
    for (const key2 in directives) {
      if (is_meta && (key2 === "frame-ancestors" || key2 === "report-uri" || key2 === "sandbox")) {
        continue;
      }
      const value = directives[key2];
      if (!value)
        continue;
      const directive = [key2];
      if (Array.isArray(value)) {
        value.forEach((value2) => {
          if (quoted.has(value2) || crypto_pattern.test(value2)) {
            directive.push(`'${value2}'`);
          } else {
            directive.push(value2);
          }
        });
      }
      header.push(directive.join(" "));
    }
    return header.join("; ");
  }
  get_meta() {
    const content = escape_html_attr(this.get_header(true));
    return `<meta http-equiv="content-security-policy" content=${content}>`;
  }
};
_use_hashes = /* @__PURE__ */ new WeakMap();
_dev = /* @__PURE__ */ new WeakMap();
_script_needs_csp = /* @__PURE__ */ new WeakMap();
_style_needs_csp = /* @__PURE__ */ new WeakMap();
_directives = /* @__PURE__ */ new WeakMap();
_script_src = /* @__PURE__ */ new WeakMap();
_style_src = /* @__PURE__ */ new WeakMap();
var updated = __spreadProps(__spreadValues({}, readable(false)), {
  check: () => false
});
async function render_response({
  branch,
  options,
  state,
  $session,
  page_config,
  status,
  error: error2 = null,
  event,
  resolve_opts,
  stuff
}) {
  if (state.prerender) {
    if (options.csp.mode === "nonce") {
      throw new Error('Cannot use prerendering if config.kit.csp.mode === "nonce"');
    }
    if (options.template_contains_nonce) {
      throw new Error("Cannot use prerendering if page template contains %svelte.nonce%");
    }
  }
  const stylesheets = new Set(options.manifest._.entry.css);
  const modulepreloads = new Set(options.manifest._.entry.js);
  const styles = /* @__PURE__ */ new Map();
  const serialized_data = [];
  let shadow_props;
  let rendered;
  let is_private = false;
  let cache;
  if (error2) {
    error2.stack = options.get_stack(error2);
  }
  if (resolve_opts.ssr) {
    branch.forEach(({ node, props: props2, loaded, fetched, uses_credentials }) => {
      if (node.css)
        node.css.forEach((url) => stylesheets.add(url));
      if (node.js)
        node.js.forEach((url) => modulepreloads.add(url));
      if (node.styles)
        Object.entries(node.styles).forEach(([k, v]) => styles.set(k, v));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (props2)
        shadow_props = props2;
      cache = loaded == null ? void 0 : loaded.cache;
      is_private = (cache == null ? void 0 : cache.private) ?? uses_credentials;
    });
    const session = writable($session);
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        session: __spreadProps(__spreadValues({}, session), {
          subscribe: (fn) => {
            is_private = (cache == null ? void 0 : cache.private) ?? true;
            return session.subscribe(fn);
          }
        }),
        updated
      },
      page: {
        error: error2,
        params: event.params,
        routeId: event.routeId,
        status,
        stuff,
        url: state.prerender ? create_prerendering_url_proxy(event.url) : event.url
      },
      components: branch.map(({ node }) => node.module.default)
    };
    const print_error = (property, replacement) => {
      Object.defineProperty(props.page, property, {
        get: () => {
          throw new Error(`$page.${property} has been replaced by $page.url.${replacement}`);
        }
      });
    };
    print_error("origin", "origin");
    print_error("path", "pathname");
    print_error("query", "searchParams");
    for (let i2 = 0; i2 < branch.length; i2 += 1) {
      props[`props_${i2}`] = await branch[i2].loaded.props;
    }
    rendered = options.root.render(props);
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  let { head, html: body } = rendered;
  const inlined_style = Array.from(styles.values()).join("\n");
  await csp_ready;
  const csp = new Csp(options.csp, {
    dev: options.dev,
    prerender: !!state.prerender,
    needs_nonce: options.template_contains_nonce
  });
  const target = hash(body);
  const init_app = `
		import { start } from ${s2(options.prefix + options.manifest._.entry.file)};
		start({
			target: document.querySelector('[data-hydrate="${target}"]').parentNode,
			paths: ${s2(options.paths)},
			session: ${try_serialize($session, (error3) => {
    throw new Error(`Failed to serialize session data: ${error3.message}`);
  })},
			route: ${!!page_config.router},
			spa: ${!resolve_opts.ssr},
			trailing_slash: ${s2(options.trailing_slash)},
			hydrate: ${resolve_opts.ssr && page_config.hydrate ? `{
				status: ${status},
				error: ${serialize_error(error2)},
				nodes: [
					${(branch || []).map(({ node }) => `import(${s2(options.prefix + node.entry)})`).join(",\n						")}
				],
				params: ${devalue(event.params)},
				routeId: ${s2(event.routeId)}
			}` : "null"}
		});
	`;
  const init_service_worker = `
		if ('serviceWorker' in navigator) {
			navigator.serviceWorker.register('${options.service_worker}');
		}
	`;
  if (options.amp) {
    const styles2 = `${inlined_style}
${rendered.css.code}`;
    head += `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"><\/script>

		<style amp-custom>${styles2}</style>`;
    if (options.service_worker) {
      head += '<script async custom-element="amp-install-serviceworker" src="https://cdn.ampproject.org/v0/amp-install-serviceworker-0.1.js"><\/script>';
      body += `<amp-install-serviceworker src="${options.service_worker}" layout="nodisplay"></amp-install-serviceworker>`;
    }
  } else {
    if (inlined_style) {
      const attributes = [];
      if (options.dev)
        attributes.push(" data-sveltekit");
      if (csp.style_needs_nonce)
        attributes.push(` nonce="${csp.nonce}"`);
      csp.add_style(inlined_style);
      head += `
	<style${attributes.join("")}>${inlined_style}</style>`;
    }
    head += Array.from(stylesheets).map((dep) => {
      const attributes = [
        'rel="stylesheet"',
        `href="${options.prefix + dep}"`
      ];
      if (csp.style_needs_nonce) {
        attributes.push(`nonce="${csp.nonce}"`);
      }
      if (styles.has(dep)) {
        attributes.push("disabled", 'media="(max-width: 0)"');
      }
      return `
	<link ${attributes.join(" ")}>`;
    }).join("");
    if (page_config.router || page_config.hydrate) {
      head += Array.from(modulepreloads).map((dep) => `
	<link rel="modulepreload" href="${options.prefix + dep}">`).join("");
      const attributes = ['type="module"', `data-hydrate="${target}"`];
      csp.add_script(init_app);
      if (csp.script_needs_nonce) {
        attributes.push(`nonce="${csp.nonce}"`);
      }
      body += `
		<script ${attributes.join(" ")}>${init_app}<\/script>`;
      body += serialized_data.map(({ url, body: body2, response }) => render_json_payload_script({ type: "data", url, body: typeof body2 === "string" ? hash(body2) : void 0 }, response)).join("\n	");
      if (shadow_props) {
        body += render_json_payload_script({ type: "props" }, shadow_props);
      }
    }
    if (options.service_worker) {
      csp.add_script(init_service_worker);
      head += `
				<script${csp.script_needs_nonce ? ` nonce="${csp.nonce}"` : ""}>${init_service_worker}<\/script>`;
    }
  }
  if (state.prerender && !options.amp) {
    const http_equiv = [];
    const csp_headers = csp.get_meta();
    if (csp_headers) {
      http_equiv.push(csp_headers);
    }
    if (cache) {
      http_equiv.push(`<meta http-equiv="cache-control" content="max-age=${cache.maxage}">`);
    }
    if (http_equiv.length > 0) {
      head = http_equiv.join("\n") + head;
    }
  }
  const segments = event.url.pathname.slice(options.paths.base.length).split("/").slice(2);
  const assets2 = options.paths.assets || (segments.length > 0 ? segments.map(() => "..").join("/") : ".");
  const html = await resolve_opts.transformPage({
    html: options.template({ head, body, assets: assets2, nonce: csp.nonce })
  });
  const headers = new Headers({
    "content-type": "text/html",
    etag: `"${hash(html)}"`
  });
  if (cache) {
    headers.set("cache-control", `${is_private ? "private" : "public"}, max-age=${cache.maxage}`);
  }
  if (!options.floc) {
    headers.set("permissions-policy", "interest-cohort=()");
  }
  if (!state.prerender) {
    const csp_header = csp.get_header();
    if (csp_header) {
      headers.set("content-security-policy", csp_header);
    }
  }
  return new Response(html, {
    status,
    headers
  });
}
function try_serialize(data, fail) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail)
      fail(coalesce_to_error(err));
    return null;
  }
}
function serialize_error(error2) {
  if (!error2)
    return null;
  let serialized = try_serialize(error2);
  if (!serialized) {
    const { name, message, stack } = error2;
    serialized = try_serialize(__spreadProps(__spreadValues({}, error2), { name, message, stack }));
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
var parse_1 = parse$1;
var serialize_1 = serialize;
var __toString = Object.prototype.toString;
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function parse$1(str, options) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var obj = {};
  var opt = options || {};
  var dec = opt.decode || decode;
  var index = 0;
  while (index < str.length) {
    var eqIdx = str.indexOf("=", index);
    if (eqIdx === -1) {
      break;
    }
    var endIdx = str.indexOf(";", index);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    var key2 = str.slice(index, eqIdx).trim();
    if (obj[key2] === void 0) {
      var val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.charCodeAt(0) === 34) {
        val = val.slice(1, -1);
      }
      obj[key2] = tryDecode(val, dec);
    }
    index = endIdx + 1;
  }
  return obj;
}
function serialize(name, val, options) {
  var opt = options || {};
  var enc = opt.encode || encode;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name)) {
    throw new TypeError("argument name is invalid");
  }
  var value = enc(val);
  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError("argument val is invalid");
  }
  var str = name + "=" + value;
  if (opt.maxAge != null) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    var expires = opt.expires;
    if (!isDate(expires) || isNaN(expires.valueOf())) {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.priority) {
    var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
    switch (priority) {
      case "low":
        str += "; Priority=Low";
        break;
      case "medium":
        str += "; Priority=Medium";
        break;
      case "high":
        str += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
}
function decode(str) {
  return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
}
function encode(val) {
  return encodeURIComponent(val);
}
function isDate(val) {
  return __toString.call(val) === "[object Date]" || val instanceof Date;
}
function tryDecode(str, decode2) {
  try {
    return decode2(str);
  } catch (e2) {
    return str;
  }
}
var setCookie = { exports: {} };
var defaultParseOptions = {
  decodeValues: true,
  map: false,
  silent: false
};
function isNonEmptyString(str) {
  return typeof str === "string" && !!str.trim();
}
function parseString(setCookieValue, options) {
  var parts = setCookieValue.split(";").filter(isNonEmptyString);
  var nameValue = parts.shift().split("=");
  var name = nameValue.shift();
  var value = nameValue.join("=");
  options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
  try {
    value = options.decodeValues ? decodeURIComponent(value) : value;
  } catch (e2) {
    console.error("set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.", e2);
  }
  var cookie = {
    name,
    value
  };
  parts.forEach(function(part) {
    var sides = part.split("=");
    var key2 = sides.shift().trimLeft().toLowerCase();
    var value2 = sides.join("=");
    if (key2 === "expires") {
      cookie.expires = new Date(value2);
    } else if (key2 === "max-age") {
      cookie.maxAge = parseInt(value2, 10);
    } else if (key2 === "secure") {
      cookie.secure = true;
    } else if (key2 === "httponly") {
      cookie.httpOnly = true;
    } else if (key2 === "samesite") {
      cookie.sameSite = value2;
    } else {
      cookie[key2] = value2;
    }
  });
  return cookie;
}
function parse(input, options) {
  options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
  if (!input) {
    if (!options.map) {
      return [];
    } else {
      return {};
    }
  }
  if (input.headers && input.headers["set-cookie"]) {
    input = input.headers["set-cookie"];
  } else if (input.headers) {
    var sch = input.headers[Object.keys(input.headers).find(function(key2) {
      return key2.toLowerCase() === "set-cookie";
    })];
    if (!sch && input.headers.cookie && !options.silent) {
      console.warn("Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.");
    }
    input = sch;
  }
  if (!Array.isArray(input)) {
    input = [input];
  }
  options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
  if (!options.map) {
    return input.filter(isNonEmptyString).map(function(str) {
      return parseString(str, options);
    });
  } else {
    var cookies = {};
    return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
      var cookie = parseString(str, options);
      cookies2[cookie.name] = cookie;
      return cookies2;
    }, cookies);
  }
}
function splitCookiesString(cookiesString) {
  if (Array.isArray(cookiesString)) {
    return cookiesString;
  }
  if (typeof cookiesString !== "string") {
    return [];
  }
  var cookiesStrings = [];
  var pos = 0;
  var start;
  var ch;
  var lastComma;
  var nextStart;
  var cookiesSeparatorFound;
  function skipWhitespace() {
    while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
      pos += 1;
    }
    return pos < cookiesString.length;
  }
  function notSpecialChar() {
    ch = cookiesString.charAt(pos);
    return ch !== "=" && ch !== ";" && ch !== ",";
  }
  while (pos < cookiesString.length) {
    start = pos;
    cookiesSeparatorFound = false;
    while (skipWhitespace()) {
      ch = cookiesString.charAt(pos);
      if (ch === ",") {
        lastComma = pos;
        pos += 1;
        skipWhitespace();
        nextStart = pos;
        while (pos < cookiesString.length && notSpecialChar()) {
          pos += 1;
        }
        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
          cookiesSeparatorFound = true;
          pos = nextStart;
          cookiesStrings.push(cookiesString.substring(start, lastComma));
          start = pos;
        } else {
          pos = lastComma + 1;
        }
      } else {
        pos += 1;
      }
    }
    if (!cookiesSeparatorFound || pos >= cookiesString.length) {
      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
    }
  }
  return cookiesStrings;
}
setCookie.exports = parse;
setCookie.exports.parse = parse;
var parseString_1 = setCookie.exports.parseString = parseString;
var splitCookiesString_1 = setCookie.exports.splitCookiesString = splitCookiesString;
function normalize(loaded) {
  if (loaded.fallthrough) {
    throw new Error("fallthrough is no longer supported. Use matchers instead: https://kit.svelte.dev/docs/routing#advanced-routing-matching");
  }
  if ("maxage" in loaded) {
    throw new Error("maxage should be replaced with cache: { maxage }");
  }
  const has_error_status = loaded.status && loaded.status >= 400 && loaded.status <= 599 && !loaded.redirect;
  if (loaded.error || has_error_status) {
    const status = loaded.status;
    if (!loaded.error && has_error_status) {
      return { status: status || 500, error: new Error() };
    }
    const error2 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    if (!(error2 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error2}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return { status: 500, error: error2 };
    }
    return { status, error: error2 };
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  if (loaded.dependencies) {
    if (!Array.isArray(loaded.dependencies) || loaded.dependencies.some((dep) => typeof dep !== "string")) {
      return {
        status: 500,
        error: new Error('"dependencies" property returned from load() must be of type string[]')
      };
    }
  }
  if (loaded.context) {
    throw new Error('You are returning "context" from a load function. "context" was renamed to "stuff", please adjust your code accordingly.');
  }
  return loaded;
}
var absolute = /^([a-z]+:)?\/?\//;
var scheme = /^[a-z]+:/;
function resolve(base2, path) {
  if (scheme.test(path))
    return path;
  const base_match = absolute.exec(base2);
  const path_match = absolute.exec(path);
  if (!base_match) {
    throw new Error(`bad base path: "${base2}"`);
  }
  const baseparts = path_match ? [] : base2.slice(base_match[0].length).split("/");
  const pathparts = path_match ? path.slice(path_match[0].length).split("/") : path.split("/");
  baseparts.pop();
  for (let i2 = 0; i2 < pathparts.length; i2 += 1) {
    const part = pathparts[i2];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  const prefix = path_match && path_match[0] || base_match && base_match[0] || "";
  return `${prefix}${baseparts.join("/")}`;
}
function is_root_relative(path) {
  return path[0] === "/" && path[1] !== "/";
}
function normalize_path(path, trailing_slash) {
  if (path === "/" || trailing_slash === "ignore")
    return path;
  if (trailing_slash === "never") {
    return path.endsWith("/") ? path.slice(0, -1) : path;
  } else if (trailing_slash === "always" && /\/[^./]+$/.test(path)) {
    return path + "/";
  }
  return path;
}
function domain_matches(hostname, constraint) {
  if (!constraint)
    return true;
  const normalized = constraint[0] === "." ? constraint.slice(1) : constraint;
  if (hostname === normalized)
    return true;
  return hostname.endsWith("." + normalized);
}
function path_matches(path, constraint) {
  if (!constraint)
    return true;
  const normalized = constraint.endsWith("/") ? constraint.slice(0, -1) : constraint;
  if (path === normalized)
    return true;
  return path.startsWith(normalized + "/");
}
async function load_node({
  event,
  options,
  state,
  route,
  node,
  $session,
  stuff,
  is_error,
  is_leaf,
  status,
  error: error2
}) {
  const { module: module2 } = node;
  let uses_credentials = false;
  const fetched = [];
  const cookies = parse_1(event.request.headers.get("cookie") || "");
  const new_cookies = [];
  let loaded;
  const shadow = is_leaf ? await load_shadow_data(route, event, options, !!state.prerender) : {};
  if (shadow.cookies) {
    shadow.cookies.forEach((header) => {
      new_cookies.push(parseString_1(header));
    });
  }
  if (shadow.error) {
    loaded = {
      status: shadow.status,
      error: shadow.error
    };
  } else if (shadow.redirect) {
    loaded = {
      status: shadow.status,
      redirect: shadow.redirect
    };
  } else if (module2.load) {
    const load_input = {
      url: state.prerender ? create_prerendering_url_proxy(event.url) : event.url,
      params: event.params,
      props: shadow.body || {},
      routeId: event.routeId,
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let requested;
        if (typeof resource === "string") {
          requested = resource;
        } else {
          requested = resource.url;
          opts = __spreadValues({
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity
          }, opts);
        }
        opts.headers = new Headers(opts.headers);
        for (const [key2, value] of event.request.headers) {
          if (key2 !== "authorization" && key2 !== "cookie" && key2 !== "host" && key2 !== "if-none-match" && !opts.headers.has(key2)) {
            opts.headers.set(key2, value);
          }
        }
        const resolved = resolve(event.url.pathname, requested.split("?")[0]);
        let response;
        let dependency;
        const prefix = options.paths.assets || options.paths.base;
        const filename = decodeURIComponent(resolved.startsWith(prefix) ? resolved.slice(prefix.length) : resolved).slice(1);
        const filename_html = `${filename}/index.html`;
        const is_asset = options.manifest.assets.has(filename);
        const is_asset_html = options.manifest.assets.has(filename_html);
        if (is_asset || is_asset_html) {
          const file = is_asset ? filename : filename_html;
          if (options.read) {
            const type = is_asset ? options.manifest.mimeTypes[filename.slice(filename.lastIndexOf("."))] : "text/html";
            response = new Response(options.read(file), {
              headers: type ? { "content-type": type } : {}
            });
          } else {
            response = await fetch(`${event.url.origin}/${file}`, opts);
          }
        } else if (is_root_relative(resolved)) {
          if (opts.credentials !== "omit") {
            uses_credentials = true;
            const authorization = event.request.headers.get("authorization");
            const combined_cookies = __spreadValues({}, cookies);
            for (const cookie2 of new_cookies) {
              if (!domain_matches(event.url.hostname, cookie2.domain))
                continue;
              if (!path_matches(resolved, cookie2.path))
                continue;
              combined_cookies[cookie2.name] = cookie2.value;
            }
            const cookie = Object.entries(combined_cookies).map(([name, value]) => `${name}=${value}`).join("; ");
            if (cookie) {
              opts.headers.set("cookie", cookie);
            }
            if (authorization && !opts.headers.has("authorization")) {
              opts.headers.set("authorization", authorization);
            }
          }
          if (opts.body && typeof opts.body !== "string") {
            throw new Error("Request body must be a string");
          }
          response = await respond(new Request(new URL(requested, event.url).href, __spreadProps(__spreadValues({}, opts), { credentials: void 0 })), options, __spreadProps(__spreadValues({}, state), {
            initiator: route
          }));
          if (state.prerender) {
            dependency = { response, body: null };
            state.prerender.dependencies.set(resolved, dependency);
          }
        } else {
          if (resolved.startsWith("//")) {
            requested = event.url.protocol + requested;
          }
          if (`.${new URL(requested).hostname}`.endsWith(`.${event.url.hostname}`) && opts.credentials !== "omit") {
            uses_credentials = true;
            const cookie = event.request.headers.get("cookie");
            if (cookie)
              opts.headers.set("cookie", cookie);
          }
          const external_request = new Request(requested, opts);
          response = await options.hooks.externalFetch.call(null, external_request);
        }
        const set_cookie = response.headers.get("set-cookie");
        if (set_cookie) {
          new_cookies.push(...splitCookiesString_1(set_cookie).map((str) => parseString_1(str)));
        }
        const proxy = new Proxy(response, {
          get(response2, key2, _receiver) {
            async function text() {
              const body = await response2.text();
              const headers = {};
              for (const [key3, value] of response2.headers) {
                if (key3 !== "set-cookie" && key3 !== "etag") {
                  headers[key3] = value;
                }
              }
              if (!opts.body || typeof opts.body === "string") {
                const status_number = Number(response2.status);
                if (isNaN(status_number)) {
                  throw new Error(`response.status is not a number. value: "${response2.status}" type: ${typeof response2.status}`);
                }
                fetched.push({
                  url: requested,
                  body: opts.body,
                  response: {
                    status: status_number,
                    statusText: response2.statusText,
                    headers,
                    body
                  }
                });
              }
              if (dependency) {
                dependency.body = body;
              }
              return body;
            }
            if (key2 === "arrayBuffer") {
              return async () => {
                const buffer = await response2.arrayBuffer();
                if (dependency) {
                  dependency.body = new Uint8Array(buffer);
                }
                return buffer;
              };
            }
            if (key2 === "text") {
              return text;
            }
            if (key2 === "json") {
              return async () => {
                return JSON.parse(await text());
              };
            }
            return Reflect.get(response2, key2, response2);
          }
        });
        return proxy;
      },
      stuff: __spreadValues({}, stuff),
      status: is_error ? status ?? null : null,
      error: is_error ? error2 ?? null : null
    };
    if (options.dev) {
      Object.defineProperty(load_input, "page", {
        get: () => {
          throw new Error("`page` in `load` functions has been replaced by `url` and `params`");
        }
      });
    }
    loaded = await module2.load.call(null, load_input);
    if (!loaded) {
      throw new Error(`load function must return a value${options.dev ? ` (${node.entry})` : ""}`);
    }
  } else if (shadow.body) {
    loaded = {
      props: shadow.body
    };
  } else {
    loaded = {};
  }
  if (shadow.body && state.prerender) {
    const pathname = `${event.url.pathname.replace(/\/$/, "")}/__data.json`;
    const dependency = {
      response: new Response(void 0),
      body: JSON.stringify(shadow.body)
    };
    state.prerender.dependencies.set(pathname, dependency);
  }
  return {
    node,
    props: shadow.body,
    loaded: normalize(loaded),
    stuff: loaded.stuff || stuff,
    fetched,
    set_cookie_headers: new_cookies.map((new_cookie) => {
      const _a4 = new_cookie, { name, value } = _a4, options2 = __objRest(_a4, ["name", "value"]);
      return serialize_1(name, value, options2);
    }),
    uses_credentials
  };
}
async function load_shadow_data(route, event, options, prerender) {
  if (!route.shadow)
    return {};
  try {
    const mod = await route.shadow();
    if (prerender && (mod.post || mod.put || mod.del || mod.patch)) {
      throw new Error("Cannot prerender pages that have endpoints with mutative methods");
    }
    const method = normalize_request_method(event);
    const is_get = method === "head" || method === "get";
    const handler = method === "head" ? mod.head || mod.get : mod[method];
    if (!handler && !is_get) {
      return {
        status: 405,
        error: new Error(`${method} method not allowed`)
      };
    }
    const data = {
      status: 200,
      cookies: [],
      body: {}
    };
    if (!is_get) {
      const result = await handler(event);
      if (result.fallthrough) {
        throw new Error("fallthrough is no longer supported. Use matchers instead: https://kit.svelte.dev/docs/routing#advanced-routing-matching");
      }
      const { status, headers, body } = validate_shadow_output(result);
      data.status = status;
      add_cookies(data.cookies, headers);
      if (status >= 300 && status < 400) {
        data.redirect = headers instanceof Headers ? headers.get("location") : headers.location;
        return data;
      }
      data.body = body;
    }
    const get8 = method === "head" && mod.head || mod.get;
    if (get8) {
      const result = await get8(event);
      if (result.fallthrough) {
        throw new Error("fallthrough is no longer supported. Use matchers instead: https://kit.svelte.dev/docs/routing#advanced-routing-matching");
      }
      const { status, headers, body } = validate_shadow_output(result);
      add_cookies(data.cookies, headers);
      data.status = status;
      if (status >= 400) {
        data.error = new Error("Failed to load data");
        return data;
      }
      if (status >= 300) {
        data.redirect = headers instanceof Headers ? headers.get("location") : headers.location;
        return data;
      }
      data.body = __spreadValues(__spreadValues({}, body), data.body);
    }
    return data;
  } catch (e2) {
    const error2 = coalesce_to_error(e2);
    options.handle_error(error2, event);
    return {
      status: 500,
      error: error2
    };
  }
}
function add_cookies(target, headers) {
  const cookies = headers["set-cookie"];
  if (cookies) {
    if (Array.isArray(cookies)) {
      target.push(...cookies);
    } else {
      target.push(cookies);
    }
  }
}
function validate_shadow_output(result) {
  const { status = 200, body = {} } = result;
  let headers = result.headers || {};
  if (headers instanceof Headers) {
    if (headers.has("set-cookie")) {
      throw new Error("Endpoint request handler cannot use Headers interface with Set-Cookie headers");
    }
  } else {
    headers = lowercase_keys(headers);
  }
  if (!is_pojo(body)) {
    throw new Error("Body returned from endpoint request handler must be a plain object");
  }
  return { status, headers, body };
}
async function respond_with_error({
  event,
  options,
  state,
  $session,
  status,
  error: error2,
  resolve_opts
}) {
  try {
    const branch = [];
    let stuff = {};
    if (resolve_opts.ssr) {
      const default_layout = await options.manifest._.nodes[0]();
      const default_error = await options.manifest._.nodes[1]();
      const layout_loaded = await load_node({
        event,
        options,
        state,
        route: null,
        node: default_layout,
        $session,
        stuff: {},
        is_error: false,
        is_leaf: false
      });
      const error_loaded = await load_node({
        event,
        options,
        state,
        route: null,
        node: default_error,
        $session,
        stuff: layout_loaded ? layout_loaded.stuff : {},
        is_error: true,
        is_leaf: false,
        status,
        error: error2
      });
      branch.push(layout_loaded, error_loaded);
      stuff = error_loaded.stuff;
    }
    return await render_response({
      options,
      state,
      $session,
      page_config: {
        hydrate: options.hydrate,
        router: options.router
      },
      stuff,
      status,
      error: error2,
      branch,
      event,
      resolve_opts
    });
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options.handle_error(error3, event);
    return new Response(error3.stack, {
      status: 500
    });
  }
}
async function respond$1(opts) {
  const { event, options, state, $session, route, resolve_opts } = opts;
  let nodes;
  if (!resolve_opts.ssr) {
    return await render_response(__spreadProps(__spreadValues({}, opts), {
      branch: [],
      page_config: {
        hydrate: true,
        router: true
      },
      status: 200,
      error: null,
      event,
      stuff: {}
    }));
  }
  try {
    nodes = await Promise.all(route.a.map((n) => n == void 0 ? n : options.manifest._.nodes[n]()));
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options.handle_error(error3, event);
    return await respond_with_error({
      event,
      options,
      state,
      $session,
      status: 500,
      error: error3,
      resolve_opts
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  let page_config = get_page_config(leaf, options);
  if (state.prerender) {
    const should_prerender = leaf.prerender ?? state.prerender.default;
    if (!should_prerender) {
      return new Response(void 0, {
        status: 204
      });
    }
  }
  let branch = [];
  let status = 200;
  let error2 = null;
  let set_cookie_headers = [];
  let stuff = {};
  ssr:
    if (resolve_opts.ssr) {
      for (let i2 = 0; i2 < nodes.length; i2 += 1) {
        const node = nodes[i2];
        let loaded;
        if (node) {
          try {
            loaded = await load_node(__spreadProps(__spreadValues({}, opts), {
              node,
              stuff,
              is_error: false,
              is_leaf: i2 === nodes.length - 1
            }));
            set_cookie_headers = set_cookie_headers.concat(loaded.set_cookie_headers);
            if (loaded.loaded.redirect) {
              return with_cookies(new Response(void 0, {
                status: loaded.loaded.status,
                headers: {
                  location: loaded.loaded.redirect
                }
              }), set_cookie_headers);
            }
            if (loaded.loaded.error) {
              ({ status, error: error2 } = loaded.loaded);
            }
          } catch (err) {
            const e2 = coalesce_to_error(err);
            options.handle_error(e2, event);
            status = 500;
            error2 = e2;
          }
          if (loaded && !error2) {
            branch.push(loaded);
          }
          if (error2) {
            while (i2--) {
              if (route.b[i2]) {
                const index = route.b[i2];
                const error_node = await options.manifest._.nodes[index]();
                let node_loaded;
                let j = i2;
                while (!(node_loaded = branch[j])) {
                  j -= 1;
                }
                try {
                  const error_loaded = await load_node(__spreadProps(__spreadValues({}, opts), {
                    node: error_node,
                    stuff: node_loaded.stuff,
                    is_error: true,
                    is_leaf: false,
                    status,
                    error: error2
                  }));
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  page_config = get_page_config(error_node.module, options);
                  branch = branch.slice(0, j + 1).concat(error_loaded);
                  stuff = __spreadValues(__spreadValues({}, node_loaded.stuff), error_loaded.stuff);
                  break ssr;
                } catch (err) {
                  const e2 = coalesce_to_error(err);
                  options.handle_error(e2, event);
                  continue;
                }
              }
            }
            return with_cookies(await respond_with_error({
              event,
              options,
              state,
              $session,
              status,
              error: error2,
              resolve_opts
            }), set_cookie_headers);
          }
        }
        if (loaded && loaded.loaded.stuff) {
          stuff = __spreadValues(__spreadValues({}, stuff), loaded.loaded.stuff);
        }
      }
    }
  try {
    return with_cookies(await render_response(__spreadProps(__spreadValues({}, opts), {
      stuff,
      event,
      page_config,
      status,
      error: error2,
      branch: branch.filter(Boolean)
    })), set_cookie_headers);
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options.handle_error(error3, event);
    return with_cookies(await respond_with_error(__spreadProps(__spreadValues({}, opts), {
      status: 500,
      error: error3
    })), set_cookie_headers);
  }
}
function get_page_config(leaf, options) {
  if ("ssr" in leaf) {
    throw new Error("`export const ssr` has been removed \u2014 use the handle hook instead: https://kit.svelte.dev/docs/hooks#handle");
  }
  return {
    router: "router" in leaf ? !!leaf.router : options.router,
    hydrate: "hydrate" in leaf ? !!leaf.hydrate : options.hydrate
  };
}
function with_cookies(response, set_cookie_headers) {
  if (set_cookie_headers.length) {
    set_cookie_headers.forEach((value) => {
      response.headers.append("set-cookie", value);
    });
  }
  return response;
}
async function render_page(event, route, options, state, resolve_opts) {
  if (state.initiator === route) {
    return new Response(`Not found: ${event.url.pathname}`, {
      status: 404
    });
  }
  if (route.shadow) {
    const type = negotiate(event.request.headers.get("accept") || "text/html", [
      "text/html",
      "application/json"
    ]);
    if (type === "application/json") {
      return render_endpoint(event, await route.shadow());
    }
  }
  const $session = await options.hooks.getSession(event);
  return respond$1({
    event,
    options,
    state,
    $session,
    resolve_opts,
    route
  });
}
function negotiate(accept, types3) {
  const parts = accept.split(",").map((str, i2) => {
    const match2 = /([^/]+)\/([^;]+)(?:;q=([0-9.]+))?/.exec(str);
    if (match2) {
      const [, type, subtype, q = "1"] = match2;
      return { type, subtype, q: +q, i: i2 };
    }
    throw new Error(`Invalid Accept header: ${accept}`);
  }).sort((a, b) => {
    if (a.q !== b.q) {
      return b.q - a.q;
    }
    if (a.subtype === "*" !== (b.subtype === "*")) {
      return a.subtype === "*" ? 1 : -1;
    }
    if (a.type === "*" !== (b.type === "*")) {
      return a.type === "*" ? 1 : -1;
    }
    return a.i - b.i;
  });
  let accepted;
  let min_priority = Infinity;
  for (const mimetype of types3) {
    const [type, subtype] = mimetype.split("/");
    const priority = parts.findIndex((part) => (part.type === type || part.type === "*") && (part.subtype === subtype || part.subtype === "*"));
    if (priority !== -1 && priority < min_priority) {
      accepted = mimetype;
      min_priority = priority;
    }
  }
  return accepted;
}
function exec(match2, names, types3, matchers) {
  const params = {};
  for (let i2 = 0; i2 < names.length; i2 += 1) {
    const name = names[i2];
    const type = types3[i2];
    const value = match2[i2 + 1] || "";
    if (type) {
      const matcher = matchers[type];
      if (!matcher)
        throw new Error(`Missing "${type}" param matcher`);
      if (!matcher(value))
        return;
    }
    params[name] = value;
  }
  return params;
}
var DATA_SUFFIX = "/__data.json";
var default_transform = ({ html }) => html;
async function respond(request, options, state) {
  var _a4, _b, _c;
  let url = new URL(request.url);
  const normalized = normalize_path(url.pathname, options.trailing_slash);
  if (normalized !== url.pathname && !((_a4 = state.prerender) == null ? void 0 : _a4.fallback)) {
    return new Response(void 0, {
      status: 301,
      headers: {
        location: (normalized.startsWith("//") ? url.origin + normalized : normalized) + (url.search === "?" ? "" : url.search)
      }
    });
  }
  const { parameter, allowed } = options.method_override;
  const method_override = (_b = url.searchParams.get(parameter)) == null ? void 0 : _b.toUpperCase();
  if (method_override) {
    if (request.method === "POST") {
      if (allowed.includes(method_override)) {
        request = new Proxy(request, {
          get: (target, property, _receiver) => {
            if (property === "method")
              return method_override;
            return Reflect.get(target, property, target);
          }
        });
      } else {
        const verb = allowed.length === 0 ? "enabled" : "allowed";
        const body = `${parameter}=${method_override} is not ${verb}. See https://kit.svelte.dev/docs/configuration#methodoverride`;
        return new Response(body, {
          status: 400
        });
      }
    } else {
      throw new Error(`${parameter}=${method_override} is only allowed with POST requests`);
    }
  }
  let decoded = decodeURI(url.pathname);
  let route = null;
  let params = {};
  if (options.paths.base && !((_c = state.prerender) == null ? void 0 : _c.fallback)) {
    if (!decoded.startsWith(options.paths.base)) {
      return new Response(void 0, { status: 404 });
    }
    decoded = decoded.slice(options.paths.base.length) || "/";
  }
  const is_data_request = decoded.endsWith(DATA_SUFFIX);
  if (is_data_request) {
    decoded = decoded.slice(0, -DATA_SUFFIX.length) || "/";
    const normalized2 = normalize_path(url.pathname.slice(0, -DATA_SUFFIX.length), options.trailing_slash);
    url = new URL(url.origin + normalized2 + url.search);
  }
  if (!state.prerender || !state.prerender.fallback) {
    const matchers = await options.manifest._.matchers();
    for (const candidate of options.manifest._.routes) {
      const match2 = candidate.pattern.exec(decoded);
      if (!match2)
        continue;
      const matched = exec(match2, candidate.names, candidate.types, matchers);
      if (matched) {
        route = candidate;
        params = decode_params(matched);
        break;
      }
    }
  }
  const event = {
    get clientAddress() {
      if (!state.getClientAddress) {
        throw new Error(`${"@sveltejs/adapter-vercel"} does not specify getClientAddress. Please raise an issue`);
      }
      Object.defineProperty(event, "clientAddress", {
        value: state.getClientAddress()
      });
      return event.clientAddress;
    },
    locals: {},
    params,
    platform: state.platform,
    request,
    routeId: route && route.id,
    url
  };
  const removed = (property, replacement, suffix = "") => ({
    get: () => {
      throw new Error(`event.${property} has been replaced by event.${replacement}` + suffix);
    }
  });
  const details = ". See https://github.com/sveltejs/kit/pull/3384 for details";
  const body_getter = {
    get: () => {
      throw new Error("To access the request body use the text/json/arrayBuffer/formData methods, e.g. `body = await request.json()`" + details);
    }
  };
  Object.defineProperties(event, {
    method: removed("method", "request.method", details),
    headers: removed("headers", "request.headers", details),
    origin: removed("origin", "url.origin"),
    path: removed("path", "url.pathname"),
    query: removed("query", "url.searchParams"),
    body: body_getter,
    rawBody: body_getter
  });
  let resolve_opts = {
    ssr: true,
    transformPage: default_transform
  };
  try {
    const response = await options.hooks.handle({
      event,
      resolve: async (event2, opts) => {
        if (opts) {
          resolve_opts = {
            ssr: opts.ssr !== false,
            transformPage: opts.transformPage || default_transform
          };
        }
        if (state.prerender && state.prerender.fallback) {
          return await render_response({
            event: event2,
            options,
            state,
            $session: await options.hooks.getSession(event2),
            page_config: { router: true, hydrate: true },
            stuff: {},
            status: 200,
            error: null,
            branch: [],
            resolve_opts: __spreadProps(__spreadValues({}, resolve_opts), {
              ssr: false
            })
          });
        }
        if (route) {
          let response2;
          if (is_data_request && route.type === "page" && route.shadow) {
            response2 = await render_endpoint(event2, await route.shadow());
            if (request.headers.has("x-sveltekit-load")) {
              if (response2.status >= 300 && response2.status < 400) {
                const location = response2.headers.get("location");
                if (location) {
                  const headers = new Headers(response2.headers);
                  headers.set("x-sveltekit-location", location);
                  response2 = new Response(void 0, {
                    status: 204,
                    headers
                  });
                }
              }
            }
          } else {
            response2 = route.type === "endpoint" ? await render_endpoint(event2, await route.load()) : await render_page(event2, route, options, state, resolve_opts);
          }
          if (response2) {
            if (response2.status === 200 && response2.headers.has("etag")) {
              let if_none_match_value = request.headers.get("if-none-match");
              if (if_none_match_value == null ? void 0 : if_none_match_value.startsWith('W/"')) {
                if_none_match_value = if_none_match_value.substring(2);
              }
              const etag = response2.headers.get("etag");
              if (if_none_match_value === etag) {
                const headers = new Headers({ etag });
                for (const key2 of [
                  "cache-control",
                  "content-location",
                  "date",
                  "expires",
                  "vary"
                ]) {
                  const value = response2.headers.get(key2);
                  if (value)
                    headers.set(key2, value);
                }
                return new Response(void 0, {
                  status: 304,
                  headers
                });
              }
            }
            return response2;
          }
        }
        if (!state.initiator) {
          const $session = await options.hooks.getSession(event2);
          return await respond_with_error({
            event: event2,
            options,
            state,
            $session,
            status: 404,
            error: new Error(`Not found: ${event2.url.pathname}`),
            resolve_opts
          });
        }
        if (state.prerender) {
          return new Response("not found", { status: 404 });
        }
        return await fetch(request);
      },
      get request() {
        throw new Error("request in handle has been replaced with event" + details);
      }
    });
    if (response && !(response instanceof Response)) {
      throw new Error("handle must return a Response object" + details);
    }
    return response;
  } catch (e2) {
    const error2 = coalesce_to_error(e2);
    options.handle_error(error2, event);
    try {
      const $session = await options.hooks.getSession(event);
      return await respond_with_error({
        event,
        options,
        state,
        $session,
        status: 500,
        error: error2,
        resolve_opts
      });
    } catch (e22) {
      const error3 = coalesce_to_error(e22);
      return new Response(options.dev ? error3.stack : error3.message, {
        status: 500
      });
    }
  }
}
var base = "";
var assets = "";
function set_paths(paths) {
  base = paths.base;
  assets = paths.assets || base;
}
var template = ({ head, body, assets: assets2, nonce }) => '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <link rel="icon" href="/favicon.png" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n\n    <link rel="manifest" crossorigin="use-credentials" href="/manifest.json" />\n    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />\n    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />\n    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />\n    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#000000" />\n    <link rel="shortcut icon" href="/favicon.ico" />\n    <meta name="msapplication-TileColor" content="#000000" />\n    <meta name="msapplication-config" content="/browserconfig.xml" />\n    <meta name="theme-color" content="#000" />\n\n    <link rel="stylesheet" href="/global.css" />\n    ' + head + '\n  </head>\n  <body>\n    <div id="svelte">' + body + "</div>\n  </body>\n</html>\n";
var read = null;
set_paths({ "base": "", "assets": "" });
var Server = class {
  constructor(manifest2) {
    this.options = {
      amp: false,
      csp: { "mode": "auto", "directives": { "upgrade-insecure-requests": false, "block-all-mixed-content": false } },
      dev: false,
      floc: false,
      get_stack: (error2) => String(error2),
      handle_error: (error2, event) => {
        this.options.hooks.handleError({
          error: error2,
          event,
          get request() {
            throw new Error("request in handleError has been replaced with event. See https://github.com/sveltejs/kit/pull/3384 for details");
          }
        });
        error2.stack = this.options.get_stack(error2);
      },
      hooks: null,
      hydrate: true,
      manifest: manifest2,
      method_override: { "parameter": "_method", "allowed": [] },
      paths: { base, assets },
      prefix: assets + "/_app/",
      prerender: true,
      read,
      root: Root,
      service_worker: base + "/service-worker.js",
      router: true,
      template,
      template_contains_nonce: false,
      trailing_slash: "never"
    };
  }
  async respond(request, options = {}) {
    if (!(request instanceof Request)) {
      throw new Error("The first argument to server.respond must be a Request object. See https://github.com/sveltejs/kit/pull/3384 for details");
    }
    if (!this.options.hooks) {
      const module2 = await Promise.resolve().then(() => (init_index_17102cb9(), index_17102cb9_exports));
      this.options.hooks = {
        getSession: module2.getSession || (() => ({})),
        handle: module2.handle || (({ event, resolve: resolve2 }) => resolve2(event)),
        handleError: module2.handleError || (({ error: error2 }) => console.error(error2.stack)),
        externalFetch: module2.externalFetch || fetch
      };
    }
    return respond(request, this.options, options);
  }
};

// .svelte-kit/vercel-tmp/manifest.js
var manifest = {
  appDir: "_app",
  assets: /* @__PURE__ */ new Set(["android-chrome-192x192.png", "android-chrome-512x512.png", "apple-touch-icon.png", "assets/about-illustration.svg", "assets/authors/aaron-lieberman.webp", "assets/authors/alan-cortez.webp", "assets/authors/alex-truong.webp", "assets/authors/andrew-lau.webp", "assets/authors/andy-lasso.webp", "assets/authors/angel-armendariz.webp", "assets/authors/armanul-ambia.webp", "assets/authors/dalisa-nguyen.webp", "assets/authors/daniel-truong.webp", "assets/authors/duc-dinh.webp", "assets/authors/ean-mcgilvery.webp", "assets/authors/eduardo-gomez.webp", "assets/authors/ethan-davidson.webp", "assets/authors/eugene-lee.webp", "assets/authors/ibrahim-israr.webp", "assets/authors/iftekharul-islam.webp", "assets/authors/jacob-nguyen.webp", "assets/authors/jason-anthony.webp", "assets/authors/jason-wong.webp", "assets/authors/joel-anil-john.webp", "assets/authors/johnathan-carranza.webp", "assets/authors/johnson-tong.webp", "assets/authors/jorge-mejia.webp", "assets/authors/joshua-hughes.webp", "assets/authors/justin-stitt.webp", "assets/authors/karnikaa-velumani.webp", "assets/authors/kavit-sanghavi.webp", "assets/authors/kayla-nguyen.webp", "assets/authors/kevin-dillon.webp", "assets/authors/kirsten-ochoa.webp", "assets/authors/lisa-hong.webp", "assets/authors/mike-ploythai.webp", "assets/authors/minh-le.webp", "assets/authors/nguyen-le.webp", "assets/authors/nicolas-renteria.webp", "assets/authors/nolan-lee.webp", "assets/authors/nurhaliza-hassan.webp", "assets/authors/parth-sharma.webp", "assets/authors/placeholder.webp", "assets/authors/rina-watanabe.webp", "assets/authors/sami-bajwa.webp", "assets/authors/samuel-sandoval.webp", "assets/authors/samuel-valls.webp", "assets/authors/serena-naranjo.webp", "assets/authors/shaleen-mathur.webp", "assets/authors/stephanie-pocci.webp", "assets/authors/taylor-noh.webp", "assets/authors/tommy-le.webp", "assets/authors/wesley-chou.webp", "assets/authors/wilbert-rodriguez.webp", "assets/badges/algo.svg", "assets/badges/create.svg", "assets/badges/dev.svg", "assets/badges/feed-icon.svg", "assets/badges/general.svg", "assets/badges/nodebuds.svg", "assets/badges/with-shadow/algo.svg", "assets/badges/with-shadow/create.svg", "assets/badges/with-shadow/dev.svg", "assets/badges/with-shadow/nodebuds.svg", "assets/bluecalender.svg", "assets/png/404-h.png", "assets/png/404-v.png", "assets/png/acm-algo-badge.png", "assets/png/acm-create-badge.png", "assets/png/acm-csuf-badge.png", "assets/png/acm-dev-badge.png", "assets/png/acm-shark.png", "assets/png/hero-illustration.png", "assets/png/hero-new.png", "assets/png/lost-frank.png", "assets/png/node-buds-badge.png", "assets/png/node-buds-testimonial-illustration.png", "assets/png/why-join-illustration.png", "assets/png/why-join-node-buds-illustration.png", "assets/readme-logomark.svg", "browserconfig.xml", "favicon-16x16.png", "favicon-32x32.png", "favicon.ico", "favicon.png", "global.css", "manifest.json", "mstile-150x150.png", "safari-pinned-tab.svg", "service-worker.js"]),
  mimeTypes: { ".png": "image/png", ".svg": "image/svg+xml", ".webp": "image/webp", ".xml": "application/xml", ".ico": "image/vnd.microsoft.icon", ".css": "text/css", ".json": "application/json" },
  _: {
    entry: { "file": "start-38aabb48.js", "js": ["start-38aabb48.js", "chunks/index-462fa7ca.js", "chunks/index-af743adc.js"], "css": [] },
    nodes: [
      () => Promise.resolve().then(() => (init__(), __exports)),
      () => Promise.resolve().then(() => (init__2(), __exports2)),
      () => Promise.resolve().then(() => (init__3(), __exports3)),
      () => Promise.resolve().then(() => (init__4(), __exports4)),
      () => Promise.resolve().then(() => (init__5(), __exports5)),
      () => Promise.resolve().then(() => (init__6(), __exports6)),
      () => Promise.resolve().then(() => (init__7(), __exports7)),
      () => Promise.resolve().then(() => (init__8(), __exports8)),
      () => Promise.resolve().then(() => (init__9(), __exports9)),
      () => Promise.resolve().then(() => (init__10(), __exports10))
    ],
    routes: [
      {
        type: "page",
        id: "",
        pattern: /^\/$/,
        names: [],
        types: [],
        path: "/",
        shadow: null,
        a: [0, 2],
        b: [1]
      },
      {
        type: "endpoint",
        id: "events.json",
        pattern: /^\/events\.json$/,
        names: [],
        types: [],
        load: () => Promise.resolve().then(() => (init_index_json_ts(), index_json_ts_exports))
      },
      {
        type: "endpoint",
        id: "blog.xml",
        pattern: /^\/blog\.xml$/,
        names: [],
        types: [],
        load: () => Promise.resolve().then(() => (init_index_xml_ts(), index_xml_ts_exports))
      },
      {
        type: "endpoint",
        id: "blog.json",
        pattern: /^\/blog\.json$/,
        names: [],
        types: [],
        load: () => Promise.resolve().then(() => (init_index_json_ts2(), index_json_ts_exports2))
      },
      {
        type: "page",
        id: "about",
        pattern: /^\/about\/?$/,
        names: [],
        types: [],
        path: "/about",
        shadow: null,
        a: [0, 3],
        b: [1]
      },
      {
        type: "page",
        id: "blog",
        pattern: /^\/blog\/?$/,
        names: [],
        types: [],
        path: "/blog",
        shadow: null,
        a: [0, 4],
        b: [1]
      },
      {
        type: "page",
        id: "events",
        pattern: /^\/events\/?$/,
        names: [],
        types: [],
        path: "/events",
        shadow: null,
        a: [0, 5],
        b: [1]
      },
      {
        type: "page",
        id: "nodebuds",
        pattern: /^\/nodebuds\/?$/,
        names: [],
        types: [],
        path: "/nodebuds",
        shadow: null,
        a: [0, 6],
        b: [1]
      },
      {
        type: "page",
        id: "paths",
        pattern: /^\/paths\/?$/,
        names: [],
        types: [],
        path: "/paths",
        shadow: null,
        a: [0, 7],
        b: [1]
      },
      {
        type: "page",
        id: "privacy",
        pattern: /^\/privacy\/?$/,
        names: [],
        types: [],
        path: "/privacy",
        shadow: null,
        a: [0, 8],
        b: [1]
      },
      {
        type: "endpoint",
        id: "blog/[id].txt",
        pattern: /^\/blog\/([^/]+?)\.txt$/,
        names: ["id"],
        types: [null],
        load: () => Promise.resolve().then(() => (init_id_txt_ts(), id_txt_ts_exports))
      },
      {
        type: "endpoint",
        id: "blog/[id].json",
        pattern: /^\/blog\/([^/]+?)\.json$/,
        names: ["id"],
        types: [null],
        load: () => Promise.resolve().then(() => (init_id_json_ts(), id_json_ts_exports))
      },
      {
        type: "page",
        id: "blog/[id]",
        pattern: /^\/blog\/([^/]+?)\/?$/,
        names: ["id"],
        types: [null],
        path: null,
        shadow: null,
        a: [0, 9],
        b: [1]
      },
      {
        type: "endpoint",
        id: "[link=link].svg",
        pattern: /^\/([^/]+?)\.svg$/,
        names: ["link"],
        types: ["link"],
        load: () => Promise.resolve().then(() => (init_link_link_svg_ts(), link_link_svg_ts_exports))
      }
    ],
    matchers: async () => {
      const { match: link } = await Promise.resolve().then(() => (init_link(), link_exports));
      return { link };
    }
  }
};

// .svelte-kit/vercel-tmp/entry.js
var server = new Server(manifest);
var entry_default = async (req, res) => {
  let request;
  try {
    request = await getRequest(`https://${req.headers.host}`, req);
  } catch (err) {
    res.statusCode = err.status || 400;
    return res.end(err.reason || "Invalid request body");
  }
  setResponse(res, await server.respond(request, {
    getClientAddress() {
      return request.headers.get("x-forwarded-for");
    }
  }));
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * rrule.js - Library for working with recurrence rules for calendar dates.
 * https://github.com/jakubroztocil/rrule
 *
 * Copyright 2010, Jakub Roztocil and Lars Schoning
 * Licenced under the BSD licence.
 * https://github.com/jakubroztocil/rrule/blob/master/LICENCE
 *
 * Based on:
 * python-dateutil - Extensions to the standard Python datetime module.
 * Copyright (c) 2003-2011 - Gustavo Niemeyer <gustavo@niemeyer.net>
 * Copyright (c) 2012 - Tomi Pievilinen <tomi.pievilainen@iki.fi>
 * https://github.com/jakubroztocil/rrule/blob/master/LICENCE
 *
 */
/*!
* rrule.js - Library for working with recurrence rules for calendar dates.
* https://github.com/jakubroztocil/rrule
*
* Copyright 2010, Jakub Roztocil and Lars Schoning
* Licenced under the BSD licence.
* https://github.com/jakubroztocil/rrule/blob/master/LICENCE
*
*/
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
/*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
/*! https://mths.be/he v1.2.0 by @mathias | MIT license */
